<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (X11; I; SunOS 5.5.1 sun4m) [Netscape]">
   <title>12: Sovraccaricamento degli operatori</title>
</head>
<body bgcolor="#FFFFFF">

<center><a href="http://www.MindView.net/"><img SRC="mindview-head.gif" ALT="MindView Inc." BORDER=0 height=81 width=636></a>
</center><p><center><font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="README-HTML.txt">Suggerimenti</a></font></u>
] [ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/SolutionGuide.html">Soluzioni
degli Esercizi</a></font></u>] [ <u><font color="#0000FF"><a href="http://www.mindview.net/ThinkingInCPP2e.html">Volume
2</a></font></u> ] [ <u><font color="#0000FF"><a href="http://www.mindview.net/MailingList.html">Newsletter
Gratuita</a></font></u> ]</font></font>
<br><font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/#PublicSeminars">Seminari</a></font></u>
] [ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/#SeminarsOnCD">Seminari
su CD ROM</a></font></u> ] [ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulenza</a></font></u>]</font></font></center>

<center>
<h2>
<font face="Verdana">Pensare in C++, seconda ed. Volume 1</font></h2></center>

<center>
<h3>
<font face="Verdana">&copy;2000 by Bruce Eckel</font></h3></center>

<center>
  <font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="Capitolo11.html">Capitolo 
  Precedente </a></font></u>] [ <u><font color="#0000FF"><a href="Contents.html">Indice 
  Generale</a></font></u> ] [ <u><font color="#0000FF"><a href="DocIndex.html">Indice 
  Analitico </a></font></u>] [ <u><font color="#0000FF"><a href="Capitolo13.html">Prossimo 
  Capitolo</a></font></u> ]</font></font> 
  <p><font face="Georgia, Times New Roman, Times, serif"><font size=-1>trad.
italiana e adattamento a cura di Giacomo Grande</font></font></center>

<h1><span lang=IT style='font-family:Verdana;
mso-ansi-language:IT'>12: Sovraccaricamento degli operatori<o:p></o:p></span></h1>

<p><span lang=IT style='font-size:13.5pt;font-family:Verdana;mso-ansi-language:
IT'>Il sovraccaricamento degli operatori è semplicemente "uno zuccherino
sintattico," che vuol dire un altro modo di chiamare le funzioni.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La differenza
è che gli argomenti di questa funzione non appaiono dentro le parentesi, ma
piuttosto circondano o seguono caratteri che abbiamo sempre pensato come
immutabili operatori.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Ci sono due
differenze tra l'uso di un operatore e una chiamata ad una funzione ordinaria.
La sintassi è differente; un operatore spesso è<span style="mso-spacerun:
yes">&nbsp; </span>"chiamato" mettendolo tra gli argomenti o a volte dopo gli
argomenti. La seconda differenza è che il compilatore stabilisce quale "funzione"
chiamare. Per esempio, se usiamo l'operatore <b>+</b> con argomenti
floating-point, il compilatore<span style="mso-spacerun: yes">&nbsp; </span>"chiama"
la funzione per sommare due floating-point (questa "chiamata" è tipicamente l'atto
di mettere del codice in-line, o un'istruzione di un processore
floating-point). Se usiamo l'operatore <b>+</b> con un numero floating-point e
un int, il compilatore<span style="mso-spacerun: yes">&nbsp; </span>"chiama"
una funzione speciale per trasformare l' <b>int</b> in <b>float</b>, e poi<span
style="mso-spacerun: yes">&nbsp; </span>"chiama" il codice per sommare due floating-point.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Ma in<span
style="mso-spacerun: yes">&nbsp; </span>C++ è possibile definire nuovi
operatori che lavorano con le classi. Questa definizione è proprio come la
definizione di una funzione ordinaria, solo che il nome della funzione consiste
della parola chiave <b>operator</b> seguita dall'operatore. Questa è la sola
differenza e diventa una funzione come tutte le altre, che il compilatore
chiama quando vede il tipo appropriato.</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<p><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><a
name=Heading349></a><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Avvertenze &amp; rassicurazioni<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Si è portati ad essere 
  super entusiasti con il sovraccaricamento degli operatori. È un giocattolo divertente, 
  sulle prime. Ma ricordiamoci che è <i>solo</i> uno zuccherino sintattico, un 
  altro modo per chiamare una funzione. Guardando la cosa sotto questo aspetto, 
  non abbiamo nessuna ragione di sovraccaricare un operatore, se non ci permette 
  di rendere il codice che coinvolge la nostra classe più facile da scrivere e 
  soprattutto più facile da <i>leggere</i> (notare che si legge molto più codice 
  di quanto non se ne scriva). Se questo non è il caso, non ci dobbiamo preoccupare.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Un'altra reazione
diffusa al sovraccaricamento degli operatori è il panico; improvvisamente gli
operatori C non hanno più un significato familiare. "Ogni cosa è cambiata e
il mio codice C farà cose diverse!" Questo non è vero. Tutti gli operatori
che contengono solo dati di tipo predefinito non possono cambiare. Non potremo
mai sovraccaricare operatori del tipo</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>1 &lt;&lt; 4;</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>oppure</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>1.414 &lt;&lt; 2;</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Solo espressioni che
contengono tipi definiti dall'utente possono avere un operatore sovraccaricato.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><a
name=Heading350></a><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Sintassi<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Definire un operatore
sovraccaricato è come definire una funzione, ma il nome della funzione è <b>operator@</b>,
dove <b>@</b> rappresenta l'operatore da sovraccaricare. Il numero di argomenti
nella lista degli argomenti dell'operatore sovraccaricato dipende da due
fattori:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<ol start=1 type=1>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo3;tab-stops:list .5in'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Se è un operatore unario
     (un solo argomento) o binario (due argomenti).</span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo3;tab-stops:list .5in'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Se l'operatore è
     definito come funzione globale (un argomento se unario, due se binario) o
     come funzione membro (zero argomenti se unario, uno se binario &#8211; l'oggetto
     diventa l'argomento a sinistra dell'operatore).</span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>
</ol>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Qui c'è una piccola
classe che mostra la sintassi per il sovraccaricamento di un operatore :</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:OperatorOverloadingSyntax.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Integer {
  <font color=#0000ff>int</font> i;
<font color=#0000ff>public</font>:
  Integer(<font color=#0000ff>int</font> ii) : i(ii) {}
  <font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>+(<font color=#0000ff>const</font> Integer&amp; rv) <font color=#0000ff>const</font> {
    cout &lt;&lt; <font color=#004488>"operator+"</font> &lt;&lt; endl;
    <font color=#0000ff>return</font> Integer(i + rv.i);
  }
  Integer&amp;
  <font color=#0000ff>operator</font>+=(<font color=#0000ff>const</font> Integer&amp; rv) {
    cout &lt;&lt; <font color=#004488>"operator+="</font> &lt;&lt; endl;
    i += rv.i;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
};

<font color=#0000ff>int</font> main() {
  cout &lt;&lt; <font color=#004488>"built-in types:"</font> &lt;&lt; endl;
  <font color=#0000ff>int</font> i = 1, j = 2, k = 3;
  k += i + j;
  cout &lt;&lt; <font color=#004488>"user-defined types:"</font> &lt;&lt; endl;
  Integer ii(1), jj(2), kk(3);
  kk += ii + jj;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>I due operatori
sovraccaricati sono definiti come funzioni membro inline che si annunciano quando
vengono chiamate. Il singolo argomento è quello che appare alla destra dell'operatore
per operatori binari. Gli operatori unari non hanno argomenti quando definiti
come funzioni membro. La funzione membro viene chiamata per l'oggetto alla
sinistra dell'operatore.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Per operatori non-condizionali 
  (gli operatori condizionali restituiscono usualmente valori Boolean), quasi 
  sempre il valore di ritorno è un oggetto o un riferimento dello stesso tipo 
  su cui si sta operando, se i due argomenti sono dello stesso tipo (se non sono 
  dello stesso tipo, l'interpretazione di quello che potrebbe restituire sta a 
  noi). In questo modo possono essere costruite espressioni complicate, come:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>kk += ii + jj;</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>L' <b>operator+</b>
produce un nuovo <b>Integer</b> (temporaneo) che viene usato come argomento <b>rv</b>
per<span style="mso-spacerun: yes">&nbsp; </span><b>operator+=</b>. Questo dato
temporaneo viene distrutto quando non è più necessario.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><a
name=Heading351></a><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Operatori sovraccaricabili<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Benchè sia possibile
sovraccaricare quasi tutti gli operatori disponibili in C, l'uso del
sovraccaricamento degli operatori è abbastanza restrittivo. In particolare,
non si possono combinare operatori che non hanno nessun significato in C (come <b>**</b>
per rappresentare l'elevamento a potenza), non si può cambiare la precedenza
degli operatori, e non si può cambiare il numero di argomenti richiesti per un
operatore. Questo ha senso &#8211; tutte queste azioni produrrebbero operatori che
confondono il significato, invece di chiarirlo.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Le prossime due
sottosezioni mostrano esempi di tutti gli operatori<span style="mso-spacerun:
yes">&nbsp; </span>"regolari", sovraccaricati<span style="mso-spacerun:
yes">&nbsp; </span>nella forma che più verosimilmente viene usata.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><a
name=Heading352></a><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Operatori unari<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>L'esempio seguente
mostra la sintassi per sovraccaricare tutti gli operatori unari, sia nella
forma di funzioni globali (non <b>friend</b> di funzioni membro) che di
funzioni membro. Questo (esempio) va dalla classe <b>Integer </b>mostrata
precedentemente fino ad una nuova classe <b>byte</b>. Il significato degli
operatori specifici dipende dall'uso che ne vogliamo fare, ma teniamo presente
il cliente programmatore prima di fare cose inaspettate.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Qui c'è un catalogo
di tutte le funzioni unarie:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:OverloadingUnaryOperators.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Funzioni non-membro:</font>
<font color=#0000ff>class</font> Integer {
  <font color=#0000ff>long</font> i;
  Integer* This() { <font color=#0000ff>return</font> <font color=#0000ff>this</font>; }
<font color=#0000ff>public</font>:
  Integer(<font color=#0000ff>long</font> ll = 0) : i(ll) {}
  <font color=#009900>//Operatori senza effetti collaterali accettano argomenti const&amp;:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer&amp;
    <font color=#0000ff>operator</font>+(<font color=#0000ff>const</font> Integer&amp; a);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>-(<font color=#0000ff>const</font> Integer&amp; a);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>~(<font color=#0000ff>const</font> Integer&amp; a);
  <font color=#0000ff>friend</font> Integer*
    <font color=#0000ff>operator</font>&amp;(Integer&amp; a);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>!(<font color=#0000ff>const</font> Integer&amp; a);
  <font color=#009900>// Operatori con effetti collaterali hanno argomenti non-const&amp;:</font>
  <font color=#009900>// Prefisso:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer&amp;
    <font color=#0000ff>operator</font>++(Integer&amp; a);
  <font color=#009900>// Postfisso:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>++(Integer&amp; a, <font color=#0000ff>int</font>);
  <font color=#009900>// Prefisso:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer&amp;
    <font color=#0000ff>operator</font>--(Integer&amp; a);
  <font color=#009900>// Postfisso:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>--(Integer&amp; a, <font color=#0000ff>int</font>);
};

<font color=#009900>// Operatori globali:</font>
<font color=#0000ff>const</font> Integer&amp; <font color=#0000ff>operator</font>+(<font color=#0000ff>const</font> Integer&amp; a) {
  cout &lt;&lt; <font color=#004488>"+Integer\n"</font>;
  <font color=#0000ff>return</font> a; <font color=#009900>//L'operatore + unario non ha effetto sull'argomento</font>
}
<font color=#0000ff>const</font> Integer <font color=#0000ff>operator</font>-(<font color=#0000ff>const</font> Integer&amp; a) {
  cout &lt;&lt; <font color=#004488>"-Integer\n"</font>;
  <font color=#0000ff>return</font> Integer(-a.i);
}
<font color=#0000ff>const</font> Integer <font color=#0000ff>operator</font>~(<font color=#0000ff>const</font> Integer&amp; a) {
  cout &lt;&lt; <font color=#004488>"~Integer\n"</font>;
  <font color=#0000ff>return</font> Integer(~a.i);
}
Integer* <font color=#0000ff>operator</font>&amp;(Integer&amp; a) {
  cout &lt;&lt; <font color=#004488>"&amp;Integer\n"</font>;
  <font color=#0000ff>return</font> a.This(); <font color=#009900>// &amp;a è ricorsivo!</font>
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>!(<font color=#0000ff>const</font> Integer&amp; a) {
  cout &lt;&lt; <font color=#004488>"!Integer\n"</font>;
  <font color=#0000ff>return</font> !a.i;
}
<font color=#009900>// Prefisso; restituisce il valore incrementato</font>
<font color=#0000ff>const</font> Integer&amp; <font color=#0000ff>operator</font>++(Integer&amp; a) {
  cout &lt;&lt; <font color=#004488>"++Integer\n"</font>;
  a.i++;
  <font color=#0000ff>return</font> a;
}
<font color=#009900>// Postfisso; restituisce il valore prima di incrementarlo:</font>
<font color=#0000ff>const</font> Integer <font color=#0000ff>operator</font>++(Integer&amp; a, <font color=#0000ff>int</font>) {
  cout &lt;&lt; <font color=#004488>"Integer++\n"</font>;
  Integer before(a.i);
  a.i++;
  <font color=#0000ff>return</font> before;
}
<font color=#009900>// Prefisso; restituisce il valore decrementato</font>
<font color=#0000ff>const</font> Integer&amp; <font color=#0000ff>operator</font>--(Integer&amp; a) {
  cout &lt;&lt; <font color=#004488>"--Integer\n"</font>;
  a.i--;
  <font color=#0000ff>return</font> a;
}
<font color=#009900>// Postfisso; restituisce il valore prima di decrementarlo:</font>
<font color=#0000ff>const</font> Integer <font color=#0000ff>operator</font>--(Integer&amp; a, <font color=#0000ff>int</font>) {
  cout &lt;&lt; <font color=#004488>"Integer--\n"</font>;
  Integer before(a.i);
  a.i--;
  <font color=#0000ff>return</font> before;
}

<font color=#009900>// Mostra che gli operatori sovraccaricati funzionano:</font>
<font color=#0000ff>void</font> f(Integer a) {
  +a;
  -a;
  ~a;
  Integer* ip = &amp;a;
  !a;
  ++a;
  a++;
  --a;
  a--;
}

<font color=#009900>// Funzioni membro("this" implicito):</font>
<font color=#0000ff>class</font> Byte {
  <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> b;
<font color=#0000ff>public</font>:
  Byte(<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> bb = 0) : b(bb) {}
  <font color=#009900>// Non ci sono effetti collaterali: funzione membro const:</font>
  <font color=#0000ff>const</font> Byte&amp; <font color=#0000ff>operator</font>+() <font color=#0000ff>const</font> {
    cout &lt;&lt; <font color=#004488>"+Byte\n"</font>;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#0000ff>const</font> Byte <font color=#0000ff>operator</font>-() <font color=#0000ff>const</font> {
    cout &lt;&lt; <font color=#004488>"-Byte\n"</font>;
    <font color=#0000ff>return</font> Byte(-b);
  }
  <font color=#0000ff>const</font> Byte <font color=#0000ff>operator</font>~() <font color=#0000ff>const</font> {
    cout &lt;&lt; <font color=#004488>"~Byte\n"</font>;
    <font color=#0000ff>return</font> Byte(~b);
  }
  Byte <font color=#0000ff>operator</font>!() <font color=#0000ff>const</font> {
    cout &lt;&lt; <font color=#004488>"!Byte\n"</font>;
    <font color=#0000ff>return</font> Byte(!b);
  }
  Byte* <font color=#0000ff>operator</font>&amp;() {
    cout &lt;&lt; <font color=#004488>"&amp;Byte\n"</font>;
    <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
  }
  <font color=#009900>//Ci sono effetti collaterali: funzione membro non-const:</font>
  <font color=#0000ff>const</font> Byte&amp; <font color=#0000ff>operator</font>++() { <font color=#009900>// Prefisso</font>
    cout &lt;&lt; <font color=#004488>"++Byte\n"</font>;
    b++;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#0000ff>const</font> Byte <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) { <font color=#009900>// Postfisso</font>
    cout &lt;&lt; <font color=#004488>"Byte++\n"</font>;
    Byte before(b);
    b++;
    <font color=#0000ff>return</font> before;
  }
  <font color=#0000ff>const</font> Byte&amp; <font color=#0000ff>operator</font>--() { <font color=#009900>// Prefisso</font>
    cout &lt;&lt; <font color=#004488>"--Byte\n"</font>;
    --b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#0000ff>const</font> Byte <font color=#0000ff>operator</font>--(<font color=#0000ff>int</font>) { <font color=#009900>// Postfisso</font>
    cout &lt;&lt; <font color=#004488>"Byte--\n"</font>;
    Byte before(b);
    --b;
    <font color=#0000ff>return</font> before;
  }
};

<font color=#0000ff>void</font> g(Byte b) {
  +b;
  -b;
  ~b;
  Byte* bp = &amp;b;
  !b;
  ++b;
  b++;
  --b;
  b--;
}

<font color=#0000ff>int</font> main() {
  Integer a;
  f(a);
  Byte b;
  g(b);
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Le funzioni sono raggruppate 
  in base al modo in cui vengono passati i loro argomenti. Le linee guida su come 
  passare e restituire argomenti saranno fornite in seguito. Le forme di sopra 
  (e quelle che seguono nella prossima sezione) sono quelle tipicamente usate, 
  così assumiamo queste come modello per il sovraccaricamento dei nostri operatori.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Incremento &amp;
decremento<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">Gli 
  operatori sovraccaricati <b>++</b> e <b>&#8211; &#8211; </b>presentano un dilemma 
  perchè vorremmo essere in grado di chiamare funzioni diverse a seconda che essi 
  appaiano prima (prefisso) o dopo (postfisso) l'oggetto su cui operano. La soluzione 
  è semplice, ma qualche volta la gente trova la cosa un pò fuorviante sulle prime. 
  Quando il compilatore vede, per esempio, <b>++a</b> (pre-incremento), esso genera 
  una chiamata a <b>operator++(a)</b>; ma quando vede <b>a++,</b> esso genera 
  una chiamata a <b>operator++(a, int)</b>. Cioè il compilatore distingue le due 
  forme effettuando chiamate a due diverse funzioni sovraccaricate. In <b>OverloadingUnaryOperators.cpp</b> 
  per le versioni riferite alle funzioni membro, se il compilatore vede <b>++b</b>, 
  genera una chiamata a <b>B::operator++(&nbsp;)</b>; se vede <b>b++</b> chiama 
  <b>B::operator++(int)</b>.</font></span><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Tutto quello che l'utente 
  vede è che viene chiamata una funzione diversa per la versione con il prefisso 
  e quella con il postfisso. In fondo le chiamate alle due funzioni<span
style="mso-spacerun: yes">&nbsp; </span>hanno firme diverse, così esse si aggangiano 
  a due corpi di funzione diversi. Il compilatore passa un valore costante fittizio 
  per l'argomento <b>int</b> (il quale non ha mai un identificativo, in quanto 
  il suo valore non è mai usato) per generare una firma diversa per la versione 
  con postfisso.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Operatori binari<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Il listato seguente
ripete l'esempio di <b>OverloadingUnaryOperators.cpp</b> per gli operatori
binari, così abbiamo un esempio per tutti gli operatori che potremmo voler
sovraccaricare. </span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:Integer.h</font>
<font color=#009900>// Operatori sovraccaricati non-membri</font>
#ifndef INTEGER_H
#define INTEGER_H
#include &lt;iostream&gt;

<font color=#009900>// Funzioni non-membro:</font>
<font color=#0000ff>class</font> Integer { 
  <font color=#0000ff>long</font> i;
<font color=#0000ff>public</font>:
  Integer(<font color=#0000ff>long</font> ll = 0) : i(ll) {}
  <font color=#009900>// Operatori che creano valori nuovi, modificati:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>+(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>-(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>*(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>/(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>%(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>^(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>&amp;(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>|(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>&lt;&lt;(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Integer
    <font color=#0000ff>operator</font>&gt;&gt;(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#009900>//Modifica per assegnamento &amp; ritorno di lvalue:</font>
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>+=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>-=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>*=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>/=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>%=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>^=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>&amp;=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>|=(Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>&gt;&gt;=(Integer&amp; left,
                <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> Integer&amp;
    <font color=#0000ff>operator</font>&lt;&lt;=(Integer&amp; left,
                <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#009900>// Gli operatori condizionali restituiscono true/false:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>==(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>!=(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>&gt;(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>&lt;=(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>&gt;=(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>&amp;&amp;(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#0000ff>friend</font> <font color=#0000ff>int</font>
    <font color=#0000ff>operator</font>||(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right);
  <font color=#009900>// Scrive i contenuti su un ostream:</font>
  <font color=#0000ff>void</font> print(std::ostream&amp; os) <font color=#0000ff>const</font> { os &lt;&lt; i; }
}; 
#endif <font color=#009900>// INTEGER_H ///:~</font></PRE></FONT></BLOCKQUOTE>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:Integer.cpp {O}</font>
<font color=#009900>// Implementazione di operatori sovraccaricati</font>
#include <font color=#004488>"Integer.h"</font>
#include <font color=#004488>"../require.h"</font>

<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>+(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i + right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>-(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i - right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>*(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i * right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>/(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  require(right.i != 0, <font color=#004488>"divide by zero"</font>);
  <font color=#0000ff>return</font> Integer(left.i / right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>%(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  require(right.i != 0, <font color=#004488>"modulo by zero"</font>);
  <font color=#0000ff>return</font> Integer(left.i % right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>^(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i ^ right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>&amp;(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i &amp; right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>|(<font color=#0000ff>const</font> Integer&amp; left,
            <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i | right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>&lt;&lt;(<font color=#0000ff>const</font> Integer&amp; left,
             <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i &lt;&lt; right.i);
}
<font color=#0000ff>const</font> Integer
  <font color=#0000ff>operator</font>&gt;&gt;(<font color=#0000ff>const</font> Integer&amp; left,
             <font color=#0000ff>const</font> Integer&amp; right) {
  <font color=#0000ff>return</font> Integer(left.i &gt;&gt; right.i);
}
<font color=#009900>// Modifica per assegnamento &amp; ritorno di lvalue:</font>
Integer&amp; <font color=#0000ff>operator</font>+=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i += right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>-=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i -= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>*=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i *= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>/=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   require(right.i != 0, <font color=#004488>"divide by zero"</font>);
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i /= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>%=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   require(right.i != 0, <font color=#004488>"modulo by zero"</font>);
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i %= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>^=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i ^= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>&amp;=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i &amp;= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>|=(Integer&amp; left,
                    <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i |= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>&gt;&gt;=(Integer&amp; left,
                     <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i &gt;&gt;= right.i;
   <font color=#0000ff>return</font> left;
}
Integer&amp; <font color=#0000ff>operator</font>&lt;&lt;=(Integer&amp; left,
                     <font color=#0000ff>const</font> Integer&amp; right) {
   <font color=#0000ff>if</font>(&amp;left == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
   left.i &lt;&lt;= right.i;
   <font color=#0000ff>return</font> left;
}
<font color=#009900>// Gli operatori condizionali restituiscono true/false:</font>
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>==(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i == right.i;
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>!=(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i != right.i;
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i &lt; right.i;
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>&gt;(<font color=#0000ff>const</font> Integer&amp; left,
              <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i &gt; right.i;
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>&lt;=(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i &lt;= right.i;
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>&gt;=(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i &gt;= right.i;
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>&amp;&amp;(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i &amp;&amp; right.i;
}
<font color=#0000ff>int</font> <font color=#0000ff>operator</font>||(<font color=#0000ff>const</font> Integer&amp; left,
               <font color=#0000ff>const</font> Integer&amp; right) {
    <font color=#0000ff>return</font> left.i || right.i;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:IntegerTest.cpp</font>
<font color=#009900>//{L} Integer</font>
#include <font color=#004488>"Integer.h"</font>
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"IntegerTest.out"</font>);

<font color=#0000ff>void</font> h(Integer&amp; c1, Integer&amp; c2) {
  <font color=#009900>// Un'espressione complessa:</font>
  c1 += c1 * c2 + c2 % c1;
  #define TRY(OP) \
    out &lt;&lt; <font color=#004488>"c1 = "</font>; c1.print(out); \
    out &lt;&lt; <font color=#004488>", c2 = "</font>; c2.print(out); \
    out &lt;&lt; <font color=#004488>";  c1 "</font> #OP <font color=#004488>" c2 produces "</font>; \
    (c1 OP c2).print(out); \
    out &lt;&lt; endl;
  TRY(+) TRY(-) TRY(*) TRY(/)
  TRY(%) TRY(^) TRY(&amp;) TRY(|)
  TRY(&lt;&lt;) TRY(&gt;&gt;) TRY(+=) TRY(-=)
  TRY(*=) TRY(/=) TRY(%=) TRY(^=)
  TRY(&amp;=) TRY(|=) TRY(&gt;&gt;=) TRY(&lt;&lt;=)
  <font color=#009900>// Espressioni condizionali:</font>
  #define TRYC(OP) \
    out &lt;&lt; <font color=#004488>"c1 = "</font>; c1.print(out); \
    out &lt;&lt; <font color=#004488>", c2 = "</font>; c2.print(out); \
    out &lt;&lt; <font color=#004488>";  c1 "</font> #OP <font color=#004488>" c2 produces "</font>; \
    out &lt;&lt; (c1 OP c2); \
    out &lt;&lt; endl;
  TRYC(&lt;) TRYC(&gt;) TRYC(==) TRYC(!=) TRYC(&lt;=)
  TRYC(&gt;=) TRYC(&amp;&amp;) TRYC(||)
} 

<font color=#0000ff>int</font> main() {
  cout &lt;&lt; <font color=#004488>"friend functions"</font> &lt;&lt; endl;
  Integer c1(47), c2(9);
  h(c1, c2);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:Byte.h</font>
<font color=#009900>// Operatori sovraccaricati membri di classi</font>
#ifndef BYTE_H
#define BYTE_H
#include <font color=#004488>"../require.h"</font>
#include &lt;iostream&gt;
<font color=#009900>// Funzioni membro ("this" implicito):</font>
<font color=#0000ff>class</font> Byte { 
  <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> b;
<font color=#0000ff>public</font>:
  Byte(<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> bb = 0) : b(bb) {}
  <font color=#009900>// Senza effetti collaterali: funzioni membro const:</font>
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>+(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b + right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>-(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b - right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>*(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b * right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>/(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    require(right.b != 0, <font color=#004488>"divide by zero"</font>);
    <font color=#0000ff>return</font> Byte(b / right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>%(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    require(right.b != 0, <font color=#004488>"modulo by zero"</font>);
    <font color=#0000ff>return</font> Byte(b % right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>^(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b ^ right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>&amp;(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b &amp; right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>|(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b | right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>&lt;&lt;(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b &lt;&lt; right.b);
  }
  <font color=#0000ff>const</font> Byte
    <font color=#0000ff>operator</font>&gt;&gt;(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Byte(b &gt;&gt; right.b);
  }
  <font color=#009900>// Modifica per assegnamento &amp; ritorno di lvalue.</font>
  <font color=#009900>// operator= può essere solo funzione membro:</font>
  Byte&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#009900>// Gestisce l'auto-assegnamento:</font>
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
    b = right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>+=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b += right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>-=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b -= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>*=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b *= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>/=(<font color=#0000ff>const</font> Byte&amp; right) {
    require(right.b != 0, <font color=#004488>"divide by zero"</font>);
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b /= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>%=(<font color=#0000ff>const</font> Byte&amp; right) {
    require(right.b != 0, <font color=#004488>"modulo by zero"</font>);
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b %= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>^=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b ^= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>&amp;=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b &amp;= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>|=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b |= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>&gt;&gt;=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b &gt;&gt;= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  Byte&amp; <font color=#0000ff>operator</font>&lt;&lt;=(<font color=#0000ff>const</font> Byte&amp; right) {
    <font color=#0000ff>if</font>(<font color=#0000ff>this</font> == &amp;right) {<font color=#009900>/* auto-assegnamento */</font>}
    b &lt;&lt;= right.b;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#009900>// Operatori condizionali restituiscono true/false:</font>
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>==(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b == right.b;
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>!=(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b != right.b;
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b &lt; right.b;
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>&gt;(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b &gt; right.b;
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>&lt;=(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b &lt;= right.b;
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>&gt;=(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b &gt;= right.b;
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>&amp;&amp;(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b &amp;&amp; right.b;
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>||(<font color=#0000ff>const</font> Byte&amp; right) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> b || right.b;
  }
  <font color=#009900>// Scrive i contenuti su un ostream:</font>
  <font color=#0000ff>void</font> print(std::ostream&amp; os) <font color=#0000ff>const</font> {
    os &lt;&lt; <font color=#004488>"0x"</font> &lt;&lt; std::hex &lt;&lt; <font color=#0000ff>int</font>(b) &lt;&lt; std::dec;
  }
}; 
#endif <font color=#009900>// BYTE_H ///:~</font></PRE></FONT></BLOCKQUOTE>


<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:ByteTest.cpp</font>
#include <font color=#004488>"Byte.h"</font>
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"ByteTest.out"</font>);

<font color=#0000ff>void</font> k(Byte&amp; b1, Byte&amp; b2) {
  b1 = b1 * b2 + b2 % b1;

  #define TRY2(OP) \
    out &lt;&lt; <font color=#004488>"b1 = "</font>; b1.print(out); \
    out &lt;&lt; <font color=#004488>", b2 = "</font>; b2.print(out); \
    out &lt;&lt; <font color=#004488>";  b1 "</font> #OP <font color=#004488>" b2 produces "</font>; \
    (b1 OP b2).print(out); \
    out &lt;&lt; endl;

  b1 = 9; b2 = 47;
  TRY2(+) TRY2(-) TRY2(*) TRY2(/)
  TRY2(%) TRY2(^) TRY2(&amp;) TRY2(|)
  TRY2(&lt;&lt;) TRY2(&gt;&gt;) TRY2(+=) TRY2(-=)
  TRY2(*=) TRY2(/=) TRY2(%=) TRY2(^=)
  TRY2(&amp;=) TRY2(|=) TRY2(&gt;&gt;=) TRY2(&lt;&lt;=)
  TRY2(=) <font color=#009900>// Operatori di assegnamento</font>

  <font color=#009900>// Espressioni condizionali:</font>
  #define TRYC2(OP) \
    out &lt;&lt; <font color=#004488>"b1 = "</font>; b1.print(out); \
    out &lt;&lt; <font color=#004488>", b2 = "</font>; b2.print(out); \
    out &lt;&lt; <font color=#004488>";  b1 "</font> #OP <font color=#004488>" b2 produces "</font>; \
    out &lt;&lt; (b1 OP b2); \
    out &lt;&lt; endl;

  b1 = 9; b2 = 47;
  TRYC2(&lt;) TRYC2(&gt;) TRYC2(==) TRYC2(!=) TRYC2(&lt;=)
  TRYC2(&gt;=) TRYC2(&amp;&amp;) TRYC2(||)

  <font color=#009900>// Assegnamenti concatenati:</font>
  Byte b3 = 92;
  b1 = b2 = b3;
}

<font color=#0000ff>int</font> main() {
  out &lt;&lt; <font color=#004488>"member functions:"</font> &lt;&lt; endl;
  Byte b1(47), b2(9);
  k(b1, b2);
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Si può vedere che all' 
  <b>operator=</b> è consentito essere solo una funzione membro. Questo è spiegato 
  in seguito.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Notare che tutti gli 
  operatori di assegnamento hanno del codice per controllare l'auto-assegnamento; 
  questo è una linea guida generale. In certi casi questo non è necessario; per 
  esempio, con <b>operator+=</b> <i>possiamo</i> scrivere <b>A+=A</b> e ottenere 
  la somma di <b>A</b> con se stesso. Dove è più importante controllare l'auto 
  assegnamento è nell'<b>operator=</b> perchè con oggetti complicati si possono 
  ottenere risultati disastrosi (in certi casi è OK, ma bisogna sempre stare attenti 
  quando si scrive<span style="mso-spacerun: yes">&nbsp; </span><b>operator=</b>)</span><span
lang=IT style='mso-ansi-language:IT'><o:p>.</o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='mso-ansi-language:IT'>Tutti gli operatori mostrati nei due esempi 
  precedenti sono sovraccaricati per manipolare un singolo tipo. È anche possibile 
  sovraccaricare operatori per manipolare tipi misti e sommare, per esempio, mele 
  con arancie. Prima di cominciare ad usare in modo esaustivo il sovraccaricamento 
  degli operatori, tuttavia, bisogna dare uno sguardo alla sezione sulla conversione 
  automatica dei tipi più avanti in questo capitolo. Spesso una conversione di 
  tipo alla destra dell'operatore può far risparmiare un sacco di operatori sovraccaricati.</span></font><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Argomenti &amp; valori
di ritorno<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">Può 
  sembrare leggermente fuorviante sulle prime quando si guarda dentro <b>OverloadingUnaryOperators.cpp</b>, 
  <b>Integer.h</b> e <b>Byte.h </b>e si vedono tutti i modi diversi in cui vengono 
  passati gli argomenti e restituiti i valori di ritorno. Benchè si <i>possano</i> 
  passare e restituire gli argomenti in tutti i modi possibili, le scelte fatte 
  in questi esempi non sono casuali. Esse seguono un modello logico, che è lo 
  stesso che dovremmo usare nella maggior parte dei casi.</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<ol start=1 type=1>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo7;tab-stops:list .5in'>
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Come per una qualunque argomento 
      di una funzione, se l'argomento serve solo in lettura e non bisogna fare 
      cambiamenti su di esso è bene passarlo come riferimento <b>const</b>. Le 
      operazioni aritmetiche ordinarie (come <b>+ </b>e <b>&#8211;</b>, ecc.) 
      e i Booleani non cambiano i loro argomenti, e quindi il modo più diffuso 
      di passare gli argomenti è come riferimento <b>const</b>. Quando la funzione 
      è un membro di una classe, questo si traduce nell'avere funzioni membro 
      <b>const</b>. Solo con gli operatori di assegnamento (come <b>+=</b>) e 
      l' <b>operator=</b>, che cambiano l'argomento alla sinistra dell'operatore, 
      l'argomento di sinistra <i>non</i> è una costante, ma viene passato come 
      indirizzo perchè viene modificato.</span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></font></p>
  </li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo7;tab-stops:list .5in'>
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Il tipo del valore di ritorno 
      che dobbiamo scegliere dipende dal significato atteso dell'operatore (di 
      nuovo, si può fare qualunque cosa con gli argomenti e i valori di ritorno.) 
      Se l'effetto dell'operatore è di produrre un nuovo valore, c'è bisogno di 
      generare un nuovo oggetto come valore di ritorno. Per esempio, <b>Integer::operator+</b> 
      deve produrre un oggetto <b>Integer</b> che è la somma degli operandi. Questo 
      oggetto viene restituito per valore come <b>const</b>, così il risultato 
      non può essere modificato come un lvalue (valore di sinistra).</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
  </li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo7;tab-stops:list .5in'>
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Tutti gli operatori di assegnamento 
      modificano il valore di sinistra. Per consentire al risultato di un assegnamento 
      di essere usato in espressioni concatenate, come <b>a=b=c</b>, ci si aspetta 
      che il valore di ritorno sia un riferimento allo stesso valore di sinistra 
      appena modificato. Ma questo riferimento deve essere <b>const</b> o non<b>const</b>? 
      Benchè noi leggiamo l'espressione <b>a=b=c</b> da sinistra verso destra, 
      il compilatore la analizza da destra verso sinistra, cosicchè non siamo 
      obbligati a restituire un non<b>const</b> per supportare il concatenamento 
      dell'assegnazione. Tuttavia la gente qualche volta si aspetta di poter effettuare 
      operazioni sull'oggetto a cui è stata appena fatta l'assegnazione, come 
      <b>(a=b).func(&nbsp;);</b> per chiamare <b>func(&nbsp;)</b> su <b>a</b> 
      dopo avergli assegnato <b>b</b>. Perciò il valore di ritorno per tutti gli 
      operatori di assegnamento potrebbe essere un riferimento non<b>const</b> 
      al valore di sinistra.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
  </li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo7;tab-stops:list .5in'>
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Per gli operatori logici 
      tutti si aspettano di avere come valore di ritorno nel peggiore dei casi 
      un <b>int</b> e nel migliore dei casi un <b>bool</b> (le librerie sviluppate 
      prima che molti compilatori C++ supportassero il tipo incorporato <b>bool,</b> 
      usano un <b>int</b> o un <b>typedef </b>equivalente).</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
  </li>
</ol>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Gli operatori di incremento 
  e decremento presentano il solito dilemma delle versioni pre- e postfissa. Entrambe 
  le versioni modificano l'oggetto e quindi non possono trattare l'oggetto come<span style="mso-spacerun: yes">&nbsp; 
  </span><b>const</b>. La versione con prefisso restituisce il valore dell'oggetto 
  dopo averlo modificato, quindi ci si aspetta come ritorno lo stesso oggetto 
  su cui opera. In questo caso, quindi, si può semplicemente restituire un <b>*this</b> 
  come riferimento. La versione con postfisso si suppone che restituisca il valore 
  dell'oggetto <i>prima che </i>questo venga modificato, perciò siamo obbligati 
  a creare un oggetto separato per rappresentare questo valore e restituirlo. 
  In questo caso il ritorno deve essere fatto per valore se si vuole preservare 
  il significato atteso (Notare che qualche volta si possono trovare gli operatori 
  di incremento e decremento che restituiscono un<span style="mso-spacerun:
yes">&nbsp; </span><b>int</b> o un <b>bool</b> per indicare, per esempio, che 
  un oggetto utilizzato per scorrere una lista ha raggiunto la fine di questa 
  lista). Adesso la domanda è: il valore di ritorno deve essere <b>const</b> o 
  non<b>const</b>? Se si consente all'oggetto di essere modificato e qualcuno 
  scrive <b>(++a).func(&nbsp;)</b>, <b>func(&nbsp;)</b> opera su <b>a</b> stessa, 
  ma con <b>(a++).func(&nbsp;)</b>, <b>func(&nbsp;)</b> opera su un oggetto temporaneo 
  restituito da <b>operator++ </b>in versione con postfisso. Gli oggetti temporanei 
  sono automaticamente <b>const</b>, perciò questo sarà marcato dal compilatore, 
  ma per coerenza ha molto più senso renderli entrambi <b>const</b>, come viene 
  fatto qui. Oppure si può scegliere di rendere<span
style="mso-spacerun: yes">&nbsp; </span>non-<b>const </b>la versione con prefisso 
  e <b>const </b>la versione con postfisso.<b> </b>A causa della varietà di significati 
  che si possono dare agli operatori di incremento e decremento, è necessario 
  considerarli caso per caso.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'><font face="Verdana, Arial, Helvetica, sans-serif">Ritorno 
  per valore come const<o:p></o:p><o:p></o:p></font><o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">Il 
  ritorno per valore come<span style="mso-spacerun: yes">&nbsp; </span><b>const</b> 
  potrebbe sembrare un pò subdolo sulle prime, perciò richiede un minimo di spiegazione. 
  Consideriamo l'operatore binario <b>operator+</b>. Se lo usiamo in un'espressione 
  come <b>f(a+b)</b>, il risultato di <b>a+b</b> diventa un oggetto temporaneo 
  usato nella chiamata di <b>f(&nbsp;)</b>. Siccome è temporaneo, esso è automaticamente 
  <b>const</b>, perciò non ha nessun effetto la dichiarazione esplicita <b>const</b> 
  o non-<b>const</b>.</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Tuttavia è anche possibile 
  inviare un messaggio al valore di ritorno di <b>a+b</b>, piuttosto che passarlo 
  semplicemente ad una funzione. Per esempio possiamo scrivere <b>(a+b).g(&nbsp;)</b>, 
  in cui <b>g(&nbsp;)</b> è una qualche funzione membro della classe <b>Integer</b>, 
  in questo caso. Rendendo <b>const</b><span style="mso-spacerun: yes">&nbsp; 
  </span>il valore di ritorno si impone che solo le funzioni membro <b>const</b> 
  possano essere chiamate per questo valore di ritorno. Questo è un uso corretto 
  di <b>const</b>, perchè previene il potenziale errore di memorizzare un'informazione 
  preziosa in un oggetto che molto probabilmente verrebbe perso.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='mso-ansi-language:IT;font-weight:normal'><o:p></o:p></span></h4>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'><font face="Verdana, Arial, Helvetica, sans-serif">Ottimizzazione 
  del valore di ritorno<o:p></o:p></font><o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">Quando 
  vengono creati nuovi oggetti da restituire per valore, guardiamo la forma usata. 
  In <b>operator+</b>, per esempio:</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>return</font> Integer(left.i + right.i);</PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Questa potrebbe sembrare 
  sulle prime una "chiamata a funzione di un costruttore," ma non lo è. La sintassi 
  è quella di un oggetto temporaneo; l'istruzione dice "costruisci un oggetto 
  temporaneo di tipo <b>Integer</b> e restituiscilo." Per questo, si potrebbe 
  pensare che il risultato è lo stesso che si ottiene creando un oggetto locale 
  e restituendolo. Invece la cosa è alquanto diversa. Se invece scriviamo:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Integer tmp(left.i + right.i);
<font color=#0000ff>return</font> tmp;</PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>succedono tre cose. Primo, 
  l'oggetto <b>tmp</b> viene creato includendo la chiamata al suo costruttore. 
  Secondo, il costruttore di copia copia<span style="mso-spacerun:
yes">&nbsp; </span><b>tmp</b> nella locazione del valore di ritorno (esterna allo 
  scope). Terzo, alla fine viene chiamato il distruttore di <b>tmp</b>.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">In 
  contrasto, l'approccio del<span style="mso-spacerun: yes">&nbsp; </span>"ritorno 
  di un oggetto temporaneo" funziona in maniera completamente diversa. Quando 
  il compilatore vede fare una cosa del genere, sa che non c'è nessun altro interesse 
  sull'oggetto creato se non quello di usarlo come valore di ritorno. Il compilatore 
  trae vantaggio da questa informazione, creando l'oggetto <i>direttamente</i> 
  dentro la locazione del valore di ritorno, esterna allo scope. Questo richiede 
  solo una chiamata al costruttore ordinario (non è necessario alcun costruttore 
  di copia) e non c'è la chiamata al distruttore, in quanto di fatto non viene 
  mai creato l'oggetto temporaneo. Così, se da una parte non costa nulla se non 
  un pò di accortezza da parte del programmatore, dall'altra è significativamente 
  molto più efficiente. Questo viene spesso chiamata <i>ottimizzazione del valore 
  di ritorno</i>.</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Operatori inusuali<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">Alcuni 
  operatori aggiuntivi hanno una sintassi leggermente diversa per il sovraccaricamento.</font></span><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>L'operatore sottoscrizione, 
  <b>operator[ ]</b>, deve essere una funzione membro e richiede un singolo argomento. 
  Siccome l' <b>operator[ ] </b>implica che l'oggetto per il quale viene chiamato 
  agisce come un array, il valore di ritorno per questo operatore deve essere 
  un riferimento, così può essere usato convenientemente alla sinistra del segno 
  di uguale. Questo operatore viene comunemente sovraccaricato; se ne potranno 
  vedere esempi nel resto del libro.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Gli operatori <b>new</b> 
  e <b>delete</b> controllano l'allocazione dinamica della memoria e possono essere 
  sovraccaricati in molti modi diversi. Questo argomento è trattato nel Capitolo 
  13.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Operatore virgola<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">L'operatore 
  virgola viene chiamato quando appare dopo un oggetto del tipo per cui l'operatore 
  virgola è definito . Tuttavia, "<b>operator,</b>" (operatore virgola) <b><span
style="mso-spacerun: yes">&nbsp;</span></b><i>non </i>viene chiamato per le liste 
  di argomenti di funzioni, ma solo per oggetti che appaiono separati da virgole. 
  Non sembra che ci siano tanti usi pratici di questo operatore ed è stato messo 
  nel linguaggio solo per coerenza. Qui c'è un esempio di come la funzione virgola 
  può essere chiamata quando appare una virgola <i>prima o dopo </i><span style="mso-spacerun: yes">&nbsp;</span>un 
  oggetto:</font></span><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:OverloadingOperatorComma.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> After {
<font color=#0000ff>public</font>:
  <font color=#0000ff>const</font> After&amp; <font color=#0000ff>operator</font>,(<font color=#0000ff>const</font> After&amp;) <font color=#0000ff>const</font> {
    cout &lt;&lt; <font color=#004488>"After::operator,()"</font> &lt;&lt; endl;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
};

<font color=#0000ff>class</font> Before {};

Before&amp; <font color=#0000ff>operator</font>,(<font color=#0000ff>int</font>, Before&amp; b) {
  cout &lt;&lt; <font color=#004488>"Before::operator,()"</font> &lt;&lt; endl;
  <font color=#0000ff>return</font> b;
}

<font color=#0000ff>int</font> main() {
  After a, b;
  a, b;  <font color=#009900>// Viene chiamato l'operatore virgola</font>

  Before c;
  1, c;  <font color=#009900>// Viene chiamato l'operatore virgola</font>
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La funzione globale consente 
  alla virgola di essere posta prima dell'oggetto in questione. L'uso mostrato 
  è piuttosto oscuro e opinabile. Benchè si potrebbe usare un lista separata da 
  virgole come parte di un'espressione più complessa, è molto subdolo nella maggior 
  parte delle situazioni.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Operator-&gt;<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">L' 
  <b>operator&#8211;&gt;</b> (dereferenziazione di puntatore) è generalmente usato 
  quando si vuole fare apparire un oggetto come puntatore. Siccome un oggetto 
  di questo tipo incorpora molta più "intelligenza" di quanta ne abbia un puntatore 
  normale, spesso viene chiamato <i>puntatore intelligente</i>. Questo è utile 
  soprattutto se si vuole "avvolgere" una classe intorno ad un puntatore per renderlo 
  sicuro, o nell'uso comune di un <i>iteratore</i>, cioè un oggetto che scorre 
  all'interno di una <i>collezione</i> /<i>contenitore </i>di altri oggetti e 
  li seleziona uno alla volta, senza fornire l'accesso diretto all'implementazione 
  del contenitore (I contenitori e gli iteratori si possono trovare spesso nelle 
  librerie di classi, come nella libreria Standard del C++, descritta nel Volume 
  2 di questo libro).</font></span><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Questo operatore deve 
  essere una funzione membro. Esso ha dei vincoli aggiuntivi atipici: deve restituire 
  un oggetto (o un riferimento ad un oggetto) che abbia anch'esso un operatore 
  di dereferenziazione di puntatore, oppure deve restituire un puntatore che può 
  essere usato per selezionare quello a cui punta l'operatore. Qui c'è un esempio:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:SmartPointer.cpp</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include <font color=#004488>"../require.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Obj {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i, j;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> f() <font color=#0000ff>const</font> { cout &lt;&lt; i++ &lt;&lt; endl; }
  <font color=#0000ff>void</font> g() <font color=#0000ff>const</font> { cout &lt;&lt; j++ &lt;&lt; endl; }
};

<font color=#009900>// Definizioni di membri static:</font>
<font color=#0000ff>int</font> Obj::i = 47;
<font color=#0000ff>int</font> Obj::j = 11;

<font color=#009900>// Container:</font>
<font color=#0000ff>class</font> ObjContainer {
  vector&lt;Obj*&gt; a;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> add(Obj* obj) { a.push_back(obj); }
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> SmartPointer;
};

<font color=#0000ff>class</font> SmartPointer {
  ObjContainer&amp; oc;
  <font color=#0000ff>int</font> index;
<font color=#0000ff>public</font>:
  SmartPointer(ObjContainer&amp; objc) : oc(objc) {
    index = 0;
  }
  <font color=#009900>// Il valore di ritorno indica la fine della lista:</font>
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>++() { <font color=#009900>// Prefisso</font>
    <font color=#0000ff>if</font>(index &gt;= oc.a.size()) <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(oc.a[++index] == 0) <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) { <font color=#009900>// Postfisso</font>
    <font color=#0000ff>return</font> <font color=#0000ff>operator</font>++(); <font color=#009900>// Usa la versione con prefisso</font>
  }
  Obj* <font color=#0000ff>operator</font>-&gt;() <font color=#0000ff>const</font> {
    require(oc.a[index] != 0, <font color=#004488>"Zero value "</font>
      <font color=#004488>"returned by SmartPointer::operator-&gt;()"</font>);
    <font color=#0000ff>return</font> oc.a[index];
  }
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 10;
  Obj o[sz];
  ObjContainer oc;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sz; i++)
    oc.add(&amp;o[i]); <font color=#009900>// Lo riempie</font>
  SmartPointer sp(oc); <font color=#009900>// Crea un iteratore</font>
  <font color=#0000ff>do</font> {
    sp-&gt;f(); <font color=#009900>// Chiamata all'operatore di dereferenziazione di puntatore</font>
    sp-&gt;g();
  } <font color=#0000ff>while</font>(sp++);
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La classe <b>Obj</b> 
  definisce gli oggetti che vengono manipolati in questo programma. Le funzioni 
  <b>f(&nbsp;)</b> e <b>g(&nbsp;)</b> semplicemente stampano valori di interesse 
  usando i dati membri <b>static</b>. I puntatori a questi oggetti sono memorizzati 
  all'interno dei contenitori di tipo <b>ObjContainer</b> usando la sua funzione 
  <b>add(&nbsp;)</b>. <b>ObjContainer</b> si presenta come un array di puntatori, 
  ma si può notare che non c'è nessun modo di tirar fuori questi puntatori. Tuttavia, 
  <b>SmartPointer</b> è dichiarata come classe <b>friend</b>, perciò ha il permesso 
  di guardare dentro al contenitore. La classe <b>SmartPointer</b> si presenta 
  molto più come un puntatore intelligente &#8211; lo si può spostare in avanti 
  usando l' <b>operator++</b> (si può anche definire un <b>operator&#8211; &#8211;</b>), 
  non può oltrepassare la fine del contenitore a cui punta, e produce (attraverso 
  l'operatore di dereferenziazione di puntatori) il valore a cui punta. Notare 
  che <b>SmartPointer </b>è un adattamento personalizzato per il contenitore per 
  cui è stato creato; a differenza di un puntatore ordinario, non c'è un puntatore 
  intelligente "general purpose". Si può apprendere molto di più sui puntatori 
  intelligenti detti "iteratori" nell'ultimo capitolo di questo libro e nel Volume 
  2<span
style="mso-spacerun: yes">&nbsp; </span>(scaricabile da <i>www.BruceEckel.com</i>).</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">In 
  <b>main(&nbsp;)</b>, una volta che il contenitore <b>oc</b> è riempito con oggetti 
  di tipo <b>Obj</b> , viene creato uno <b>SmartPointer sp</b>. Le chiamate al 
  puntatore intelligente avvengono nelle espressioni:</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE>sp-&gt;f(); <font color=#009900>// Chiamate a puntatori intelligenti</font>
sp-&gt;g(); </PRE>
  </FONT><span
style='font-family:Georgia'><o:p></o:p></span></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Qui, anche se <b>sp</b>
di fatto non ha le funzioni membro <b>f(&nbsp;)</b> e <b>g(&nbsp;)</b>, l'operatore
di dereferenziazione di puntatori automaticamente chiama queste funzioni per l'<b>Obj*</b>
restituito da <b>SmartPointer::operator&#8211;&gt;</b>. Il compilatore effettua tutti
i controlli per assicurare che la chiamata alla funzione lavori correttamente.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Un iteratore
nidificato<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>È molto più comune
vedere una classe "puntatore intelligente" o "iteratore" nidificata all'interno
della classe che essa serve. L'esempio precedente può essere riscritto per
nidificare <b>SmartPointer</b> all'interno di <b>ObjContainer</b>, come segue:</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:NestedSmartPointer.cpp</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include <font color=#004488>"../require.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Obj {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i, j;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> f() { cout &lt;&lt; i++ &lt;&lt; endl; }
  <font color=#0000ff>void</font> g() { cout &lt;&lt; j++ &lt;&lt; endl; }
};

<font color=#009900>// Definizioni di membri Static:</font>
<font color=#0000ff>int</font> Obj::i = 47;
<font color=#0000ff>int</font> Obj::j = 11;

<font color=#009900>// Container:</font>
<font color=#0000ff>class</font> ObjContainer {
  vector&lt;Obj*&gt; a;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> add(Obj* obj) { a.push_back(obj); }
  <font color=#0000ff>class</font> SmartPointer;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> SmartPointer;
  <font color=#0000ff>class</font> SmartPointer {
    ObjContainer&amp; oc;
    <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font> index;
  <font color=#0000ff>public</font>:
    SmartPointer(ObjContainer&amp; objc) : oc(objc) {
      index = 0;
    }
    <font color=#009900>// Il valore di ritorno indica la fine della lista:</font>
    <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>++() { <font color=#009900>// Prefisso</font>
      <font color=#0000ff>if</font>(index &gt;= oc.a.size()) <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
      <font color=#0000ff>if</font>(oc.a[++index] == 0) <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
      <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) { <font color=#009900>// Postfisso</font>
      <font color=#0000ff>return</font> <font color=#0000ff>operator</font>++(); <font color=#009900>// Usa la versione con prefisso</font>
    }
    Obj* <font color=#0000ff>operator</font>-&gt;() <font color=#0000ff>const</font> {
      require(oc.a[index] != 0, <font color=#004488>"Zero value "</font>
        <font color=#004488>"returned by SmartPointer::operator-&gt;()"</font>);
      <font color=#0000ff>return</font> oc.a[index];
    }
  };
  <font color=#009900>// Funzione per produrre un puntatore intelligente che </font>
  <font color=#009900>// punta all'inizio di ObjContainer:</font>
  SmartPointer begin() { 
    <font color=#0000ff>return</font> SmartPointer(*<font color=#0000ff>this</font>);
  }
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 10;
  Obj o[sz];
  ObjContainer oc;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sz; i++)
    oc.add(&amp;o[i]); <font color=#009900>//Lo riempie</font>
  ObjContainer::SmartPointer sp = oc.begin();
  <font color=#0000ff>do</font> {
    sp-&gt;f(); <font color=#009900>// Chiamata all'operatore di dereferenziazione di puntatore</font>
    sp-&gt;g();
  } <font color=#0000ff>while</font>(++sp);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Oltre alla
nidificazione delle classi, ci sono solo due differenze qui. La prima è nella
dichiarazione della classe in modo che possa essere <b>friend</b>:</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> SmartPointer;
<font color=#0000ff>friend</font> SmartPointer;</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Il compilatore deve
innanzitutto sapere che la classe esiste prima che possa dire che è una <b>friend</b>.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La seconda differenza
è nella funzione <b>begin(&nbsp;), </b>membro<span style="mso-spacerun:
yes">&nbsp; </span>di <b>ObjContainer</b>, che produce uno<span
style="mso-spacerun: yes">&nbsp; </span><b>SmartPointer</b> che punta all'inizio
della sequenza <b>ObjContainer</b>. Benchè sia solo una questione di
convenienza, è preziosa perchè segue parte della forma usata nella libreria
Standard del C++.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Operator-&gt;*<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">L' 
  <b>operator&#8211;&gt;*</b> è un operatore binario che si comporta come tutti 
  gli altri operatori binari. Viene fornito per quelle situazioni in cui si vuole 
  simulare il comportamento di un<span style="mso-spacerun: yes">&nbsp; </span><i>puntatore-a-membro</i>, 
  descritto nel capitolo precedente.</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Proprio come l' <b>operator-&gt;</b>, 
  l'operatore di dereferenziazione di puntatore-a-membro viene generalmente usato 
  con certi tipi di oggetti che rappresentano un "puntatore intelligente," anche 
  se l'esempio mostrato qui è più semplice, in modo da risultare comprensibile. 
  Il trucco quando si definisce l' <b>operator-&gt;*</b> è che deve ritornare 
  un oggetto per il quale l' <b>operator(&nbsp;) </b>(chiamata a funzione) può 
  essere chiamato con gli argomenti da passare<span style="mso-spacerun:
yes">&nbsp; </span>alla funzione membro che si sta chiamando.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>L'operatore <i>chiamata 
  a funzione</i>,<i> </i><span style="mso-spacerun: yes">&nbsp;</span><b>operator(&nbsp;),</b> 
  deve essere una funzione membro, ed è unica per il fatto che accetta un numero 
  qualsiasi di argomenti. Esso fa si che il nostro oggetto si presenti come se 
  fosse una funzione. Anche se è possibile definire diverse funzioni con l'<b> 
  operator(&nbsp;)</b> sovraccaricato, con diversi argomenti, questo viene spesso 
  usato per tipi che hanno una sola operazione (funzione membro) o che hanno almeno 
  un'operazione particolarmente importante rispetto alle altre. Possiamo vedere 
  nel Volume 2 che la Libreria dello Standard C++ usa l'operatore chiamata a funzione 
  per creare "oggetti funzione." </span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Per creare un <b>operator-&gt;*</b> 
  bisogna prima creare una classe con un <b>operator(&nbsp;)</b> che rappresenta 
  il tipo di oggetto che l' <b>operator-&gt;*</b> deve restituire. Questa classe 
  deve in qualche modo catturare le informazioni necessarie affinchè quando l' 
  <b>operator(&nbsp;)</b> viene chiamato (il che avviene automaticamente), il 
  puntatore-a-membro viene dereferenziato per l'oggetto. Nell'esempio seguente, 
  il costruttore <b>FunctionObject</b> cattura e memorizza sia il puntatore all'oggetto 
  che il puntatore alla funzione membro, e quindi l' <b>operator(&nbsp;)</b> li 
  usa per costruire la chiamata al puntatore-a-membro:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:PointerToMemberOperator.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Dog {
<font color=#0000ff>public</font>:
  <font color=#0000ff>int</font> run(<font color=#0000ff>int</font> i) <font color=#0000ff>const</font> { 
    cout &lt;&lt; <font color=#004488>"run\n"</font>;  
    <font color=#0000ff>return</font> i; 
  }
  <font color=#0000ff>int</font> eat(<font color=#0000ff>int</font> i) <font color=#0000ff>const</font> { 
     cout &lt;&lt; <font color=#004488>"eat\n"</font>;  
     <font color=#0000ff>return</font> i; 
  }
  <font color=#0000ff>int</font> sleep(<font color=#0000ff>int</font> i) <font color=#0000ff>const</font> { 
    cout &lt;&lt; <font color=#004488>"ZZZ\n"</font>; 
    <font color=#0000ff>return</font> i; 
  }
  <font color=#0000ff>typedef</font> <font color=#0000ff>int</font> (Dog::*PMF)(<font color=#0000ff>int</font>) <font color=#0000ff>const</font>;
  <font color=#009900>// operator-&gt;* deve restituire un oggetto </font>
  <font color=#009900>// che ha un operator():</font>
  <font color=#0000ff>class</font> FunctionObject {
    Dog* ptr;
    PMF pmem;
  <font color=#0000ff>public</font>:
    <font color=#009900>// Salva il puntatore all'oggetto e il puntatore al membro</font>
    FunctionObject(Dog* wp, PMF pmf) 
      : ptr(wp), pmem(pmf) { 
      cout &lt;&lt; <font color=#004488>"FunctionObject constructor\n"</font>;
    }
    <font color=#009900>// Effettua la chiamata usando il puntatore all'oggetto</font>
    <font color=#009900>// e il puntatore al membro</font>
    <font color=#0000ff>int</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>int</font> i) <font color=#0000ff>const</font> {
      cout &lt;&lt; <font color=#004488>"FunctionObject::operator()\n"</font>;
      <font color=#0000ff>return</font> (ptr-&gt;*pmem)(i); <font color=#009900>// Effettua la chiamata</font>
    }
  };
  FunctionObject <font color=#0000ff>operator</font>-&gt;*(PMF pmf) { 
    cout &lt;&lt; <font color=#004488>"operator-&gt;*"</font> &lt;&lt; endl;
    <font color=#0000ff>return</font> FunctionObject(<font color=#0000ff>this</font>, pmf);
  }
};
 
<font color=#0000ff>int</font> main() {
  Dog w;
  Dog::PMF pmf = &amp;Dog::run;
  cout &lt;&lt; (w-&gt;*pmf)(1) &lt;&lt; endl;
  pmf = &amp;Dog::sleep;
  cout &lt;&lt; (w-&gt;*pmf)(2) &lt;&lt; endl;
  pmf = &amp;Dog::eat;
  cout &lt;&lt; (w-&gt;*pmf)(3) &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><b><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Dog</span></b><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'> ha tre funzioni membro, 
  e tutte prendono un argomento <b>int</b> e restituiscono un <b>int</b>. <b>PMF</b> 
  è un <b>typedef</b> per semplificare la definizione di un puntatore-a-membro 
  per le funzioni membro di <b>Dog</b>.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Con <b>operator-&gt;* 
  </b>viene creata e restituita una <b>FunctionObject</b>. Notare che <b>operator-&gt;*</b> 
  conosce sia il puntatore-a-membro che l'oggetto per cui questo viene chiamato 
  (<b>this</b>), e li passa al costruttore di <b>FunctionObject</b> che ne memorizza 
  i valori. Quando viene chiamato <b>operator-&gt;*</b>, il compilatore chiama 
  immediatamente l' <b>operator(&nbsp;)</b> per calcolare il valore di ritorno 
  di <b>operator-&gt;*</b>, passandogli gli argomenti di <b>operator-&gt;*</b>. 
  L'operatore <b>FunctionObject::operator(&nbsp;)</b> prende gli argomenti e dereferenzia 
  il<span style="mso-spacerun: yes">&nbsp; </span>"reale" puntatore-a-membro usando 
  il puntatore all'oggetto e il puntatore-a-membro da esso memorizzati.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Notare che quello che 
  stiamo facendo qui, proprio come con l' <b>operator-&gt;</b>, è di inserirci 
  nel mezzo della chiamata ad <b>operator-&gt;*</b>. Questo ci permette di fare 
  delle operazioni extra, se ne abbiamo bisogno.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Il meccanismo dell'<b>operator-&gt;* 
  </b>implementato qui funziona solo con funzioni membro che prendono come argomento 
  un <b>int </b>e restituiscono un <b>int</b>. Questo è limitativo, ma creare 
  un meccanismo di sovraccaricamento per ogni singola possibilità sembra un compito 
  proibitivo. Fortunatamente il meccanismo dei <b>template</b> del C++ (descritto 
  nell'ultimo capitolo di questo libro e nel Volume 2) è stato pensato proprio 
  per gestire problemi di questo tipo.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span style='font-family:Georgia'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Operatori che non si
possono sovraccaricare<o:p></o:p></span></h3>

<span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">Ci 
  sono certi operatori tra quelli disponibili che non sono sovraccaricabili. Il 
  motivo generico per questa restrizione è la sicurezza. Se questi operatori fossero 
  sovraccaricabili, si potrebbero in qualche modo mettere a repentaglio o rompere 
  i meccanismi di sicurezza, rendendo le cose difficili o confondendo la pratica 
  esistente.</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font>
<ul type=disc>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo11;tab-stops:list .5in'> 
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>L' <b>operator.</b> (operatore 
      punto) di selezione dei membri. Correntemente, il punto ha un significato 
      per qualunque membro di classe, ma se se ne permettesse il sovraccaricamento, 
      allora non si potrebbe più accedere ai membri in maniera normale, ma solo 
      con i puntatori o con l'operatore <b>operator-&gt;</b>.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
  </li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo11;tab-stops:list .5in'> 
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>L' <b>operator .*</b> (operatore 
      punto asterisco), dereferenziatore del puntatore a membro, per gli stessi 
      motivi dell' <b>operator. </b>(operatore punto).</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
  </li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo11;tab-stops:list .5in'> 
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Non c'è un operatore per 
      l'elevamento a potenza. La scelta più popolare per questa operazione è stato 
      l' <b>operator** </b>(operatore **) dal Fortran, ma questo solleva un difficile 
      problema di parsing. Neanche il C ha un operatore per l'elevamento a potenza, 
      per cui sembra che il C++ non ne abbia bisogno di uno, anche perchè si può 
      sempre usare una funzione. Un operatore di elevamento a potenza potrebbe 
      aggiungere una notazione comoda, ma questa nuova funzionalità nel linguaggio 
      non compenserebbe la complessità aggiunta al compilatore.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
  </li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo11;tab-stops:list .5in'> 
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Non ci sono operatori definiti 
      dall'utente. Cioè non si possono aggiungere (e sovraccaricare) operatori 
      che non siano già tra quelli disponibili nel linguaggio. Il problema è in 
      parte nella difficoltà di gestire le precedenze e in parte nel fatto che 
      lo sforzo non sarebbe compensato dai vantaggi.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
  </li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo11;tab-stops:list .5in'> 
    <p><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Non si possono cambiare 
      le regole di precedenza. Sono già abbastanza difficili da ricordare così 
      come sono, senza lasciare che la gente ci giochi.</span><span lang=IT
     style='mso-ansi-language:IT'></span></font><span lang=IT
     style='mso-ansi-language:IT'></span><span
lang=IT style='mso-ansi-language:IT'></span></p>
  </li>
</ul>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Operatori non-membro<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">In 
  alcuni degli esempi precedenti, gli operatori possono essere membri o non-membri 
  e non sembra esserci molta differenza. Questo in genere solleva una questione, 
  "Quale dobbiamo scegliere?" In generale, se non c'è differenza è preferibile 
  scegliere un membro di classe, per enfatizzare l'associazione tra l'operatore 
  e la sua classe. Quando l'operando di sinistra è sempre un oggetto della classe 
  corrente questo funziona benissimo. </font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Tuttavia qualche volta 
  si vuole che l'operando di sinistra sia un oggetto di qualche altra classe. 
  Un caso comune in cui si può vedere questo è quando gli operatori <b>&lt;&lt;</b> 
  e <b>&gt;&gt;</b> sono sovraccaricati per iostreams. Siccome iostreams è una 
  libreria fondamentale del C++, probabilmente si vogliono sovraccaricare questi 
  operatori per molte classi proprie, per cui il problema merita di essere affrontato:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:IostreamOperatorOverloading.cpp</font>
<font color=#009900>// Esempi di operatori sovraccaricati non-membri</font>
#include <font color=#004488>"../require.h"</font>
#include &lt;iostream&gt;
#include &lt;sstream&gt; <font color=#009900>// "String streams"</font>
#include &lt;cstring&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> IntArray {
  <font color=#0000ff>enum</font> { sz = 5 };
  <font color=#0000ff>int</font> i[sz];
<font color=#0000ff>public</font>:
  IntArray() { memset(i, 0, sz* <font color=#0000ff>sizeof</font>(*i)); }
  <font color=#0000ff>int</font>&amp; <font color=#0000ff>operator</font>[](<font color=#0000ff>int</font> x) {
    require(x &gt;= 0 &amp;&amp; x &lt; sz,
      <font color=#004488>"IntArray::operator[] out of range"</font>);
    <font color=#0000ff>return</font> i[x];
  }
  <font color=#0000ff>friend</font> ostream&amp;
    <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> IntArray&amp; ia);
  <font color=#0000ff>friend</font> istream&amp;
    <font color=#0000ff>operator</font>&gt;&gt;(istream&amp; is, IntArray&amp; ia);
};

ostream&amp; 
<font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> IntArray&amp; ia) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; ia.sz; j++) {
    os &lt;&lt; ia.i[j];
    <font color=#0000ff>if</font>(j != ia.sz -1)
      os &lt;&lt; <font color=#004488>", "</font>;
  }
  os &lt;&lt; endl;
  <font color=#0000ff>return</font> os;
}

istream&amp; <font color=#0000ff>operator</font>&gt;&gt;(istream&amp; is, IntArray&amp; ia){
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; ia.sz; j++)
    is &gt;&gt; ia.i[j];
  <font color=#0000ff>return</font> is;
}

<font color=#0000ff>int</font> main() {
  stringstream input(<font color=#004488>"47 34 56 92 103"</font>);
  IntArray I;
  input &gt;&gt; I;
  I[4] = -1; <font color=#009900>// Usa l'operatore sovraccaricato operator[]</font>
  cout &lt;&lt; I;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Questa classe contiene
anche un <b>operator [ ] </b>sovraccaricato, che restituisce un riferimento al
giusto valore nell'array. Siccome viene restituito un riferimento, l'espressione</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>I[4] = -1;</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>non solo si presenta
in modo molto più umano di quanto non si sarebbe ottenuto con l'uso dei
puntatori, ma sortisce anche l'effetto desiderato.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>È importante che gli
operatori di shift sovraccaricati ritornino<span style="mso-spacerun:
yes">&nbsp; </span><i>per riferimento</i>, in modo che l'azione si rifletta
sugli oggetti esterni. Nelle definizioni di funzioni, un'espressione come</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>os &lt;&lt; ia.i[j];</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>causa la chiamata alle
funzioni <i>esistenti</i> dell'operatore sovraccaricato (cioè quelle definite
in <b>&lt;iostream&gt;</b>). In questo caso, la funzione chiamata è <b>ostream&amp;
operator&lt;&lt;(ostream&amp;, int)</b> perchè <b>ia.i[j]</b> si risolve in un
<b>int</b>.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Una volta che sono
state effettuate tutte le azioni su <b>istream</b> o su <b>ostream</b>, questo
viene restituito in modo che possa essere usato in espressioni più complicate.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>In <b>main(&nbsp;)</b>
viene usato un nuovo tipo di <b>iostream</b>:<span style="mso-spacerun:
yes">&nbsp; </span><b>stringstream</b> (dichiarato in <b>&lt;sstream&gt;</b>).
Questa è una classe che prende una <b>string</b> (che può costruire a partire
da un array di <b>char</b>, come mostrato qui) e la traduce in un <b>iostream</b>.
Nell'esempio di sopra, questo significa che gli operatori di shift possono
essere testati senza aprire un file o digitando dati dalla linea di comando.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La forma mostrata in
questo esempio per l'inserimento e l'estrazione dei dati è standard. Se si
vogliono creare questi operatori per la propria classe si può copiare il
prototipo delle funzioni e i tipi di ritorno e seguire la stessa forma per il
corpo.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Linee guida di base<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Murray</span><a
href="#fn49"><span lang=IT style='mso-ansi-language:IT'>[49]</span></a><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><span
style="mso-spacerun: yes">&nbsp; </span>suggerisce queste linee guida per la
scelta tra membri e non-membri:</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<div align=center>

<table border=1 cellpadding=0 style='mso-cellspacing:1.5pt;mso-padding-alt:
 0in 0in 0in 0in'>
 <tr>
  <td width=148 style='width:111.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal align=center style='text-align:center'><b><span lang=IT
  style='font-family:Verdana;mso-ansi-language:IT'>Operatore</span></b><b><span
  lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></b></p>
  </td>
  <td width=183 style='width:137.25pt;padding:.75pt .75pt .75pt .75pt'>
  <h5><span lang=IT>Uso raccomandato</span></h5>
  </td>
 </tr>
 <tr>
  <td width=148 style='width:111.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Tutti gli
  operatori unari</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>
  </td>
  <td width=183 style='width:137.25pt;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><span lang=IT style='font-family:
  Georgia;mso-ansi-language:IT'>membri</span><span lang=IT style='mso-ansi-language:
  IT'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr>
  <td width=148 style='width:111.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p><b><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>= (&nbsp;)
  [ ] &#8211;&gt; &#8211;&gt;*</span></b><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>
  </td>
  <td width=183 style='width:137.25pt;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><i><span lang=IT style='font-family:
  Georgia;mso-ansi-language:IT'>Devono essere </span></i><span lang=IT
  style='font-family:Georgia;mso-ansi-language:IT'>membri</span><span lang=IT
  style='mso-ansi-language:IT'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr>
  <td width=148 style='width:111.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p><b><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>+= &#8211;= /=
  *= ^= </span></b><span lang=IT style='mso-ansi-language:IT'><br>
  </span><b><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>&amp;=
  |= %= &gt;&gt;= &lt;&lt;=</span></b><span lang=IT style='mso-ansi-language:
  IT'><o:p></o:p></span></p>
  </td>
  <td width=183 style='width:137.25pt;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><span lang=IT style='font-family:
  Georgia;mso-ansi-language:IT'>membri</span><span lang=IT style='mso-ansi-language:
  IT'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr>
  <td width=148 style='width:111.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Tutti gli
  altri operatori binari</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>
  </td>
  <td width=183 style='width:137.25pt;padding:.75pt .75pt .75pt .75pt'>
  <p align=center style='text-align:center'><span lang=IT style='font-family:
  Georgia;mso-ansi-language:IT'>non-membri</span><span lang=IT
  style='mso-ansi-language:IT'><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Assegnamento con il
sovraccaricamento<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Una fonte comune di
confusione per i nuovi programmatori in C++ è l'assegnamento. Questo perchè
il segno di <b>=</b> (uguale) è un'operazione fondamentale nella
programmazione, dal livello più alto fino alla copia di un registro a livello
macchina. In più qualche volta viene invocato anche il costruttore di copia
(descritto nel Capitolo 11) quando si usa il segno di =:</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MyType b;
MyType a = b;
a = b;</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Nella seconda linea
viene <i>definito</i> l'oggetto<b> a</b>. Un nuovo oggetto viene creato laddove
non ne esisteva uno prima. Siccome sappiamo come il compilatore C++ sia
difensivo riguardo all'inizializzazione di oggetti, sappiamo anche che deve
essere sempre chiamato un costruttore dove si definisce un oggetto. Ma quale
costruttore? <b>a</b> viene creato da un oggetto di tipo <b>MyType</b>
preesistente (<b>b</b>, sul lato destro del segno di =), per cui c'è una sola
scelta: il costruttore di copia. Anche se è coinvolto un segno di uguale,
viene di fatto chiamato il costruttore di copia.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Nella terza linea le 
  cose sono diverse. Sul lato sinistro del segno di uguale c'è un oggetto precedentemente 
  inizializzato. Chiaramente non viene chiamato un costruttore per un oggetto 
  che è stato già creato. In questo caso viene chiamato l'operatore <b>MyType::operator=</b> 
  per <b>a</b>, prendendo come argomento tutto ciò che si trova sul lato destro 
  del segno di uguale (si possono avere più funzioni <b>operator=</b> per trattare 
  differenti titpi di argomenti ).</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Questo comportamento
non è limitato al costruttore di copia. Ogni volta che si inizializza un
oggetto usando un<span style="mso-spacerun: yes">&nbsp; </span>segno di <b>=</b>
invece della forma ordinaria di chiamata a funzione del costruttore, il
compilatore cerca un costruttore che accetta tutto ciò che sta sul lato destro
dell'operatore:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:CopyingVsInitialization.cpp</font>
<font color=#0000ff>class</font> Fi {
<font color=#0000ff>public</font>:
  Fi() {}
};

<font color=#0000ff>class</font> Fee {
<font color=#0000ff>public</font>:
  Fee(<font color=#0000ff>int</font>) {}
  Fee(<font color=#0000ff>const</font> Fi&amp;) {}
};

<font color=#0000ff>int</font> main() {
  Fee fee = 1; <font color=#009900>// Fee(int)</font>
  Fi fi;
  Fee fum = fi; <font color=#009900>// Fee(Fi)</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Quando si ha a che
fare con il segno di <b>=</b> è importante avere in mente questa distinzione :
se l'oggetto non è stato ancora creato, è richiesta un'inizializzazione;
altrimenti viene usato l' <b>operator=</b>.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>È comunque meglio
evitare di scrivere codice che usa il segno di<span style="mso-spacerun:
yes">&nbsp; </span><b>=</b> per l'inizializzazione; usare, invece, sempre la
forma esplicita del costruttore. Le due costruzioni con il segno di uguale
diventano quindi:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Fee fee(1);
Fee fum(fi);</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>In questo modo si
evita di confondere il lettore.</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Il comportamento
dell'operator=<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>In <b>Integer.h</b> e <b>Byte.h</b>,
asseriamo che <b>operator=</b> può essere solo una funzione membro. Esso è
intimamente legato all'oggetto sul lato sinistro di &#8216;<b>=</b>'. Se fosse
possibile definire l' <b>operator=</b> globalmente, potremmo tentare di
ridefinire il segno &#8216;<b>=</b>' predefinito:</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> <font color=#0000ff>operator</font>=(<font color=#0000ff>int</font>, MyType); <font color=#009900>// Global = non consentito!</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Il compilatore evita
questa possibilità forzando l' <b>operator=</b> ad essere una funzione membro.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Quando si crea un <b>operator=</b>,
bisogna copiare tutte le informazioni necessarie dall'oggetto presente sul lato
destro all'oggetto corrente (cioè l'oggetto per il quale l' <b>operator= </b>viene
chiamato) per effettuare quello che consideriamo un<span style="mso-spacerun:
yes">&nbsp; </span>"assegnamento" per la nostra classe. Per oggetti semplici
questo è ovvio:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:SimpleAssignment.cpp</font>
<font color=#009900>// Semplice operator=()</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Value {
  <font color=#0000ff>int</font> a, b;
  <font color=#0000ff>float</font> c;
<font color=#0000ff>public</font>:
  Value(<font color=#0000ff>int</font> aa = 0, <font color=#0000ff>int</font> bb = 0, <font color=#0000ff>float</font> cc = 0.0)
    : a(aa), b(bb), c(cc) {}
  Value&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Value&amp; rv) {
    a = rv.a;
    b = rv.b;
    c = rv.c;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#0000ff>friend</font> ostream&amp;
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Value&amp; rv) {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"a = "</font> &lt;&lt; rv.a &lt;&lt; <font color=#004488>", b = "</font>
      &lt;&lt; rv.b &lt;&lt; <font color=#004488>", c = "</font> &lt;&lt; rv.c;
  }
};

<font color=#0000ff>int</font> main() {
  Value a, b(1, 2, 3.3);
  cout &lt;&lt; <font color=#004488>"a: "</font> &lt;&lt; a &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"b: "</font> &lt;&lt; b &lt;&lt; endl;
  a = b;
  cout &lt;&lt; <font color=#004488>"a after assignment: "</font> &lt;&lt; a &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Qui l'oggetto sul lato 
  sinistro del segno di <b>=</b> copia tutti gli elementi dell'oggetto sulla destra, 
  e poi ritorna un riferimento a se stesso, il che permette di creare un'espressione 
  molto più complessa.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Questo esempio contiene 
  un errore comune. Quando si effettua un assegnamento tra due oggetti dello stesso 
  tipo bisogna sempre fare il controllo sull'auto assegnamento: l'oggetto viene 
  assegnato a se stesso? In certi casi, come questo, è innocuo effettuare l'operazione 
  di assegnamento in qualunque modo, ma se vengono apportate modifiche all'implementazione 
  della classe ci possono essere delle differenze, e se non si tiene conto di 
  questo si possono introdurre errori molto difficili da scovare.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>I puntatori nelle
classi<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia, Times New Roman, Times, serif">Cosa 
  succede se l'oggetto non è così semplice? Per esempio, cosa succede se l'oggetto 
  contiene puntatori ad altri oggetti? Semplicemente, copiando un puntatore si 
  finisce per avere due oggetti che puntano alla stessa locazione di memoria. 
  In situazioni come queste, bisogna fare un pò di conti.</font></span><font face="Georgia, Times New Roman, Times, serif"><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Ci sono due approcci 
  comuni al problema. La tecnica più semplice è quella di copiare tutti i dati 
  puntati dal puntatore quando si fa l'assegnamento o si invoca il costruttore 
  di copia. Questo è chiaro:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:CopyingWithPointers.cpp</font>
<font color=#009900>// Soluzione del problema della replica del puntatore</font>
<font color=#009900>// con la duplicazione dell'oggetto che viene puntato </font>
<font color=#009900>// durante l'assegnamento e la costruzione della copia.</font>
#include <font color=#004488>"../require.h"</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Dog {
  string nm;
<font color=#0000ff>public</font>:
  Dog(<font color=#0000ff>const</font> string&amp; name) : nm(name) {
    cout &lt;&lt; <font color=#004488>"Creating Dog: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  <font color=#009900>// Il costruttore di copia &amp; operator= </font>
  <font color=#009900>// sono corretti.</font>
  <font color=#009900>// Crea un oggetto Dog da un puntatore a Dog:</font>
  Dog(<font color=#0000ff>const</font> Dog* dp, <font color=#0000ff>const</font> string&amp; msg) 
    : nm(dp-&gt;nm + msg) {
    cout &lt;&lt; <font color=#004488>"Copied dog "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; <font color=#004488>" from "</font>
         &lt;&lt; *dp &lt;&lt; endl;
  }
  ~Dog() { 
    cout &lt;&lt; <font color=#004488>"Deleting Dog: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  <font color=#0000ff>void</font> rename(<font color=#0000ff>const</font> string&amp; newName) {
    nm = newName;
    cout &lt;&lt; <font color=#004488>"Dog renamed to: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  <font color=#0000ff>friend</font> ostream&amp;
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Dog&amp; d) {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"["</font> &lt;&lt; d.nm &lt;&lt; <font color=#004488>"]"</font>;
  }
};

<font color=#0000ff>class</font> DogHouse {
  Dog* p;
  string houseName;
<font color=#0000ff>public</font>:
  DogHouse(Dog* dog, <font color=#0000ff>const</font> string&amp; house)
   : p(dog), houseName(house) {}
  DogHouse(<font color=#0000ff>const</font> DogHouse&amp; dh)
    : p(<font color=#0000ff>new</font> Dog(dh.p, <font color=#004488>" copy-constructed"</font>)),
      houseName(dh.houseName 
        + <font color=#004488>" copy-constructed"</font>) {}
  DogHouse&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> DogHouse&amp; dh) {
    <font color=#009900>// Controlla l'auto-assegnamento:</font>
    <font color=#0000ff>if</font>(&amp;dh != <font color=#0000ff>this</font>) {
      p = <font color=#0000ff>new</font> Dog(dh.p, <font color=#004488>" assigned"</font>);
      houseName = dh.houseName + <font color=#004488>" assigned"</font>;
    }
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#0000ff>void</font> renameHouse(<font color=#0000ff>const</font> string&amp; newName) {
    houseName = newName;
  }
  Dog* getDog() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> p; }
  ~DogHouse() { <font color=#0000ff>delete</font> p; }
  <font color=#0000ff>friend</font> ostream&amp;
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> DogHouse&amp; dh) {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"["</font> &lt;&lt; dh.houseName 
      &lt;&lt; <font color=#004488>"] contains "</font> &lt;&lt; *dh.p;
  }
}; 

<font color=#0000ff>int</font> main() {
  DogHouse fidos(<font color=#0000ff>new</font> Dog(<font color=#004488>"Fido"</font>), <font color=#004488>"FidoHouse"</font>);
  cout &lt;&lt; fidos &lt;&lt; endl;
  DogHouse fidos2 = fidos; <font color=#009900>// Costruzione della copia</font>
  cout &lt;&lt; fidos2 &lt;&lt; endl;
  fidos2.getDog()-&gt;rename(<font color=#004488>"Spot"</font>);
  fidos2.renameHouse(<font color=#004488>"SpotHouse"</font>);
  cout &lt;&lt; fidos2 &lt;&lt; endl;
  fidos = fidos2; <font color=#009900>// Assegnamento</font>
  cout &lt;&lt; fidos &lt;&lt; endl;
  fidos.getDog()-&gt;rename(<font color=#004488>"Max"</font>);
  fidos2.renameHouse(<font color=#004488>"MaxHouse"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Dog</span></b><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'> è una classe
semplice che contiene solo una <b>string</b> che memorizza il nome del cane.
Tuttavia bisogna in genere sapere quando succede qualcosa a <b>Dog</b> perchè
i costruttori e i distruttori<span style="mso-spacerun: yes">&nbsp;
</span>stampano informazioni quando vengono chiamati. Notare che<span
style="mso-spacerun: yes">&nbsp; </span>il secondo costruttore è come un costruttore
di copia, solo che prende un puntatore a <b>Dog</b> invece di un riferimento,
ed ha un secondo argomento che è un messaggio che viene concatenato al nome
dell'argomento <b>Dog</b>. Questo viene usato per aiutare nel tracciamento del
comportamento del programma.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Si può vedere che
ogni volta che una funzione membro stampa delle informazioni, non accede
direttamente a queste informazioni, ma invia <b>*this</b> a <b>cout</b>. Questo
a sua volta chiama l' <b>ostream</b> <b>operator&lt;&lt;</b>. È importante
farlo in questo modo, perchè se vogliamo riformattare il modo in cui le
informazioni di <b>Dog</b> vengono visualizzate (come abbiamo fatto aggiungendo
&#8216;[' e &#8216;]') bisogna agire in un posto solo.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Un <b>DogHouse </b>contiene
un <b>Dog*</b> e mostra le quattro funzioni che bisogna sempre definire quando
la classe contiene dei puntatori: tutti i costruttori ordinari necessari, il costruttore
di copia, <b>operator=</b> (o lo si definisce o se ne impedisce l'uso), e il
distruttore. L' <b>operator=</b> fa il controlo sull'auto-assegnamento, come
deve essere, anche se qui non è strettamente necessario. Questo elimina
virtualmente la possibilità di dimenticarsene se si fanno delle modifiche al
codice che lo rendono necessario.</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Il conteggio dei Riferimenti<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Nell'esempio di sopra,
il costruttore di copia e l' <b>operator=</b> effettuano una nuova copia dei
dati puntati dal puntatore, e il distruttore la cancella. Tuttavia se il nostro
oggetto richiede un sacco di memoria o un elevato overhead di inizializzazione,
si vorrebbe evitare questa copia. Un approccio comune a questo problema è
chiamato <i>conteggio dei riferimenti</i>. Si conferisce intelligenza all'oggetto
che viene puntato in modo che esso sa quanti oggetti lo stanno puntando. La
costruzione-copia o l'assegnamento comportano l'aggiunta di un altro puntatore
ad un oggetto esistente e l'incremento di un contatore di riferimenti. La
distruzione comporta il decremento del contatore dei riferimenti e la
distruzione dell'oggetto se il contatore arriva a zero.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Ma cosa succede se
vogliamo scrivere nell'oggetto ( <b>Dog</b> nell'esempio di sopra)? Più di un
oggetto può usare questo <b>Dog</b>, cosicchè potremmo andare a modificare il
<b>Dog</b> di qualcun altro come il nostro, il che non sembra essere molto
carino. Per risolvere questo problema di "duplicazione" viene usata una tecnica
aggiuntiva chiamata <i>copia-su-scrittura</i>. Prima di scrivere un blocco di
memoria ci si assicura che nessun altro vi sta scrivendo. Se il contatore di
riferimenti è maggiore di uno bisogna fare una copia personale del blocco di
memoria prima di scriverci dentro, in modo da non disturbare il territorio di
qualcun altro . Qui c'è un semplice esempio del contatore di riferimenti e
della copia su scrittura:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:ReferenceCounting.cpp</font>
<font color=#009900>// Contatore di riferimenti, copia-su-scrittura</font>
#include <font color=#004488>"../require.h"</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Dog {
  string nm;
  <font color=#0000ff>int</font> refcount;
  Dog(<font color=#0000ff>const</font> string&amp; name) 
    : nm(name), refcount(1) {
    cout &lt;&lt; <font color=#004488>"Creating Dog: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  <font color=#009900>// Previene l'assegnamento:</font>
  Dog&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Dog&amp; rv);
<font color=#0000ff>public</font>:
  <font color=#009900>// Gli oggetti Dog possono essere creati solo sull'heap:</font>
  <font color=#0000ff>static</font> Dog* make(<font color=#0000ff>const</font> string&amp; name) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Dog(name);
  }
  Dog(<font color=#0000ff>const</font> Dog&amp; d) 
    : nm(d.nm + <font color=#004488>" copy"</font>), refcount(1) {
    cout &lt;&lt; <font color=#004488>"Dog copy-constructor: "</font> 
         &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  ~Dog() { 
    cout &lt;&lt; <font color=#004488>"Deleting Dog: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  <font color=#0000ff>void</font> attach() { 
    ++refcount;
    cout &lt;&lt; <font color=#004488>"Attached Dog: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  <font color=#0000ff>void</font> detach() {
    require(refcount != 0);
    cout &lt;&lt; <font color=#004488>"Detaching Dog: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
    <font color=#009900>// Distrugge l'oggetto se nessuno lo sta usando:</font>
    <font color=#0000ff>if</font>(--refcount == 0) <font color=#0000ff>delete</font> <font color=#0000ff>this</font>;
  }
  <font color=#009900>// Copia questo oggetto Dog in modo condizionale.</font>
  <font color=#009900>// La chiama prima di modificare Dog, assegna</font>
  <font color=#009900>// il puntatore di ritorno a Dog*.</font>
  Dog* unalias() {
    cout &lt;&lt; <font color=#004488>"Unaliasing Dog: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
    <font color=#009900>// Non lo duplica se non replicato:</font>
    <font color=#0000ff>if</font>(refcount == 1) <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
    --refcount;
    <font color=#009900>// Usa il costruttore di copia per duplicare:</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Dog(*<font color=#0000ff>this</font>);
  }
  <font color=#0000ff>void</font> rename(<font color=#0000ff>const</font> string&amp; newName) {
    nm = newName;
    cout &lt;&lt; <font color=#004488>"Dog renamed to: "</font> &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  <font color=#0000ff>friend</font> ostream&amp;
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Dog&amp; d) {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"["</font> &lt;&lt; d.nm &lt;&lt; <font color=#004488>"], rc = "</font> 
      &lt;&lt; d.refcount;
  }
};

<font color=#0000ff>class</font> DogHouse {
  Dog* p;
  string houseName;
<font color=#0000ff>public</font>:
  DogHouse(Dog* dog, <font color=#0000ff>const</font> string&amp; house)
   : p(dog), houseName(house) {
    cout &lt;&lt; <font color=#004488>"Created DogHouse: "</font>&lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  DogHouse(<font color=#0000ff>const</font> DogHouse&amp; dh)
    : p(dh.p),
      houseName(<font color=#004488>"copy-constructed "</font> + 
        dh.houseName) {
    p-&gt;attach();
    cout &lt;&lt; <font color=#004488>"DogHouse copy-constructor: "</font>
         &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
  }
  DogHouse&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> DogHouse&amp; dh) {
    <font color=#009900>// Controlla auto-assegnamento:</font>
    <font color=#0000ff>if</font>(&amp;dh != <font color=#0000ff>this</font>) {
      houseName = dh.houseName + <font color=#004488>" assigned"</font>;
      <font color=#009900>// Prima cancella quello che stiamo usando:</font>
      p-&gt;detach();
      p = dh.p; <font color=#009900>// Simile al costruttore di copia</font>
      p-&gt;attach();
    }
    cout &lt;&lt; <font color=#004488>"DogHouse operator= : "</font>
         &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#009900>// Decrementa refcount, e distrugge l'oggetto condizionatamente</font>
  ~DogHouse() {
    cout &lt;&lt; <font color=#004488>"DogHouse destructor: "</font> 
         &lt;&lt; *<font color=#0000ff>this</font> &lt;&lt; endl;
    p-&gt;detach(); 
  }
  <font color=#0000ff>void</font> renameHouse(<font color=#0000ff>const</font> string&amp; newName) {
    houseName = newName;
  }
  <font color=#0000ff>void</font> unalias() { p = p-&gt;unalias(); }
  <font color=#009900>// Copia-su-scrittura. Ogni volta che modifichiamo</font>
  <font color=#009900>// i contenuti del puntatore </font>
  <font color=#009900>// bisogna prima chiamare unalias():</font>
  <font color=#0000ff>void</font> renameDog(<font color=#0000ff>const</font> string&amp; newName) {
    unalias();
    p-&gt;rename(newName);
  }
  <font color=#009900>// ... o quando permettiamo l'accesso a qualcun altro:</font>
  Dog* getDog() {
    unalias();
    <font color=#0000ff>return</font> p; 
  }
  <font color=#0000ff>friend</font> ostream&amp;
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> DogHouse&amp; dh) {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"["</font> &lt;&lt; dh.houseName 
      &lt;&lt; <font color=#004488>"] contains "</font> &lt;&lt; *dh.p;
  }
}; 

<font color=#0000ff>int</font> main() {
  DogHouse 
    fidos(Dog::make(<font color=#004488>"Fido"</font>), <font color=#004488>"FidoHouse"</font>),
    spots(Dog::make(<font color=#004488>"Spot"</font>), <font color=#004488>"SpotHouse"</font>);
  cout &lt;&lt; <font color=#004488>"Entering copy-construction"</font> &lt;&lt; endl;
  DogHouse bobs(fidos);
  cout &lt;&lt; <font color=#004488>"After copy-constructing bobs"</font> &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"fidos:"</font> &lt;&lt; fidos &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"spots:"</font> &lt;&lt; spots &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"bobs:"</font> &lt;&lt; bobs &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"Entering spots = fidos"</font> &lt;&lt; endl;
  spots = fidos;
  cout &lt;&lt; <font color=#004488>"After spots = fidos"</font> &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"spots:"</font> &lt;&lt; spots &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"Entering auto-assegnamento"</font> &lt;&lt; endl;
  bobs = bobs;
  cout &lt;&lt; <font color=#004488>"After auto-assegnamento"</font> &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"bobs:"</font> &lt;&lt; bobs &lt;&lt; endl;
  <font color=#009900>// Commentare le seguenti linee:</font>
  cout &lt;&lt; <font color=#004488>"Entering rename(\"</font>Bob\<font color=#004488>")"</font> &lt;&lt; endl;
  bobs.getDog()-&gt;rename(<font color=#004488>"Bob"</font>);
  cout &lt;&lt; <font color=#004488>"After rename(\"</font>Bob\<font color=#004488>")"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La classe <b>Dog</b> è
l'oggetto puntato da <b>DogHouse</b>. Essa contiene un contatore di riferimenti
e delle funzioni per controllare e leggere questo contatore. C'è un costruttore
di copia in modo che possiamo costruire un nuovo oggetto <b>Dog</b> da uno
esistente.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La funzione <b>attach(&nbsp;)</b>
incrementa il contatore dei riferimennti di un oggetto <b>Dog</b> per indicare
che c'è un altro oggetto che lo usa. <b>detach(&nbsp;) </b>decrementa il
contatore dei riferimenti. Se il contatore arriva a zero allora nessuno lo sta
usando più, così la funzione membro distrugge il suo oggetto chiamando <b>delete
this</b>.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Prima di effettuare
delle modifiche (come rinominare un <b>Dog</b>), bisogna assicurarsi che non si
sta modificando un <b>Dog </b>che qualche altro oggetto sta usando. Si ottiene
ciò chiamando <b>DogHouse::unalias(&nbsp;)</b>, che a sua volta chiama <b>Dog::unalias(&nbsp;)</b>.<b>
</b>L'ultima funzione restituisce il puntatore al <b>Dog</b> esistente se il
contatore dei riferimenti è uno (che significa che nessun altro sta puntando a
questo <b>Dog</b>), ma duplicherà il <b>Dog</b> se il contatore dei
riferimenti è maggiore di uno.</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Il costruttore di
copia, invece di creare la sua propria memoria, assegna <b>Dog</b> al <b>Dog</b>
dell'oggetto sorgente. Quindi, siccome adesso c'è un oggetto in più che usa
questo blocco di memoria, esso incrementa il contatore dei riferimenti chiamando
<b>Dog::attach(&nbsp;)</b>.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>L' <b>operator=</b> ha
a che fare con un oggetto che è stato già creato sul lato sinistro del segno <b>=</b>,
perciò deve prima pulire a fondo questo oggeto chiamando <b>detach(&nbsp;)</b>
per l'oggetto <b>Dog</b>, che distrugge il vecchio <b>Dog </b>se nessun altro
lo sta usando. Quindi l' <b>operator=</b> ripete il comportamento del costruttore
di copia. Notare che esso controlla prima se stiamo assegnando l'oggetto a se
stesso.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Il distruttore chiama <b>detach(&nbsp;)</b>
per distruggere l'oggetto <b>Dog, </b>se ci sono le condizioni.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Per implementare la
copia-su-scrittura, bisogna controllare tutte le azioni che scrivono il nostro
blocco di memoria. Per esempio, la funzione membro <b>renameDog(&nbsp;)</b> ci
permette di cambiare i valori nel blocco di memoria. Ma prima usa <b>unalias(&nbsp;)</b>
per prevenire la modifica di un<span style="mso-spacerun: yes">&nbsp; </span><b>Dog</b>
"replicato"(un <b>Dog </b>con più di un oggetto <b>DogHouse</b> che punta ad
esso). E se abbiamo bisogno di produrre un puntatore a un <b>Dog </b>dall'interno
di <b>DogHouse</b>, bisogna dapprima chiamare <b>unalias(&nbsp;)</b> per questo
puntatore.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>main(&nbsp;)</span></b><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'> testa le varie
funzioni che devono lavorare correttamente per implementare il conteggio dei
riferimenti: il costruttore, il costruttore di copia, l'<b>operator=</b> e il
distruttore. Esso controlla anche la copia-suscrittura chiamando <b>renameDog(&nbsp;)</b>.
</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Qui c'è l'output
(dopo qualche piccola riformattazione):</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Creating Dog: [Fido], rc = 1
Created DogHouse: [FidoHouse] 
  contains [Fido], rc = 1
Creating Dog: [Spot], rc = 1
Created DogHouse: [SpotHouse] 
  contains [Spot], rc = 1
Entering copy-construction
Attached Dog: [Fido], rc = 2
DogHouse copy-constructor: 
  [copy-constructed FidoHouse] 
    contains [Fido], rc = 2
After copy-constructing bobs
fidos:[FidoHouse] contains [Fido], rc = 2
spots:[SpotHouse] contains [Spot], rc = 1
bobs:[copy-constructed FidoHouse] 
  contains [Fido], rc = 2
Entering spots = fidos
Detaching Dog: [Spot], rc = 1
Deleting Dog: [Spot], rc = 0
Attached Dog: [Fido], rc = 3
DogHouse <font color=#0000ff>operator</font>= : [FidoHouse assigned]
  contains [Fido], rc = 3
After spots = fidos
spots:[FidoHouse assigned] contains [Fido],rc = 3
Entering auto-assegnamento
DogHouse <font color=#0000ff>operator</font>= : [copy-constructed FidoHouse]
  contains [Fido], rc = 3
After auto-assegnamento
bobs:[copy-constructed FidoHouse] 
  contains [Fido], rc = 3
Entering rename(<font color=#004488>"Bob"</font>)
After rename(<font color=#004488>"Bob"</font>)
DogHouse destructor: [copy-constructed FidoHouse]
  contains [Fido], rc = 3
Detaching Dog: [Fido], rc = 3
DogHouse destructor: [FidoHouse assigned] 
  contains [Fido], rc = 2
Detaching Dog: [Fido], rc = 2
DogHouse destructor: [FidoHouse] 
  contains [Fido], rc = 1
Detaching Dog: [Fido], rc = 1
Deleting Dog: [Fido], rc = 0</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Studiando l' output,
scorrendo il codice sorgente e facendo esperimenti con il programma, si può
affinare la conoscenza di queste tecniche.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Creazione automatica
dell' operator=<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Siccome assegnare un
oggetto ad un altro oggetto <i>dello stesso tipo</i> è un'attività che molti
si aspettano che sia possibile, il compilatore crea automaticamente <b>type::operator=(type)</b>
se non se ne fornisce uno. Il comportamento di questo operatore imita quello
del costruttore di copia creato automaticamente dal compilatore; se una classe
contiene oggetti (o è ereditata da un'altra classe), l' <b>operator=</b> per
questi oggetti viene chiamato ricorsivamente. Questo viene detto <i>assegnamento
per membro</i>.<i> </i>Per esempio,</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:AutomaticOperatorEquals.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Cargo {
<font color=#0000ff>public</font>:
  Cargo&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Cargo&amp;) {
    cout &lt;&lt; <font color=#004488>"inside Cargo::operator=()"</font> &lt;&lt; endl;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
};

<font color=#0000ff>class</font> Truck {
  Cargo b;
};

<font color=#0000ff>int</font> main() {
  Truck a, b;
  a = b; <font color=#009900>// Stampa: "inside Cargo::operator=()"</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>L' <b>operator=</b>
generato automaticamente per <b>Truck </b>chiama <b>Cargo::operator=</b>.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>In generale non vogliamo 
  che il compilatore faccia questo per noi. Con classi di una certa complessità 
  (specialmente se contengono puntatori!) è preferibile creare esplicitamente 
  l' <b>operator=</b>. Se non vogliamo che gli utenti della nostra classe effettuino 
  l'assegnamento, dichiariamo l' <b>operator=</b> come funzione <b>private</b> 
  (non è necessario definirla a meno che non la stiamo usando nella nostra classe).</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Conversione automatica di tipo<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>In C e C++, se il
compilatore vede un'espressione o una chiamata a funzione che usano un tipo che
non è proprio quello richiesto, spesso può effettuare una conversione di tipo.
In C++, possiamo ottenere lo stesso effetto per i tipi definiti dall'utente,
definendo delle funzioni di conversione automatica dei tipi. Queste funzioni si
presentano in due forme: come tipo particolare di costruttore o come operatore
sovraccaricato.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Conversione con
costruttore<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Se si definisce un
costruttore che prende come unico argomento un oggetto (o riferimento) di un
altro tipo, questo permette al compilatore di effettuare una conversione
automatica di tipo. Per esempio,</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:AutomaticTypeConversion.cpp</font>
<font color=#009900>// Costruttore per la conversione di tipo</font>
<font color=#0000ff>class</font> One {
<font color=#0000ff>public</font>:
  One() {}
};

<font color=#0000ff>class</font> Two {
<font color=#0000ff>public</font>:
  Two(<font color=#0000ff>const</font> One&amp;) {}
};

<font color=#0000ff>void</font> f(Two) {}

<font color=#0000ff>int</font> main() {
  One one;
  f(one); <font color=#009900>// Si aspetta un Two, riceve un One</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Quando il compilatore
vede la funzione <b>f(&nbsp;)</b> chiamata con l'oggetto <b>One</b>, guarda la
dichiarazione di <b>f(&nbsp;)</b> e si accorge che il tipo richiesto è <b>Two</b>.
Quindi vede se c'è un modo di ricavare <b>Two</b> da <b>One</b>, trova il
costruttore <b>Two::Two(One)</b> e silenziosamente lo chiama. L'oggetto
risultante di tipo <b>Two</b> viene passato ad <b>f(&nbsp;)</b>.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>In questo caso la
conversione automatica di tipo ci ha risparmiato l'onere di definire due
versioni sovraccaricate di <b>f(&nbsp;)</b>. Tuttavia il costo è una chiamata
nascosta a un costruttore di <b>Two</b>, che può importare se si è
interessati all'efficienza delle chiamate ad <b>f(&nbsp;)</b>.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Prevenire la
conversione con costruttore<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Ci sono dei casi in
cui la conversione automatica con costruttore può causare problemi. Per
disattivare questa conversione si può modificare il costruttore, facendolo
precedere dalla parola chiave <b>explicit</b> (che funziona solo con i
costruttori). Usata per modificare il costruttore della classe <b>Two</b> nell'esempio
di sopra, si ha:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:ExplicitKeyword.cpp</font>
<font color=#009900>// Usando la parola chiave "explicit"</font>
<font color=#0000ff>class</font> One {
<font color=#0000ff>public</font>:
  One() {}
};

<font color=#0000ff>class</font> Two {
<font color=#0000ff>public</font>:
  <font color=#0000ff>explicit</font> Two(<font color=#0000ff>const</font> One&amp;) {}
};

<font color=#0000ff>void</font> f(Two) {}

<font color=#0000ff>int</font> main() {
  One one;
<font color=#009900>//!  f(one); // Nessuna autoconversione permessa</font>
  f(Two(one)); <font color=#009900>// OK -- l'utente effettua la conversione</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Rendendo <b>explicit</b>
il costruttore di <b>Two</b>, si dice al compilatore di non effettuare nessuna
conversione automatica usando questo particolare costruttore (altri costruttori
non-<b>explicit</b> nella stessa classe possono comunque effetture la
conversione automatica). Se l'utilizzatore vuole che la conversione avvenga,
deve scrivere del codice fuori dalla classe Nel codice di sopra, <b>f(Two(one))</b>
crea un oggetto temporaneo di tipo <b>Two</b> da <b>one</b>, proprio come ha
fatto il compilatore nella versione precedente dell'esempio.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Conversione con
operatore<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Il secondo modo per
ottenere la conversione automatica è attraverso un operatore sovraccaricato.
Si può creare una funzione membro che prende il tipo corrente e lo converte in
quello desiderato usando la parola chiave <b>operator</b> seguita dal tipo
verso cui vogliamo fare la conversione. Questa forma di sovraccaricamento di
operatore è unica, in quanto si vede specificato il valore di ritorno &#8211; il
valore di ritorno è il <i>nome</i> dell'operatore che stiamo sovraccaricando.
Qui c'è un esempio:</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:OperatorOverloadingConversion.cpp</font>
<font color=#0000ff>class</font> Three {
  <font color=#0000ff>int</font> i;
<font color=#0000ff>public</font>:
  Three(<font color=#0000ff>int</font> ii = 0, <font color=#0000ff>int</font> = 0) : i(ii) {}
};

<font color=#0000ff>class</font> Four {
  <font color=#0000ff>int</font> x;
<font color=#0000ff>public</font>:
  Four(<font color=#0000ff>int</font> xx) : x(xx) {}
  <font color=#0000ff>operator</font> Three() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> Three(x); }
};

<font color=#0000ff>void</font> g(Three) {}

<font color=#0000ff>int</font> main() {
  Four four(1);
  g(four);
  g(1);  <font color=#009900>// Chiama Three(1,0)</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Con la tecnica del
costruttore è la classe di destinazione che effettua la conversione, mentre
con la tecnica dell'operatore è la classe sorgente a fare la conversione. Il
pregio della tecnica del costruttore è che si possono aggiungere nuovi
percorsi di conversione ad un sistema esistente quando si crea una nuova classe.
Tuttavia creando un costruttore con un solo argomento si definisce <i>sempre</i>
una conversione automatica di tipo (anche nel caso di più argomenti, se agli
altri vengono lasciati i valori di default), che potrebbe non essere la cosa
che si vuole (in qual caso si può disattivare la conversione con <b>explicit</b>).
In più, non c'è la possibilità di usare la conversione con costruttore da un
tipo definito dall'utente ad un tipo predefinito; questo è possibile solo con
il sovraccaricamento di operatore.</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Riflessività<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Uno dei principali motivi 
  di convenienza nell'usare operatori globali sovraccaricati invece di operatori 
  membri di classe è che nelle versioni globali la conversione automatica di tipo 
  può essere applicata ad entrambi gli operandi, mentre con gli oggetti membro 
  l'operando di sinistra deve essere sempre del tipo giusto. Se si vuole che entrambi 
  gli operandi siano convertiti, la versione globale fa risparmiare un sacco di 
  codice. Qui c'è un piccolo esempio:</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:ReflexivityInOverloading.cpp</font>
<font color=#0000ff>class</font> Number {
  <font color=#0000ff>int</font> i;
<font color=#0000ff>public</font>:
  Number(<font color=#0000ff>int</font> ii = 0) : i(ii) {}
  <font color=#0000ff>const</font> Number
  <font color=#0000ff>operator</font>+(<font color=#0000ff>const</font> Number&amp; n) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> Number(i + n.i);
  }
  <font color=#0000ff>friend</font> <font color=#0000ff>const</font> Number
    <font color=#0000ff>operator</font>-(<font color=#0000ff>const</font> Number&amp;, <font color=#0000ff>const</font> Number&amp;);
};

<font color=#0000ff>const</font> Number
  <font color=#0000ff>operator</font>-(<font color=#0000ff>const</font> Number&amp; n1,
            <font color=#0000ff>const</font> Number&amp; n2) {
    <font color=#0000ff>return</font> Number(n1.i - n2.i);
}

<font color=#0000ff>int</font> main() {
  Number a(47), b(11);
  a + b; <font color=#009900>// OK</font>
  a + 1; <font color=#009900>// 2nd argomento convertito a Number</font>
<font color=#009900>//! 1 + a; // Sbagliato! il primo argomento non è di tipo Number</font>
  a - b; <font color=#009900>// OK</font>
  a - 1; <font color=#009900>// 2nd argomento convertito a Number</font>
  1 - a; <font color=#009900>// 1mo argomento convertito a Number</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La classe <b>Number</b>
ha sia un <b>operator+</b> come membro, sia un <b>friend</b> <b>operator&#8211;</b>.
Siccome c'è un costruttore che prende come unico argomento un <b>int</b>, un <b>int</b>
può essere automaticamente convertito a <b>Number</b>, ma solo alle giuste
condizioni. In <b>main(&nbsp;)</b>, possiamo vedere che aggiungere un <b>Number</b>
ad un altro <b>Number</b> funziona bene perchè c'è una corrispondenza esatta
con l'operatore sovraccaricato. Quando il compilatore vede un <b>Number</b>
seguito da un <b>+</b> e da un int <b>int</b>, può trovare la corrispondenza
con la funzione membro <b>Number::operator+</b> e convertire l'argomento <b>int</b>
a <b>Number</b> usando il costruttore. Ma quando vede un <b>int,</b> un <b>+</b>
e un <b>Number</b>, non sa cosa fare perchè tutto quello che ha è <b>Number::operator+</b>,
che richiede che l'operando di sinistra sia già un oggetto di tipo <b>Number</b>.
Cosicchè il compilatore produce un errore.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Con il <b>friend</b> <b>operator&#8211;</b>,
le cose sono diverse. Il compilatore ha bisogno di inserire entrambi gli
argomenti, per quanto può; non è costretto ad avere un tipo <b>Number</b>
come argomento sul lato sinistro. Così, se vede </span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>1 &#8211; a</PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>può convertire il
primo argomento a <b>Number</b> usando il costruttore.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>A volte si vuole
limitare l'uso dei propri operatori, rendendoli membri di classe. Per esempio,
quando si moltiplica una matrice per un vettore, il vettore deve stare sulla
destra. Ma se si vuole che gli operatori convertano entrambi gli argomenti,
bisogna definire l'operatore come funzione friend.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Fortunatamente il
compilatore se vede <b>1 &#8211; 1</b> non converte gli argomenti a oggetti di tipo <b>Number</b>
per poi chiamare l' <b>operator&#8211;</b>. Questo significherebbe che il codice C
esistente si troverebbe improvvisamente a funzionare in maniera diversa. Il
compilatore cerca dapprima il confronto più "semplice", che è l'operator
predefinito nell'espressione <b>1 &#8211; 1</b>.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Esempio di conversione di tipo<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Un esempio in cui la
conversione automatica di tipo è estremamente utile accade con qualsiasi
classe che incapsula stringhe di caratteri (in questo caso possiamo
implementare la classe usando<span style="mso-spacerun: yes">&nbsp;
</span>semplicemente la classe <b>string</b><span style="mso-spacerun:
yes">&nbsp; </span>del C++ Standard, perchè è semplice). Senza la conversione
automatica di tipo, se si vogliono usare tutte le funzioni per la manipolazione
delle stringhe presenti nella libreria Standard del C, bisogna creare una
funzione membro per ognuna di esse, come questa:</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:Strings1.cpp</font>
<font color=#009900>// Nessuna autoconversione di tipo</font>
#include <font color=#004488>"../require.h"</font>
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Stringc {
  string s;
<font color=#0000ff>public</font>:
  Stringc(<font color=#0000ff>const</font> string&amp; str = <font color=#004488>""</font>) : s(str) {}
  <font color=#0000ff>int</font> strcmp(<font color=#0000ff>const</font> Stringc&amp; S) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> ::strcmp(s.c_str(), S.s.c_str());
  }
  <font color=#009900>// ... ecc., per ogni funzione in string.h</font>
};

<font color=#0000ff>int</font> main() {
  Stringc s1(<font color=#004488>"hello"</font>), s2(<font color=#004488>"there"</font>);
  s1.strcmp(s2);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Qui viene creata solo
la funzione <b>strcmp(&nbsp;)</b>, ma si può creare la funzione corrispondente
per ognuna di quelle presenti in <b>&lt;cstring&gt;, </b>se necessario.
Fortunatamente possiamo fornire una conversione automatica di tipo permettendo
l'accesso a tutte le funzioni in <b>&lt;cstring&gt;</b>:</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:Strings2.cpp</font>
<font color=#009900>// Con auto conversione di tipo</font>
#include <font color=#004488>"../require.h"</font>
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Stringc {
  string s;
<font color=#0000ff>public</font>:
  Stringc(<font color=#0000ff>const</font> string&amp; str = <font color=#004488>""</font>) : s(str) {}
  <font color=#0000ff>operator</font> <font color=#0000ff>const</font> <font color=#0000ff>char</font>*() <font color=#0000ff>const</font> { 
    <font color=#0000ff>return</font> s.c_str(); 
  }
};

<font color=#0000ff>int</font> main() {
  Stringc s1(<font color=#004488>"hello"</font>), s2(<font color=#004488>"there"</font>);
  strcmp(s1, s2); <font color=#009900>// Funzione C Standard</font>
  strspn(s1, s2); <font color=#009900>// Qualunque funzione su string!</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Ora qualunque funzione
che prende un argomento di tipo <b>char*</b> può prendere anche un argomento
di tipo <b>Stringc</b> perchè il compilatore sa come costruire un <b>char*</b>
a partire da una <b>Stringc</b>.</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<h3 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Trappole nella
conversione automatica di tipo<o:p></o:p></span></h3>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Siccome il compilatore
deve scegliere il modo in cui effettuare silenziosamente la conversione, può
cadere in errore se non la progettiamo correttamente. Una situazione semplice
ed ovvia si presenta quando una classe <b>X</b> può convertire se stessa in un
oggetto di tipo <b>Y</b> con un<span style="mso-spacerun: yes">&nbsp; </span><b>operator
Y(&nbsp;)</b>. Se la classe <b>Y</b> ha un costruttore che prende un unico
argomento di tipo <b>X</b>, questo rappresenta lo stesso tipo di conversione.
Il compilatore ha ora due modi di effettuare la conversione da <b>X</b> a <b>Y</b>,
e si può creare un'ambiguità :</span><span lang=IT style='mso-ansi-language:
IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:TypeConversionAmbiguity.cpp</font>
<font color=#0000ff>class</font> Orange; <font color=#009900>// Dichiarazione di Classe</font>

<font color=#0000ff>class</font> Apple {
<font color=#0000ff>public</font>:
  <font color=#0000ff>operator</font> Orange() <font color=#0000ff>const</font>; <font color=#009900>// Converte Apple in Orange</font>
};

<font color=#0000ff>class</font> Orange {
<font color=#0000ff>public</font>:
  Orange(Apple); <font color=#009900>// Converte Apple in Orange</font>
};

<font color=#0000ff>void</font> f(Orange) {}

<font color=#0000ff>int</font> main() {
  Apple a;
<font color=#009900>//! f(a); // Errore: conversione ambigua</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La soluzione ovvia al
problema è di non fare ciò. Bisogna fornire una sola possibilità di
conversione automatica da un tipo ad un altro.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Un problema molto più
difficile da individuare accade quando si fornisce una conversione automatica
verso più tipi. Questa viene detta <i>fan-out</i>:</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:TypeConversionFanout.cpp</font>
<font color=#0000ff>class</font> Orange {};
<font color=#0000ff>class</font> Pear {};

<font color=#0000ff>class</font> Apple {
<font color=#0000ff>public</font>:
  <font color=#0000ff>operator</font> Orange() <font color=#0000ff>const</font>;
  <font color=#0000ff>operator</font> Pear() <font color=#0000ff>const</font>;
};

<font color=#009900>//eat() sovraccaricata:</font>
<font color=#0000ff>void</font> eat(Orange);
<font color=#0000ff>void</font> eat(Pear);

<font color=#0000ff>int</font> main() {
  Apple c;
<font color=#009900>//! eat(c);</font>
  <font color=#009900>// Errore: Apple -&gt; Orange o Apple -&gt; Pear ???</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La classe <b>Apple</b> 
  ha una conversione automatica sia verso <b>Orange</b> che verso <b>Pear</b>. 
  La cosa insidiosa rispetto a questo è che non c'è nessun problema fino a quando 
  qualcuno non crea due versioni sovraccaricate della funzione <b>eat(&nbsp;)</b> 
  (con una sola versione il codice in <b>main(&nbsp;)</b> funziona bene).</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Di nuovo, la soluzione
&#8211; e la parola d'ordine generale con la conversione automatica dei tipi &#8211; è
quella di fornire una singola conversione automatica da un tipo a un altro. Si
possono avere conversioni verso altri tipi; ma queste possono semplicemente
essere non <i>automatiche</i>. Si possono definire chiamate a funzioni
esplicite con nomi come <b>makeA(&nbsp;)</b> e <b>makeB(&nbsp;)</b>.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h4 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Attività nascoste<o:p></o:p></span></h4>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La conversione
automatica dei tipi può introdurre molte più attività sottostanti di quante
ci si possa aspettare. Come piccolo esercizio mentale, osserviamo questa
modifica al file <b>CopyingVsInitialization.cpp</b>:</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C12:CopyingVsInitialization2.cpp</font>
<font color=#0000ff>class</font> Fi {};

<font color=#0000ff>class</font> Fee {
<font color=#0000ff>public</font>:
  Fee(<font color=#0000ff>int</font>) {}
  Fee(<font color=#0000ff>const</font> Fi&amp;) {}
};

<font color=#0000ff>class</font> Fo {
  <font color=#0000ff>int</font> i;
<font color=#0000ff>public</font>:
  Fo(<font color=#0000ff>int</font> x = 0) : i(x) {}
  <font color=#0000ff>operator</font> Fee() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> Fee(i); }
};

<font color=#0000ff>int</font> main() {
  Fo fo;
  Fee fee = fo;
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>Non c'è nessun costruttore 
  per creare l'oggetto <b>Fee fee</b> dall'oggetto <b>Fo</b>. Tuttavia, <b>Fo</b> 
  ha una funzione di conversione automatica verso <b>Fee</b>. Non c'è nessun costruttore 
  di copia per creare un oggetto di tipo <b>Fee</b> da un altro oggetto di tipo 
  <b>Fee</b>, ma questa è una delle funzioni speciali che il compilatore è in 
  grado di creare per noi (il costruttore di default, il costruttore di copia, 
  l'<b>operator=</b>, e il distruttore possono essere automaticamente sintetizzati 
  dal compilatore). Cosicchè per l'istruzione relativamente innocua</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Fee fee = fo;</PRE>
  </FONT></BLOCKQUOTE>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>viene chiamato l' operatore 
  di conversione di tipo e viene creato un costruttore di copia.</span><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></p>
<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><font face="Georgia, Times New Roman, Times, serif"><span
lang=IT style='mso-ansi-language:IT'>Usare la conversione automatica di tipo con 
  attenzione</span><span lang=IT style='font-family:Georgia;mso-ansi-language:
IT'>. Come per ogni <span style="mso-spacerun:
yes">&nbsp;</span>sovraccaricamento di operatore, è eccellente quando riduce significativamente 
  il codice da scrivere, ma non è meritevole di un uso grat</span></font><span lang=IT style='font-family:Georgia;mso-ansi-language:
IT'>uito.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'>Sommario<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Georgia;mso-ansi-language:IT'>La ragione dell'esistenza
del sovraccaricamento degli operatori è per quelle situazioni in cui questo
rende la vita più facile. Non c'è niente di particolarmente magico riguardo a
ciò; gli operatori sovraccaricati sono semplicemente delle funzioni con nomi
simpatici, e le chiamate a queste funzioni vengono fatte dal compilatore quando
questo riconosce la giusta corrispondenza. Ma se il sovraccaricamento non
fornisce un significativo beneficio al creatore della classe o all'utente della
stessa, è inutile complicare le cose con la sua aggiunta.</span><span lang=IT
style='mso-ansi-language:IT'><o:p></o:p></span></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span style='font-family:Georgia'><o:p></o:p></span></p>

<h2 style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-family:Verdana;mso-ansi-language:IT'>Esercizi<o:p></o:p></span></h2>

<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='font-size:10.0pt;font-family:Georgia;mso-ansi-language:IT'>Le
soluzioni agli esercizi selezionati si possono trovare nel documento
elettronico <i>The Thinking in C++ Annotated Solution Guide</i>, disponibile su
<a href="http://www.bruceeckel.com/">www.BruceEckel.com</a> dietro una piccola
ricompensa. </span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></p>

<ol start=1 type=1>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare una semplice classe 
    con un <b>operator++ </b>sovraccaricato. Provare a chiamare quest'operatore 
    nelle forme pre- e postfissa e vedere che tipo di warning da il compilatore.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare una semplice classe 
    che contiene un <b>int</b> e sovraccaricare l' <b>operator+</b> come funzione 
    membro. Fornire anche una funzione membro <b>print(&nbsp;) </b>che prende 
    come argomento un <b>ostream&amp; </b>e stampa su di esso <b>ostream&amp;</b>.<b> 
    </b>Testare la classe per mostrare che funziona correttamente.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Aggiungere un <b>operator-</b> 
    binario all'esercizio 2 come funzione membro. Dimostrare che si possono usare 
    gli oggetti di questa classe in espressioni complesse come </span><span
     lang=IT style='mso-ansi-language:IT'><br>
    </span><b><span lang=IT style='font-family:Georgia;mso-ansi-language:IT'>a 
    + b &#8211; c</span></b><span lang=IT style='font-family:Georgia;mso-ansi-language:
     IT'>.<o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Aggiungere un <b>operator++</b> 
    e un <b>operator&#8212;</b>all'esercizio 2, sia la versione pre- che postfissa, 
    in modo tale che restituiscano l'oggetto incrementato o decrementato. Assicurarsi 
    che la versione postfissa restituisca il valore corretto. </span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Modificare gli operatori 
    di incremento e decremento dell'esercizio 4 in modo tale che le versioni prefisse 
    restituiscano un riferimento non-<b>const </b>e le versioni postfisse restituiscano 
    un oggetto <b>const. </b>Mostrare che funzionano correttamente e spiegare 
    perchè questo potrebbe essere fatto in pratica.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Cambiare la funzione <b>print(&nbsp;)</b> 
    nell'esercizio 2 in modo che sia la versione sovraccaricata dell' <b>operator&lt;&lt;</b> 
    come in <b>IostreamOperatorSovraccaricamento.cpp</b>.<o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Modificare l'esercizio 3 
    in modo tale che l' <b>operator+</b> e l' <b>operator-</b> non siano funzioni 
    membro. Dimostarre che queste continuino a funzionare correttamente.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Aggiungere l' <b>operator-</b> 
    unario nll'esercizio 2 e dimostrare che funziona correttamente.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare una classe che contiene 
    un singolo <b>private</b> <b>char</b>. Sovraccaricare gli operatori <b>&lt;&lt;</b> 
    e <b>&gt;&gt;</b> di iostream (come in <b>IostreamOperatorSovraccaricamento.cpp</b>) 
    e testarli. Si possono testare con <b>fstreams</b>, <b>stringstream</b>s,<span
     style="mso-spacerun: yes">&nbsp; </span><b>cin</b> e <b>cout</b>.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Determinare il valore della 
    costante fittizia che il compilatore passa ad <b>operator++</b> e <b>operator--</b>. 
    </span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Scrivere una classe <b>Number</b> 
    che memorizza un <b>double</b>, e aggiungere una versione sovraccaricata per 
    <b>+, &#8211;, *, /</b>, e per l'assegnamento. Scegliere i valori di ritorno 
    per queste funzioni in modo tale che le espressioni possano essere concatenate, 
    con un occhio all'efficienza. Scrivere un operatore di conversione automatica 
    di tipo <b>operator double()</b>.</span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Modificare l'esercizio11 
    in modo venga usata <i>l'ottimizzazione del valore di ritorno</i>, se non 
    è stato già fatto.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare una classe che contiene 
    un puntatore, e dimostrare che se si permette al compilatore di sintetizzare 
    l' <b>operator=</b> il risultato dell'uso di questo operatore saranno puntatori 
    che puntano alla stessa zona di memoria. Rimediare al problema definendo un 
    proprio <b>operator=</b> e dimostrare che il problema viene risolto. Assicurarsi 
    di controllare l'auto-assegnamento e gestire il caso in modo appropriato.</span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Scrivere una classe di nome 
    <b>Bird </b>che contiene un membro di tipo <b>string</b> e uno <b>static int</b>.<b> 
    </b>Nel costruttore di default usare l' <b>int</b> per generare automaticamente 
    un identificatore costruito nel membro di tipo <b>string</b>, attraverso il 
    nome della classe (<b>Bird #1</b>, <b>Bird #2</b>, ecc.). Aggiungere un <b>operator&lt;&lt; 
    </b>per <b>ostream</b>s per stampare gli oggetti <b>Bird</b>. Scrivere un 
    operatore di assegnamento ( <b>operator=</b> ) e un costruttore di copia. 
    Nel <b>main(&nbsp;)</b>, verificare che tutto funzioni correttamente.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Scrivere una classe di nome 
    <b>BirdHouse</b> che contiene un oggetto, un puntatore e un riferimento per 
    la classe <b>Bird</b> dell'esercizio 14. Il costruttore prende I tre <b>Bird</b>s 
    come argomenti. Aggiungere un <b>operator&lt;&lt;</b> per <b>ostream</b>s 
    per <b>BirdHouse</b>. Scrivere e disattivare l'<b>operator=</b> e un costruttore 
    di copia. Nel <b>main(&nbsp;)</b>, verificare che tutto funzioni correttamente. 
    Assicurarsi che si possano concatenare gli assegnamenti per gli oggetti di 
    tipo <b>BirdHouse</b> e costruire espressioni che coinvolgono operatori multipli. 
    </span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Aggiungere un dato membro 
    di tipo <b>int</b> sia a<span style="mso-spacerun: yes">&nbsp; </span><b>Bird</b> 
    che a <b>BirdHouse</b> dell'esercizio 15. Aggiungere operatori membri <b>+</b>, 
    <b>-</b>, <b>*</b>, e <b>/</b> che usano il membro <b>int</b> per effettuare 
    operazioni sui rispettivi sui rispettivi membri. Verificare che questo funziona.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Ripetere l'esercizio 16 
    usando operatori non-membro.</span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Aggiungere un <b>operator-- 
    </b>a <b>SmartPointer.cpp</b> e <b>NestedSmartPointer.cpp</b>.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Modificare <b>CopyingVsInitialization.cpp</b> 
    in modo che tutti I costruttori stampino un messaggio che spieghi cosa sta 
    succedendo. Verificare adesso che le due forme di chiamate al costruttor-copia 
    (la forma con l;assegnamento e quella con le parentesi) sono equivalenti.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Provare a creare un <b>operator=</b> 
    non-membro per una classe e vedere che tipo di messaggio da il compilatore.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare una classe con un 
    operatore di assegnamento che ha un secondo argomento, una <b>string</b> con 
    un valore di default "op=call." Creare una funzione che assegna un oggetto 
    di questa classe ad un'altra classe e mostrare che l'operatore di assegnamento 
    viene chiamato correttamente.</span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>In <b>CopyingWithPointers.cpp</b>, 
    rimuovere l' <b>operator=</b> in <b>DogHouse</b> e mostrare che l' <b>operator=</b> 
    sintetizzato dal compilatore copia correttamente il valore di <b>string</b> 
    ma effettua semplicemente una "replica" del puntatore a <b>Dog</b>.</span><span
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>In <b>ReferenceCounting.cpp</b>, 
    aggiungere uno <b>static int</b> e un <b>int </b>ordinario come dati membro 
    sia a <b>Dog</b> che a <b>DogHouse</b>. In tutti I costruttori di entrambe 
    le classi, incrementare lo <b>static int</b> e assegnare il risultato all' 
    <b>int</b> ordinario per tenere traccia del numero di oggetti che sono stati 
    creati. Effettuare le modifiche necessarie in modo tale che le istruzioni 
    di stampa stampino gli identificatori di <b>int</b> degli oggetti coinvolti.</span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare una classe contenente 
    una <b>string</b> come membro dati. Inizializzare la <b>string</b> nel costruttore, 
    ma non creare un costruttore di copia o un <b>operator=</b>. Costruire una 
    seconda classe che ha un oggetto membro della prima classe; non creare un 
    costruttore di copia o un <b>operator=</b> neanche per questa seconda classe. 
    Dimostrare che il costruttore di copia e l' <b>operator=</b> vengono sintetizzati 
    opportunamente dal compilatore.</span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Combinare le classi in <b>OverloadingUnaryOperators.cpp</b> 
    e <b>Integer.cpp</b>. </span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Modificare <b>PointerToMemberOperator.cpp</b> 
    aggiungendo due nuove funzioni membro alla classe <b>Dog</b> che non prendono 
    nessun argomento e restituiscono un <b>void</b>. Creare e testareun<span style="mso-spacerun: yes">&nbsp; 
    </span><b>operator-&gt;*</b> sovraccaricato che lavora con le due nuove funzioni.</span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Aggiungere un <b>operator-&gt;* 
    </b>a <b>NestedSmartPointer.cpp</b>.</span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare due classi, <b>Apple</b> 
    e <b>Orange</b>. In <b>Apple</b>, creare un costruttore che prende <b>Orange</b> 
    come argomento. Creare una funzione che prende un <b>Apple</b> e chiama questa 
    funzione con un <b>Orange</b> per mostrare che funziona. Adesso rendere il 
    costruttore di <b>Apple</b><span style="mso-spacerun:
     yes">&nbsp; </span><b>explicit</b> per dimostrare che viene impedita la conversione 
    automatica dei tipi. Modificare la chiamata alla funzione in modo tale che 
    la conversione venga fatta esplicitamente e pertanto ha successo.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Aggiungere un <b>operator*</b> 
    globale a <b>ReflexivityInSovraccaricamento.cpp</b> e dimostrare che è riflessivo.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Creare due classi e un <b>operator+</b> 
    e le funzioni di conversioni in modo tale che l'addizione sia riflessiva per 
    le due classi.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Correggere <b>TypeConversionFanout.cpp</b> 
    per creare una funzione esplicita da chiamare per effettuare la conversione 
    dei tipi, invece di uno degli operatori di conversione automatica.</span><span lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></font></li>
  <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo15;tab-stops:list .5in'> <font face="Georgia, Times New Roman, Times, serif"><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>Scrivere del semplice codice 
    che usa gli operatori <b>+</b>, <b>-</b>, <b>*</b>, e <b>/</b> per dati di 
    tipo <b>double</b>. Vedere come generare codice assembler con il proprio compilatore 
    e guardare dentro al codice assembler generato per scoprire e spiegare cosa 
    succede nel dettaglio.</span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p><o:p></o:p></span></font><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>
</ol>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p><font face = "Verdana"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></o:p></span></p>
<hr size=2 width="100%" align=center>
<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
lang=IT style='mso-ansi-language:IT'><o:p><font face = "Verdana"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face = "Verdana"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"><font face="Georgia"></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></o:p></span></p>

<div class=MsoNormal align=center style='text-align:center;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'> 
</div>


<p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><a
name=fn49></a><a href="#fnB49"><span style='mso-bookmark:fn49'>[49]</span><span
style='mso-bookmark:fn49'></span></a><span style='mso-bookmark:fn49'></span><span
style='font-size:10.0pt;font-family:Georgia'> Rob Murray, <i>C++ Strategies &amp; 
  Tactics</i>, Addison-Wesley, 1993, pagina 47.</span></p>

<center>
  <font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="Capitolo11.html">Capitolo 
  Precedente</a></font></u> ] [ <u><font color="#0000FF">Indice generale </font></u>] 
  [ <u><font color="#0000FF"><a href="DocIndex.html">Indice analitico </a></font></u>] 
  [ <u><font color="#0000FF">Prossimo Capitolo</font></u> ]</font></font> <br>
  <font face="Georgia">Ultima modifica:24/12/2002</font> 
</center>

</body>

</html>
