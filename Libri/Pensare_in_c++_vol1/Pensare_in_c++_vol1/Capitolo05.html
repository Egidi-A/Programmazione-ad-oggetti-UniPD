<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIC2Vone.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:09/27/2001
Translation Time:05:25:32
Translation Platform:Win32
Number of Output files:22
This File:Chapter05.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>5: Nascondere l'implementazione</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF">
<DIV ALIGN="CENTER"> <a href="http://www.MindView.net"> <img src="mindview-head.gif" alt="MindView Inc." border = "0"></a> 
  <center>
    <p align="CENTER"><font face="Verdana" size=2>[ </font><a href="README-HTML.txt"><u><font face="Verdana" size="2" color="#0000ff">Suggerimenti</font></u></a><font face="Verdana" size=2> 
      ] [ </font><a href="http://www.mindview.net/CPPServices/SolutionGuide.html"><u><font face="Verdana" size=2 color="#0000ff">Soluzioni 
      degli Esercizi</font></u></a><font face="Verdana" size=2>] [ </font><a href="http://www.mindview.net/ThinkingInCPP2e.html"><u><font face="Verdana" size=2 color="#0000ff">Volume 
      2</font></u></a><font face="Verdana" size=2> ] [ </font><a href="http://www.mindview.net/MailingList.html"><u><font face="Verdana" size=2 color="#0000ff">Newsletter 
      Gratuita</font></u></a><font face="Verdana" size=2> ] <br>
      [ </font><a href="http://www.mindview.net/CPPServices/#PublicSeminars"><u><font face="Verdana" size=2 color="#0000ff">Seminari</font></u></a><font face="Verdana" size=2> 
      ] [ </font><a href="http://www.mindview.net/CPPServices/#SeminarsOnCD"><u><font face="Verdana" size=2 color="#0000ff">Seminari 
      su CD ROM</font></u></a><font face="Verdana" size=2> ] [ </font><a href="http://www.mindview.net/CPPServices/#ConsultingServices"><u><font face="Verdana" size="2" color="#0000ff">Consulenza</font></u></a><font face="Verdana" size=2>] 
      </font></p>
    <h2 align="CENTER"><font face="Verdana">Pensare in C++, seconda ed. Volume 
      1</font></h2>
    <h3 align="CENTER"><font face="Verdana">&copy;2000 by Bruce Eckel</font></h3>
    <p align="CENTER"><font face="Verdana" size=2>[ </font><a href="Capitolo04.html"><u><font face="Verdana" size=2 color="#0000ff">Capitolo 
      Precedente </font></u></a><font face="Verdana" size=2> ] [ </font><a href="Contents.html"><u><font face="Verdana" size=2 color="#0000ff">Indice 
      Generale</font></u></a><font face="Verdana" size=2> ] [ </font><a href="DocIndex.html"><u><font face="Verdana" size=2 color="#0000ff">Indice 
      Analitico </font></u></a><font face="Verdana" size=2> ] [ </font><a href="Capitolo06.html"><u><font face="Verdana" size=2 color="#0000ff">Prossimo 
      Capitolo</font></u></a><font face="Verdana" size=2> ] </font></p>
    <p align="CENTER"><font face="Georgia, Times New Roman, Times, serif">traduzione 
      italiana e adattamento a cura di Mauro Sorbo</font></p>
  </center>
</DIV>
<FONT FACE = "Verdana"> 
<H1 ALIGN="LEFT">5: Nascondere l'implementazione</H1>
</FONT> 
<DIV ALIGN="LEFT"> 
  <P><font size="4" face="Verdana, Arial, Helvetica, sans-serif">Una tipica libreria 
    C contiene una <b>struct</b> ed alcune funzioni associate per agire su essa. 
    Si è visto come il C++<b> </b>prenda funzioni che sono associate concettualmente 
    e le renda associate letteralmente</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">mettendo le dichiarazioni 
    della funzione&nbsp; dentro lo scope della <b>struct</b>, cambiando il modo 
    in cui le funzioni vengono chiamate per una<b> struct</b>, eliminando il passaggio 
    dell'indirizzo di struttura come primo argomento ed aggiungendo un nuovo tipo 
    di nome al programma ( quindi non si deve creare un <b> typedef</b> per la <b>struct</b>).</font></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Tutto ci&ograve; aiuta 
    ad organizzare il proprio codice e lo rende più facile da scrivere e leggere. 
    Tuttavia ci sono altri problemi quando si creano librerie in C++, specialmente 
    problematiche riguardanti il controllo e la sicurezza. Questo capitolo prende 
    in esame il problema dei limiti nelle strutture.</font></P>
</DIV>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE = "Verdana"> </FONT></P>
</DIV>
<FONT FACE = "Verdana"> 
<H2 ALIGN="LEFT">Fissare i limiti</H2>
</FONT> 
<p ALIGN="LEFT"><font face="Georgia, Times New Roman, Times, serif">In qualsiasi 
  relazione è importante avere dei limiti che sono rispettati da tutte le parti 
  coinvolte. Quando si crea una libreria, si&nbsp;stabilisce una relazione con 
  il <i>programmatore client&nbsp; </i>che&nbsp; usa quella libreria per costruire 
  un'applicazione o un'altra libreria.</font></p>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">In una <b>struct </b>del 
    C, come per la maggior parte delle cose in C, non ci sono regole. I programmatori 
    client possono fare qualsiasi cosa vogliono e non c'è modo di forzare nessun 
    particolare comportamento. Per esempio, nell'ultimo capitolo anche se si capisce 
    l'importanza delle funzioni chiamate<b> inizialize()</b> e <b>cleanup()</b>, 
    il programmatore client ha l'opzione di non chiamare quelle funzioni ( osserveremo 
    un miglior approccio nel prossimo capitolo). E anche se davvero si preferirebbe 
    che il programmatore client non manipolasse direttamente alcuni dei membri 
    della nostra <b>struct</b>, in C non c'è modo di prevenirlo. Ogni cosa è palese 
    al mondo.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Ci sono due ragioni del perch&egrave; 
    si deve controllare l'accesso ai membri. La prima serve a tenere lontane le 
    mani del programmatore client dalle cose che non devono essere toccate, parti 
    che sono necessarie al funzionamento interno dei tipi di dato, ma non parti 
    dell'interfaccia di cui il programmatore client ha bisogno per risolvere i 
    propri problemi. Questo &egrave; davvero un servizio ai programmatori client 
    perch&egrave; essi possono facilmente capire cos'&egrave; importante per loro 
    e cosa possono ignorare.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La seconda ragione per 
    il controllo d'accesso è permettere al progettista della libreria di cambiare 
    la struttura interna senza preoccuparsi di come influenzer&agrave; il programmatore 
    client. Nell'esempio dello <b>Stack</b> nell'ultimo capitolo, si può volere 
    allocare la memoria in grandi&nbsp;blocchi, per rapidit&agrave;, invece di 
    creare spazio ogni volta che un elemento viene aggiunto. Se l'interfaccia 
    e l'implementazione sono chiaramente separate e protette, si pu&ograve; ottenere 
    ci&ograve; richiedendo solo un nuovo link dal programmatore client.</font></P>
</DIV>
<DIV ALIGN="LEFT">
<P><BR>
  </P>
</DIV>
<FONT FACE = "Verdana"> 
<H2 ALIGN="LEFT">Il controllo d'accesso del C++</H2>
</FONT> 
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Il C++ introduce tre 
    nuove parole riservate per fissare i limiti in una struttura: <b>public, private</b> 
    e<b> protected. </b>Il loro uso e il loro significato sono molto semplici. 
    Questi <i> access specifiers (specificificatori di accesso)</i> sono usati 
    solo in una dichiarazione di struttura e cambiano i limiti per tutte le dichiarazioni 
    che li seguono. In qualsiasi momento si usa un specificatore d'accesso, esso 
    deve essere seguito dai due punti.&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Per <b>public</b> s'intende 
    che tutte le dichiarazioni dei membri sono disponibili a tutti. I membri <b>public</b> 
    sono come quelli dello <b>struct</b>. Per esempio, le seguenti dichiarazioni 
    <b>struct</b> sono identiche:&nbsp;&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: C05:Public.cpp</font>
<font color="#009900">// Public è come la struct del C</font></PRE>
  <PRE>

<font color=#0000ff>struct</font> A {
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>char</font> j;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>void</font> func();
};

<font color=#0000ff>void</font> A::func() {}

<font color=#0000ff>struct</font> B {
<font color=#0000ff>public</font>:
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>char</font> j;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>void</font> func();
};

<font color=#0000ff>void</font> B::func() {}  

<font color=#0000ff>int</font> main() {
  A a; B b;
  a.i = b.i = 1;
  a.j = b.j = 'c';
  a.f = b.f = 3.14159;
  a.func();
  b.func();
} <font color=#009900>///:~</font></PRE>
  </FONT> </BLOCKQUOTE>
<p><font face="Georgia, Times New Roman, Times, serif">La parola chiave <b>private</b>, 
  invece, significa che nessuno eccetto noi può accedere a quel membro, il creatore 
  del tipo, dentro i membri funzione di quel tipo. <b>private</b> è un muro di 
  mattoni tra noi&nbsp; e il programmatore client, se qualcuno prova ad accedere 
  al membro <b>private</b>, avrà un errore di compilazione. In <b>struct B</b>&nbsp; 
  nell'esempio sopra, si potrebbe voler nascondere porzioni della rappresentazione 
  ( cio&egrave; il membro data) , accessibile solo per noi:</font></p>
<DIV ALIGN="LEFT"></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: C05:Private.cpp</font>
<font color="#009900">// Fissare i limiti

</font><font color=#0000ff>struct</font> B {
<font color=#0000ff>private</font>:
  <font color=#0000ff>char</font> j;
  <font color=#0000ff>float</font> f;
<font color=#0000ff>public</font>:
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>void</font> func();
};

<font color=#0000ff>void</font> B::func() {
  i = 0;
  j = '0';
  f = 0.0;
};

<font color=#0000ff>int</font> main() {
  B b;
  b.i = 1;    <font color=#009900>// OK, public </font>
<font color=#009900>//!  b.j = '1';  // vietato, private</font>
<font color=#009900>//!  b.f = 1.0;  // vietato, private</font>
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Sebbene <b>func() </b>può 
    accedere a qualsiasi membro di <b>B</b> ( poichè <b>func()</b> è un membro 
    di <b>B</b>, in questo modo ha automaticamente il permesso), un' ordinaria 
    funzione globale come <b>main()</b> non può. Naturalmente, neanche le funzioni 
    membro delle altre strutture. Solamente le funzioni che sono chiaramente dichiarate 
    nella dichiarazione della struttura (il &quot;contratto&quot;) possono avere 
    accesso ai membri <b>private</b>.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Non c'è nessun ordine 
    richiesto per gli specificatori d'accesso e possono apparire pù di una volta. 
    Essi influenzano tutti i membri dichiarati dopo di loro e prima del prossimo 
    specificatore d'accesso.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<FONT FACE = "Verdana"> 
<H3 ALIGN="LEFT"> protected</H3>
</FONT> 
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">L'ultimo specificatore 
    d'accesso è </font><font face="Georgia"><b>protected</b></font><font face="Georgia, Times New Roman, Times, serif">. 
    Esso funziona come <b>private</b>, con un' eccezione che in realtà non pu&ograve; 
    essere spiegata ora: le strutture &quot;ereditate&quot; ( le quali non possono 
    accedere a membri <b>private</b> ) hanno il permesso di </font><font face="Georgia, Times New Roman, Times, serif">accedere 
    ai membri <b>protected</b>. Questo diverrà più chiaro nel capitolo 14 quando 
    l'ereditarietà verrà introdotta. Per il momento si consideri <b>protected</b> 
    come <b>private</b>.&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<FONT FACE = "Verdana"> 
<H2 ALIGN="LEFT"> Friends</H2>
</FONT> 
<DIV ALIGN="LEFT"></DIV>
<p>C<font face="Georgia, Times New Roman, Times, serif">osa succede se si d&agrave; 
  permesso di accesso ad una funzione che non &egrave; un membro della struttura 
  corrente? Ci&ograve; si ottiene dichiarando quella funzione <b>friend</b> <i>dentro 
  </i>la dichiarazione della struttura. &Egrave; importante che la dichiarazione 
  avvenga dentro la dichiarazione della struttura perch&egrave; si deve poter 
  ( e anche il compilatore) leggere la dichiarazione della struttura e vedere 
  tutte le dimensioni ed il comportamento dei tipi di dato. Una regola molto importante 
  in tutte le relazione &egrave;: &quot;<i> Chi pu&ograve; accedere alla mia implementazione 
  privata?&quot;.</i></font></p>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">L</font><font face="Georgia, Times New Roman, Times, serif">a 
    classe controlla quale codice ha accesso ai suoi membri. Non c'è un modo mag<font color="#000000">ico 
    di intrufolarsi dal di fuori se non</font> si è un <b>friend</b>; non si può 
    dichiarare una nuova classe e dire: &quot;<i>Ciao, io sono un amico di <b>Bob</b>!</i>&quot; 
    ed aspettarsi di vedere i membri <b>private</b> e <b>protected</b> di <b>Bob</b>.&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Si può dichiarare una 
    funzione globale come un <b>friend</b> e si può dichiarare anche una funzione 
    membro di un'altra struttura o perfino una struttura intera come un <b>friend</b>. 
    Ecco qui un esempio:</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: C05:Friend.cpp</font>
<font color="#009900">// Friend permette un accesso speciale
// Dichiarazione (specificazione di tipo incompleta)</font></PRE>
  <PRE><font color=#0000ff>struct</font> X;

<font color=#0000ff>struct</font> Y {
  <font color=#0000ff>void</font> f(X*);
};

<font color=#0000ff>struct</font> X { <font color=#009900>// Definizione</font>
<font color=#0000ff>private</font>:
  <font color=#0000ff>int</font> i;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> inizializza();
  <font color=#0000ff>friend</font> <font color=#0000ff>void</font> g(X*, <font color=#0000ff>int</font>); <font color=#009900>// friend globale</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>void</font> Y::f(X*);  <font color=#009900>// Struct membro friend </font>
  <font color=#0000ff>friend</font> <font color=#0000ff>struct</font> Z; <font color=#009900>// L'intera struct è un friend</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>void</font> h();
};

<font color=#0000ff>void</font> X::inizializza() { 
  i = 0; 
}

<font color=#0000ff>void</font> g(X* x, <font color=#0000ff>int</font> i) { 
  x-&gt;i = i; 
}

<font color=#0000ff>void</font> Y::f(X* x) { 
  x-&gt;i = 47; 
}

<font color=#0000ff>struct</font> Z {
<font color=#0000ff>private</font>:
  <font color=#0000ff>int</font> j;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> inizializza();
  <font color=#0000ff>void</font> g(X* x);
};

<font color=#0000ff>void</font> Z::inizializza() { 
  j = 99;
}

<font color=#0000ff>void</font> Z::g(X* x) { 
  x-&gt;i += j; 
}

<font color=#0000ff>void</font> h() {
  X x;
  x.i = 100; <font color=#009900>// manipulazione diretta del dato</font>
}

<font color=#0000ff>int</font> main() {
  X x;
  Z z;
  z.g(&amp;x);
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif"><b>struct</b> <b>Y</b> 
    ha una funzione membro <b>f()</b> che modificherà un oggetto del tipo <b>X</b>. 
    Questo è un po' un rompicapo perchè il compilatore del C++ richiede di dichiarare 
    ogni cosa prima di riferirsi a ciò, quindi la <b>struct Y</b> deve essere 
    dichiarata prima degli stessi membri come un <b>friend</b> nel <b>struct X</b>. 
    Ma per essere dichiarata <b>Y::f(X*)</b>, deve essere prima dichiarata la 
    <b>struct X</b>!&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Ecco qui la soluzione. 
    Si noti che <B>Y::f(X*)</B> prende l'<i>indirizzo</i> di un oggetto <b>X</b>. 
    Questo è critico perchè il compilatore sa sempre come passare un indirizzo, 
    il quale è di lunghezza fissa indifferente all'oggetto che&nbsp;&egrave; passato, 
    anche se non ha tutte le informazioni &nbsp;circa la lunghezza del tipo. Se 
    si prova a passare l'intero oggetto, comunque, il compilatore deve vedere 
    l'intera struttura definizione di <b>X</b> per conoscere la lunghezza e come 
    passarla, prima di permettere di far dichiarare una&nbsp; funzione come <B>Y::g(X)</B>.</font></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Passando un'indirizzo 
    di un <b>X</b>, il compilatore permette di fare una s<i>pecificazione di tipo 
    incompleta</i> di <b>X</b> prima di dichiarare <B>Y::f(X*)</B>. Ciò avviene 
    nella dichiarazione:&nbsp;</font></P>
</DIV>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#0000ff>struct</font> X;</PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P>Q<font face="Georgia, Times New Roman, Times, serif">uesta semplice dichiarazione 
    dice al compilatore che c'è una <b>struct</b> con quel nome, quindi è giusto 
    riferirsi ad essa se non c'&egrave; bisogno di conoscere altro che il nome.</font></P>
</DIV>
<DIV ALIGN="LEFT">
<P><BR>
  </P>
</DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Ora, in <b>struct X</b>, 
    la funzione <B>Y::f(X*) </B>può essere dichiarata come un <b>friend</b> senza 
    nessun problema. Se si provava a dichiararla prima il compilatore avrebbe 
    visto la piena specificazione per <b>Y</b> e avrebbe segnalato un errore. Questo 
    è una caratteristica per assicurare consistenza ed eliminare i bachi.&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"> <BR>
</DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Notare le altre due funzioni 
    <b>friend</b>. La prima dichiara una funzione ordinaria globale <b>g()</b> 
    come un <b>friend</b>. Ma <b>g()</b> non è stata precedentemente dichiarata&nbsp;globale! 
    Risulta che <b>friend</b> può essere usato in questo modo per dichiarare simultaneamente 
    la funzione e darle uno stato <b>friend</b>. Ciò si estende alle intere strutture:</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#0000ff>friend</font> <font color=#0000ff>struct</font> Z;</PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">è una specificazione 
    di tipo incompleta per <b>Z</b> e d&agrave; all'intera struttura lo stato 
    <b>friend</b>.</font></P>
</DIV>
<DIV ALIGN="LEFT">
<P><BR>
  </P>
</DIV>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Friends nidificati</H3>
</FONT>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Usare una struttura nidificata 
    non d&agrave; automaticamente l'accesso ai membri <b>private</b>. Per compiere 
    ciò, si deve seguire una particolare forma: primo, dichiarare( senza definire 
    ) la struttura nidificata, dopo la si dichiara come un <b>friend</b>, ed infine 
    si definisce la struttura. La definizione della struttura deve essere separata 
    dalla dichiarazione di <b>friend</b>, altrimenti sarebbe vista dal compilatore 
    come un non membro. Ecco qui un esempio:</font></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: C05:NestFriend.cpp</font>
<font color=#009900>// friend nidificati</font>
#include &lt;iostream&gt;
#include &lt;cstring&gt; <font color=#009900>// memset()</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 20;

<font color=#0000ff>struct</font> Contenitore {
<font color=#0000ff>private</font>:
  <font color=#0000ff>int</font> a[sz];
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> inizializza();
  <font color=#0000ff>struct</font> Puntatore;
  <font color=#0000ff>friend</font> <font color=#0000ff>struct</font> Puntatore;
  <font color=#0000ff>struct</font> Puntatore {
  <font color=#0000ff>private</font>:
    Contenitore* h;
    <font color=#0000ff>int</font>* p;
  <font color=#0000ff>public</font>:
    <font color=#0000ff>void</font> inizializza(Holder* h);
    <font color=#009900> // per muoversi nel vettore</font>
    <font color=#0000ff>void</font> prossimo();
    <font color=#0000ff>void</font> precedente();
    <font color=#0000ff>void</font> primo();
    <font color=#0000ff>void</font> ultimo();
    <font color=#009900>// accedere ai valori:</font>
    <font color=#0000ff>int</font> leggi();
    <font color=#0000ff>void</font> imposta(<font color=#0000ff>int</font> i);
  };
};

<font color=#0000ff>void</font> Contenitore::inizializza() {
  memset(a, 0, sz * <font color=#0000ff>sizeof</font>(<font color=#0000ff>int</font>));
}

<font color=#0000ff>void</font> Contenitore::Puntatore::inizializza(Holder* rv) {
  h = rv;
  p = rv-&gt;a;
}

<font color=#0000ff>void</font> Contenitore::Puntatore::prossimo() {
  <font color=#0000ff>if</font>(p &lt; &amp;(h-&gt;a[sz - 1])) p++;
}

<font color=#0000ff>void</font> Contenitore::Puntatore::precedente() {
  <font color=#0000ff>if</font>(p &gt; &amp;(h-&gt;a[0])) p--;
}

<font color=#0000ff>void</font> Contenitore::Puntatore::primo() {
  p = &amp;(h-&gt;a[0]);
}

<font color=#0000ff>void</font> Contenitore::Puntatore::ultimo() {
  p = &amp;(h-&gt;a[sz - 1]);
}

<font color=#0000ff>int</font> Contenitore::Puntatore::leggi() {
  <font color=#0000ff>return</font> *p;
}

<font color=#0000ff>void</font> Contenitore::Puntatore::imposta(<font color=#0000ff>int</font> i) {
  *p = i;
}

<font color=#0000ff>int</font> main() {
  Contenitore h;
  Contenitore::Puntatore hp, hp2;
  <font color=#0000ff>int</font> i;

  h.inizializza();
  hp.inizializza(&amp;h);
  hp2.inizializza(&amp;h);
  <font color=#0000ff>for</font>(i = 0; i &lt; sz; i++) {
    hp.imposta(i);
    hp.prossimo();
  }
  hp.primo();
  hp2.ultimo();
  <font color=#0000ff>for</font>(i = 0; i &lt; sz; i++) {
    cout &lt;&lt; <font color=#004488>&quot;hp = &quot;</font> &lt;&lt; hp.leggi()
         &lt;&lt; <font color=#004488>&quot;, hp2 = &quot;</font> &lt;&lt; hp2.leggi() &lt;&lt; endl;
    hp.prossimo();
    hp2.precedente();
  }
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Una volta dichiarato 
    <b>Puntatore</b> è concesso l'accesso ai membri private di <b>Contenitore 
    </b> scrivendo:</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#0000ff>friend</font> <U><font color=#0000ff>struct</font> </U>Puntatore;</PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La <b>struct Contenitore 
    </b> contiene un vettore di <b>int</b> e di <b>Puntatore </b>&nbsp;che permette 
    loro l'accesso. Poichè <b>Puntatore </b> è fortemente associato con <b>Contenitore</b>, 
    è ragionevole farne un membro della struttura del <b>Contenitore</b>. Ma poichè 
    <b>Puntatore </b>è una classe separata dal <b>Contenitore</b>, si pu&ograve; 
    farne più di uno in <b>main()</b> ed usarlo per scegliere differenti parti 
    del vettore. <b>Puntatore </b>è una struttura invece&nbsp;di puntatori C grezzi, 
    quindi si pu&ograve; garantire che punteranno sempre dentro <b>Contenitore</b>.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La funzione della libreria 
    Standard C <b>memset()</b> ( in <b>&lt;cstring&gt;</b> ) è usata per convenienza 
    nel programma di sopra. Essa imposta tutta la memoria ad un indirizzo di partenza 
    ( il primo argomento ) un particolare valore ( il secondo argomento ) per 
    <b>n</b> byte dopo&nbsp; l'indirizzo di partenza ( <b>n</b> è il terzo argomento 
    ). Naturalmente, si potrebbe semplicemente usare un ciclo, ma <b>memset()</b> è disponibile, testato con successo 
    ( così è meno probabile che si introduca un errore) e probabilmente più efficiente 
    di quando lo si codifica&nbsp;a mano.</font></P>
  <BR>
</DIV>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> E' puro?</H3>
</FONT> 
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La definizione di classe 
    d&agrave; una segno di verifica, quindi si può vedere guardando la classe 
    quali funzioni hanno il permesso di modificare le parti <b>private</b> della 
    classe. Se una funzione è un <b>friend,</b> significa che non è un membro, 
    ma si vuole dare un permesso di modificare comunque dati <b>private</b> e 
    deve essere elencata nella definizione della classe così che chiunque possa 
    vedere che è una delle funzioni privilegiate.&nbsp;&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Il C++ è un linguaggio 
    orientato a oggetti ibrido, non un puro, e <b>friend</b> fu aggiunto per aggirare 
    i problemi pratici che sorgevano.&nbsp;</font></P>
  <BR>
</DIV>
<FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Layout dell'oggetto</H2>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Il capitolo 4 afferma 
    che una <b>struct</b> scritta per un compilatore C e poi compilata col C++ 
    rimarrebbe immutata. Ciò è riferito al layout dell'oggetto della <b>struct, 
    </b>cio&egrave;, dove lo spazio per le variabili individuali &egrave; posizionato 
    nella memoria allocata per l'oggetto. Se il compilatore del C++ cambia il 
    layout della <b>struct</b> del C, allora verrebbe corrotto qualsiasi codice 
    C scritto in base alla conoscenza delle posizioni delle variabili nello <b>struct</b>.&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Quando si iniziano ad 
    usare gli specificatori d'accesso, tuttavia, ci si sposta completamente nel 
    regno del C++ e le cose cambiano un po'. Con un particolare &quot;blocco di 
    accesso&quot; (un gruppo di dichiarazioni delimitate dagli specificatori d'accesso 
    ) &egrave; garantito che le variabili siano posizionate in modo contiguo, 
    come in C. Tuttavia i blocchi d'accesso possono non apparire nell'oggetto 
    nell'ordine in cui si dichiarano. Sebbene&nbsp; il compilatore posizioner&agrave; 
    di solito i blocchi esattamente come si vedono, non c'è alcuna regola su ciò, 
    perchè una particolare architettura di macchina e/o ambiente operativo forse 
    pu&ograve; avere un esplicito supporto per il <b>private</b> e <b>protected</b> 
    che potrebbe richiedere che questi blocchi siano posti in locazioni speciali 
    di memoria. La specifica del linguaggio non vuole restringere questa possibilit&agrave;.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Gli specificatori d'accesso 
    sono parte della struttura e non influenzano gli oggetti creati dalla struttura. 
    Tutte le informazioni degli specificatori d'accesso scompaiono prima che il 
    programma giri; generalmente durante la compilazione. In un programma funzionante, 
    gli oggetti diventano &quot; regioni di memoria&quot; e niente più. Se veramente 
    lo si vuole, si possono violare tutte le regole ed accedere alla memoria direttamente, 
    come si può farlo in C. Il C++ non è progettato per preventivarci dal fare 
    cose poco saggie. Esso ci fornisce solamente di una alternativa più facile 
    e molto desiderata.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">In generale, non è una 
    buona idea dipendere da qualcosa che è un' implementazione specifica quando 
    si sta scrivendo un programma. Quando si devono avere dipendenze di specifiche 
    di implementazione, le si racchiudano dentro una struttura cosicchè&nbsp;qualsiasi&nbsp;modifica 
    per la portabilit&agrave; &egrave; concentrata in un solo posto.</font></P>
</DIV>
<FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> La classe</H2>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Il controllo d'accesso 
    è spesso detto <i>occultamento dell'implementazione</i>. Includere funzioni 
    dentro le strutture ( ci&ograve; &egrave; spesso detto incapsulazione<a name="fnB36" href="#fn36">[36]</a>), 
    produce un tipo di dato con caratteristiche e comportamenti, ma l'accesso 
    di controllo pone limiti con quel tipo di dato</font><font face="Georgia, Times New Roman, Times, serif">, 
    per due importanti ragioni. La prima è stabilire cosa il programmatore client 
    può e non può usare. Si può costruire un proprio meccanismo interno nella 
    struttura senza preoccuparsi che il programmatore client penserà che questi 
    meccanismi sono parte dell'interfaccia che dovrebbero essere usati.&nbsp;&nbsp;</font></P>
  </DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Questa problematica porta 
    direttamente alla seconda ragione, che riguarda la separazione dell'interfaccia 
    dall'implementazione. Se la struttura viene usata in un insieme di programmi, 
    ma i programmatori client non possono fare nient'altro che mandare messagi 
    all'interfaccia pubblica, allora si pu&ograve; cambiare tutto ci&ograve; che 
    &egrave; <b>private</b> senza richiedere modifiche al codice.<BR>
    </font></P>
</DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">L'incapsulamento ed il 
    controllo d'accesso, presi insieme, sono qualcosa di più che una <b>struct</b> 
    del C. Ora siamo nel mondo della programmazione orientata agli oggetti, dove 
    una struttura descrive una classe di oggetti come se si descriverebbe una 
    classe di pesci o una classe di uccelli: ogni oggetto appartenente a questa 
    classe&nbsp;condivider&agrave; le stesse caratteristiche e comportamenti. 
    Ecco cosa &egrave; diventata una dichiarazione di struttura, una descrizione 
    del modo in cui tutti gli oggetti di questo tipo appariranno e si comporteranno.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Nell'originale linguaggio 
    OOP, Simula-67, la parola chiave <b>class</b> fu usata per descrivere un nuovo 
    tipo di dato. Ciò apparentemente ispirò Stroustrup a scegliere la stessa parola 
    chiave per il C++, per enfatizzare che questo era il punto focale dell'intero 
    linguaggio: la creazione di nuovi tipi di dato che sono qualcosa in più che 
    le <b>struct</b> del C con funzioni. Ci&ograve; certamente sembra una adeguata 
    giustificazione per una nuova parola chiave.&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Tuttavia l'uso di una 
    <b>class</b> nel C++ si avvicina ad essere una parola chiave non necessaria. 
    E' identica alla parola chiave <b>struct</b> assolutamente in ogni aspetto 
    eccetto uno: <b>class</b> &egrave; per default <b>private</b>, mentre struct 
    &egrave; <b>public</b>. Ecco qui due strutture che producono lo stesso risultato:&nbsp;&nbsp;&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT">
<P><BR>
  </P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: C05:Class.cpp</font>
<font color="#009900">// Similitudini tra struct e class

</font><font color=#0000ff>struct</font> A {
<font color=#0000ff>private</font>:
  <font color=#0000ff>int</font> i, j, k;
<font color=#0000ff>public</font>:
  <font color=#0000ff>int</font> f();
  <font color=#0000ff>void</font> g();
};

<font color=#0000ff>int</font> A::f() { 
  <font color=#0000ff>return</font> i + j + k; 
}

<font color=#0000ff>void</font> A::g() { 
  i = j = k = 0; 
}

<font color="#009900">// Identici risultati sono prodotti con:

</font><font color=#0000ff>class</font> B {
  <font color=#0000ff>int</font> i, j, k;
<font color=#0000ff>public</font>:
  <font color=#0000ff>int</font> f();
  <font color=#0000ff>void</font> g();
};

<font color=#0000ff>int</font> B::f() { 
  <font color=#0000ff>return</font> i + j + k; 
}

<font color=#0000ff>void</font> B::g() { 
  i = j = k = 0; 
} 

<font color=#0000ff>int</font> main() {
  A a;
  B b;
  a.f(); a.g();
  b.f(); b.g();
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La classe è il concetto 
    fondamentale OOP in C++. &Egrave; una delle parole chiave che non sarà indicata 
    in grassetto in questo libro, diventa noiso vederla ripetuta. Il passaggio 
    alle classi &egrave; cos&igrave; importante che sospetto che Stroustrup avrebbe 
    preferito eliminare <b>struct</b>, ma il bisogno di compatibilit&agrave; con 
    il codice esistente non lo ha permesso.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Molti preferiscono uno 
    stile di creazione di classi che è più simile alla <b>struct</b> che alla 
    classe, perchè si pu&ograve; non usare il comportamento <b>private</b> della 
    classe per default iniziando con <b>public</b>:</font></P>
</DIV>
<DIV ALIGN="LEFT">
<P><BR>
  </P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#0000ff>class</font> X {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> funzione_di_interfaccia();
<font color=#0000ff>private</font>:
  <font color=#0000ff>void</font> funzione_privata();
  <font color=#0000ff>int</font> rappresentazione_interna;
}; </PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La logica dietro ciò 
    sta nel fatto che il lettore &egrave; interessato a vedere prima i membri 
    pi&ugrave; importanti, poi pu&ograve; ignorare tutto ci&ograve; che &egrave; 
    <b>private</b>. Infatti, le sole ragioni per cui tutti gli altri membri devono 
    essere dichiarati nella classe sono dovute al fatto che cos&igrave; il compilatore 
    conosce la grandezza degli oggetti e li pu&ograve; allocare correttamente 
    e quindi garantire consistenza.</font></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Gli esempi di questo 
    libro, comunque, porrà i membri <b>private</b> per prima : </font></P>
</DIV>

<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#0000ff>class</font> X {
  <font color=#0000ff>void</font> private_function();
  <font color=#0000ff>int</font> internal_representation;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> interface_function();
}; </PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">qualcuno persino arricchisce 
    i propri nomi nomi privati:</font><BR>
  </P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#0000ff>class</font> Y {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> f();
<font color=#0000ff>private</font>:
  <font color=#0000ff>int</font> mX;  <font color=#009900>// nome &quot;Self-decorated&quot; </font>
}; </PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Poichè <b>mX</b> è già 
    nascosto nello scope di Y, la <b>m</b> ( sta per &quot;membro&quot; ) non 
    &egrave; necessaria.Tuttavia, nei progetti con molte variabili globali ( cosa 
    da evitare, ma a volte &egrave; inevitabile nei progetti esistenti), &egrave; 
    di aiuto poter distinguere all'interno di una definizione di funzione membro 
    quale dato &egrave; globale e quale &egrave; un membro.</font></P>
</DIV>

<DIV ALIGN="LEFT">
  <P><BR>
  </P>
</DIV>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Modificare Stash per usare il controllo d'accesso</H3>
</FONT>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Ha senso riprendere l'esempio del Capitolo 4 e modificarlo 
    per usare le classi ed il controllo d'accesso. Si noti la porzione d'interfaccia 
    del programmatore client &egrave; ora chiaramente distinguibile, quindi non 
    c'&egrave; possibilit&agrave; da parte del programmatore client di manipolare 
    una parte della classe che non dovrebbe.</FONT><BR>
  </P>
  </DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: C05:Stash.h</font>
<font color=#009900>// Convertita per usare il controllo d'accesso</font>
#ifndef STASH_H
#define STASH_H

<font color=#0000ff>class</font> Stash {
  <font color=#0000ff>int</font> size;      <font color=#009900>// Dimensione di ogni spazio</font>
  <font color=#0000ff>int</font> quantity;  <font color=#009900>// Numero dello spazio libero</font>
  <font color=#0000ff>int</font> next;      <font color=#009900>// prossimo spazio libero
 // array di byte allocato dinamicamente:</font>
  <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font>* storage;
  <font color=#0000ff>void</font> inflate(<font color=#0000ff>int</font> increase);
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> initialize(<font color=#0000ff>int</font> size);
  <font color=#0000ff>void</font> cleanup();
  <font color=#0000ff>int</font> add(<font color=#0000ff>void</font>* element);
  <font color=#0000ff>void</font>* fetch(<font color=#0000ff>int</font> index);
  <font color=#0000ff>int</font> count();
};
#endif <font color=#009900>// STASH_H ///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La funzione <b>inflate()</b> 
    è stata resa <b>private</b> perchè è usata solo dalla funzione <b>add()</b> 
    ed è in questo modo parte della implementazione sottostante, non dell' interfaccia. 
    Ciò significa che, in seguito, si può cambiare l'implementazione sottostante 
    per usare un differente sistema per la gestione della memoria.&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia">Tranne l'include del file, l'header di sopra &egrave; 
    l'uncia cosa che &egrave; stata cambiata per questo esempio. Il file di implementanzione 
    ed il file di test sono gli stessi.</font><BR>
  </P></DIV>
<DIV ALIGN="LEFT">
  <P><BR>
  </P></DIV>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT">Modificare Stack per usare il controllo d'accesso</H3>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Come secondo esempio, 
    ecco qui <b>Stack</b> trasformato in una classe. Ora la struttura nidificata 
    data è <b>private</b>, cosa non male perchè assicura che il programmatore 
    client non dovr&agrave; mai guardarla e non dipender&agrave; dalla rappresentazione 
    interna di <b>Stack</b>:</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: C05:Stack2.h</font>
<font color=#009900>// struct nidificate tramite linked list</font>
#ifndef STACK2_H
#define STACK2_H

<font color=#0000ff>class</font> Stack {
  <font color=#0000ff>struct</font> Link {
    <font color=#0000ff>void</font>* data;
    Link* next;
    <font color=#0000ff>void</font> initialize(<font color=#0000ff>void</font>* dat, Link* nxt);
  }* head;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> initialize();
  <font color=#0000ff>void</font> push(<font color=#0000ff>void</font>* dat);
  <font color=#0000ff>void</font>* peek();
  <font color=#0000ff>void</font>* pop();
  <font color=#0000ff>void</font> cleanup();
};
#endif <font color=#009900>// STACK2_H ///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Come prima, l'implementazione 
    non cambia e quindi non è ripetuta qui. Anche il test è identico. L'unica 
    cosa che è stata cambiata è la robustezza dell'interfaccia della classe. Il 
    valore reale del controllo d'accesso è impedire di oltrepassare i limiti durante 
    lo sviluppo. Infatti, il compilatore&nbsp; è l'unico che conosce il livello 
    di protezione dei membri della classe. Nessuna informazione del controllo 
    di accesso arriva al linker, tutti i controlli di protezione sono fatti dal 
    compilatore. </font></P>
</DIV>


<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Si noti che l'interfaccia 
    presentata al programmatore client è adesso veramente quella di uno stack 
    di tipo push-down. &Egrave; implementato come una linked list, ma la si pu&ograve; 
    cambiare senza influenzare il programmatore client che interagisce con essa. 
    </font></P>
</DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif"></font></P>
</DIV>
<FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> <font face="Verdana, Arial, Helvetica, sans-serif">Gestire le 
  classi</font></H2>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Il controllo d'accesso 
    in C++ permette di separare l'interfaccia dall'implementazione, ma l'occultamento 
    dell'implementazione è solamente parziale. Il compilatore deve vedere ancora 
    le dichiarazioni di tutte le parti di un oggetto per crearlo e manipolarlo 
    correttamente. Si potrebbe immaginare un linguaggio di programmazione che 
    richiede solo un'interfaccia pubblica di un oggetto e permette di nascondere 
    l'implementazione privata, ma il C++ esegue la maggior parte dei controlli 
    sul tipo staticamente ( a tempo di compilazione) . Ci&ograve; significa che 
    si sapr&agrave; subito se c'&egrave; un errore. Significa anche che il proprio 
    programma &egrave; pi&ugrave; efficiente. Tuttavia, includere l'implementazione 
    privata ha due effetti: l'implementazione &egrave; visibile anche se non &egrave; 
    accessibile e pu&ograve; richiedere un inutile ricompilazione.</font></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><FONT FACE = "Verdana"></FONT></P>
</DIV>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Nascondere l'implementazione</H3>
</FONT> 
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Alcuni progetti non possono 
    permettersi di avere le loro implementazioni visibili al programmatore client. 
    Essa pu&ograve; mostrare informazioni strategiche in un file header di libreria&nbsp;che 
    un'azienda non vuole mostrare alla concorrenza. Si pu&ograve; star lavorando 
    su un sistema dove la sicurezza &egrave; un requisito, un algoritmo di criptazione 
    per esempio, e non si vuole esporre indizzi in un file header che potrebbero 
    aiutare a crackare il codice. Oppure si pu&ograve; volere mettere il codice 
    in un ambiente ostile, dove i programmatori accedono direttamente ai componenti 
    privati, usando puntatori e casting. In tutte queste situazioni, serve avere 
    la struttura compilata dentro un file d'implementazione piuttosto che esposta 
    in un file header.</font></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><BR>
  </P></DIV>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Ridurre la ricompilazione </H3>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><FONT FACE="Georgia">Il project manager del proprio ambiente di programmazione 
    ricompiler&agrave; un file se esso &egrave; toccato ( cio&egrave;, modificato) 
    oppure se un altro file dipende da esso, cio&egrave; se &egrave; modificato 
    un file header. Questo significa che ogni volta che si fa un cambiamento ad 
    una classe, non importa se alla sua interfaccia pubblica o ai membri privati, 
    si forzer&agrave; una ricompilazione di qualsiasi cosa che include quel header 
    file. Ci&ograve; &egrave; spesso detto <i>fragile base-class problem ( problema 
    di classe base fragile). </i>Per un progetto grosso nelle prime fasi ci&ograve; 
    pu&ograve; essere ingombrante perch&egrave; l'implementazione sottostante 
    pu&ograve; cambiare spesso; se il progetto &egrave; molto grande, il tempo 
    di compilazione pu&ograve; proibire cambiamenti rapidi.</FONT></P>
  
</DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">La tecnica per risolvere 
    ci&ograve; &egrave; spesso detta <i>handle classes</i> oppure &quot;Cheshire 
    cat&quot;<a name="fnB37" href="#fn37">[37]</a>, ogni cosa tranne l'implementazione 
    scompare fatta eccezione di un singolo puntatore, lo &quot;smile&quot;. Il 
    puntatore si riferisce ad una struttura la cui definizione &egrave; nel file 
    di implementazione con tutte le definizioni delle funzioni membro. Quindi, 
    finch&egrave; l'interfaccia non viene toccata, l'header file non &egrave; 
    modificato. L'implementazione pu&ograve; cambiare e solo il file di imlementazione 
    deve essere ricompilato e relinkato con il progetto. </font></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">Ecco qui un semplice 
    esempio dimostrante la tecnica. Il file principale contiene solo l'interfaccia 
    pubblica e un singolo puntatore di un una incompleta classe specificata&nbsp;:</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"> 
  <PRE><font color=#009900>//: C05:Handle.h</font>
<font color=#009900>/<font face="Georgia, Times New Roman, Times, serif">/ handle classes

</font></font>#ifndef HANDLE_H
#define HANDLE_H

<font color=#0000ff>class</font> Handle {
  <font color=#0000ff>struct</font> Cheshire; <font color=#009900>// solo la dichiarazione della classe</font>
  Cheshire* smile;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> inizializza();
  <font color=#0000ff>void</font> pulisci();
  <font color=#0000ff>int</font> leggi();
  <font color=#0000ff>void</font> cambia(<font color=#0000ff>int</font>);
};
#endif <font color=#009900>// HANDLE_H ///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Questo è tutto quello 
    che il programmatore client pu&ograve; vedere. La linea</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>struct</font> Cheshire;</PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">è una </font><font face="Georgia"><i>incomplete 
    type specification</i></font> ( <font face="Georgia, Times New Roman, Times, serif">specificazione 
    incompleta di tipo) o una <i>dichiarazione di classe</i> ( una definizione 
    di classe include il corpo di una classe). Esso dice al compilatore che il 
    <b>Cheshire</b> &egrave; un nome di struttura, ma non fornisce dettagli circa 
    la struct. Questa è un' informazione sufficiente per creare un puntatore alla 
    <b>struct</b>, non si può creare un oggetto prima che sia stata fornito il 
    corpo della struttura. In questa tecnica il corpo della struttura &egrave; 
    nascosto nel file di implementazione:</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: C05:Handle.cpp {O}</font>
<font color=#009900>// implementazione del Handle </font>
#include <font color=#004488>&quot;Handle.h&quot;</font>
#include <font color=#004488>&quot;../require.h&quot;</font>

<font color=#009900>// Definizione dell'implementazione del Handle:</font>
<font color=#0000ff>struct</font> Handle::Cheshire {
  <font color=#0000ff>int</font> i;
};

<font color=#0000ff>void</font> Handle::inizializza() {
  smile = <font color=#0000ff>new</font> Cheshire;
  smile-&gt;i = 0;
}

<font color=#0000ff>void</font> Handle::pulisci() {
  <font color=#0000ff>delete</font> smile;
}

<font color=#0000ff>int</font> Handle::leggi() {
  <font color=#0000ff>return</font> smile-&gt;i;
}

<font color=#0000ff>void</font> Handle::cambia(<font color=#0000ff>int</font> x) {
  smile-&gt;i = x;
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif"><b>Cheshire</b> è una 
    struttura nidificata, quindi deve essere definita con la risoluzione dello 
    scope:</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>struct</font> Handle::Cheshire {</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT">
  <P>Nel <FONT FACE="Georgia"><B>Handle::inizializza(&#160;), </B>il salvataggio 
    è localizzato per una struttura Cheshire, e nel </FONT><FONT FACE="Georgia"><B>Handle::pulisci(&#160;) 
    </B>questo salvataggio è rilasciato. Questo salvataggio è usato al posto di 
    tutti gli elementi dato che normalmente si metterebbero nella sezione <b>private</b> 
    della classe. Quando si compila <b>Handle.cpp</b>, questa definizione di struttura 
    è celata in un oggetto dove nessuno può vederla. Se si cambiano gli elementi 
    di <b>Cheshire</b>, l'unico file che deve essere ricompilato è <b>Handle.cpp 
    </b>perchè il file principale non viene modificato.&nbsp;</FONT></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">L'uso di <b>Handle</b> 
    è identico all'uso di qualsiasi classe: si include l'header, si creano oggetti 
    e si mandano messaggi.</font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>

<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>//: C05:UseHandle.cpp</font>
<font color=#009900>//{L} Handle</font>
<font color=#009900>// Usare  la  Handle class</font>
#include <font color=#004488>&quot;Handle.h&quot;</font>

<font color=#0000ff>int</font> main() {
  Handle u;
  u.inizializza();
  u.leggi();
  u.cambia(1);
  u.pulisci();
} <font color=#009900>///:~</font></PRE>
  </FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT">
  <P><font face="Georgia, Times New Roman, Times, serif">L'unica cosa a cui il 
    programmatore client può accedere è l'interfaccia pubblica, quindi finch&egrave; 
    l'implementazione è l'unica cosa che cambia, il file sopracitato non ha bisogno 
    mai di essere ricompilato. Dunque sebbene questo non è un perfetto occultamento 
    dell'implementazione, esso è una gran miglioramento.&nbsp;</font></P>
</DIV>

<DIV ALIGN="LEFT">
  <P><FONT FACE = "Verdana"></FONT></P>
</DIV>
<FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Sommario</H2>
</FONT> 
<p ALIGN="LEFT"><font face="Georgia, Times New Roman, Times, serif">Il controllo 
  d'accesso in C++ d&agrave; un prezioso controllo al creatore di una classe. 
  Gli utenti della classe possono chiaramente vedere cosa esattamente possono 
  usare e cosa ignorare. Ancor più importante è l' abilità di assicurare che nessun 
  programmatore client diventi dipendente da qualche parte della implementazione sottostante della classe. Se si conosce ciò come creatore di una classe 
  , si pu&ograve; cambiare l'implementazione sottostante con la consapevolezza 
  che nessun programmatore client sarà penalizzato dai cambiamenti, perchè essi 
  non possono accedere a quella parte della classe.</font></p>
<DIV ALIGN="LEFT"></DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">Quando si ha la competenza  
    di cambiare l' implementazione sottostante, non solo si pu&ograve; migliorare 
    il proprio progetto dopo un po', ma si ha anche la libertà di commettere errori. 
    Non &egrave; importante come accuratamente si pianifichi e progetti, si faranno 
    errori. Sapendo ciò è relativamente sicuro fare questi errori e ciò significa 
    che si sar&agrave; più sperimentatori, si imparer&agrave; più velocemente 
    e si finira il proprio progetto più presto.&nbsp;&nbsp;</font></P>
</DIV>
<DIV ALIGN="LEFT"> </DIV>
<DIV ALIGN="LEFT"> 
  <P><font face="Georgia, Times New Roman, Times, serif">L'interfaccia pubblica 
    di una classe è&nbsp;ciò che il programmatore client <i> vede</i>, quindi 
    è la parte più importante della cl<font color="#000000">asse per fare bene 
    durante </font>l'analisi e il disegno. Ma anche qui c'&egrave; margine per 
    cambiare. Se non si ottiene la giusta interfaccia la prima volta, si possono 
    aggiungere pi&ugrave; funzioni mantendo quelle che i programmatori client 
    hanno gi&agrave; usato nel loro codice.</font></P>
</DIV>
<DIV ALIGN="LEFT">
<P><BR>
  </P>
</DIV>
<FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Esercizi</H2>
</FONT>
<DIV ALIGN="LEFT"> 
  <P><font face=Georgia>Le soluzioni degli esercizi selezionati possono essere 
    trovate nel documento elettronico <i>The Thinking in C++ Annotated Solution 
    Guide</i> , disponibile per una piccola somma su www.BruceEckel.com </font></P>
</DIV>
<DIV ALIGN="LEFT"></DIV>
<ol>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia, Times New Roman, Times, serif">Creare 
      una classe con membri dato e membri di funzione <b>public</b>,<b>private</b> 
      e <b>protected</b>. Creare un oggetto di questa classe e vedere che tipo 
      di messaggio del compilatore si ottiene quando si prova ad accedere ai membri 
      di tutte le classi.</font></DIV>
    <DIV ALIGN="LEFT"></DIV>
    <DIV ALIGN="LEFT"> 
      <DIV ALIGN="LEFT"></DIV>
    </DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"> 
      <DIV ALIGN="LEFT"><font face="Georgia, Times New Roman, Times, serif">Scrivere 
        una <b>struct</b> chiamata <b>Lib</b> che contiene 3 stringhe <b>a,b</b> 
        e <b>c</b>. Nel <b>main()</b> creare un oggetto del <b>Lib</b> chiamato 
        <b>x </b>ed assegnare a&nbsp;&nbsp; <B>x.a</B>, <B>x.b</B>, e <B>x.c</B>. 
        Stampare i valori. Ora rimpiazzare <b>a,b</b> e <b>c</b> con un vettore 
        di <b>string</b> <B>s[3]</B>. Mostrare che il nostro codice in <b>main( 
        )</b> interrompe come un risultato di un cambiamento. Adesso creare una 
        class chiamata <b>Libc</b>, con oggetti&nbsp; &nbsp;<B>private</B> <B>string</B> 
        <b>a,b,</b> e <b>c</b>, e le funzioni del membro.</font></DIV>
    </DIV>
    <DIV ALIGN="LEFT"></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia, Times New Roman, Times, serif">Creare 
      una classe ed una funzione globale <b>friend</b> che manipola dati <b>private</b> 
      in una classe.</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia, Times New Roman, Times, serif">Scrivere 
      due classi, una che ha una funzione membro che prende un puntatore ad un 
      oggetto di un altra classe. Creare instanze di entrambi gli oggetti in <b>main() 
      </b>e chiamare la funzione membro in ogni classe.</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia, Times New Roman, Times, serif">Creare 
      tre classi. La prima classe contiene dati <b>private</b> e fornisce privilegi 
      ad una seconda</font><font face="Georgia"> classe ed ad una funzione membro 
      della terza classe. Nel<b> main()</b>, dimostrare che tutte funzionano correttamente.</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia">Creare una classe <b>Hen</b>. Dentro 
      essa annidare una classe <b>Nest</b>. Dentro <b>Nest</b> piazzare una classe 
      <b>Egg</b>. Ogni classe dovrebbe avere una funzione membro <b>display()</b>. 
      Nel <b>main()</b>, creare un'istanza di ogni classe e chiamare la funzione 
      <b>display()</b> per ognuno.</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia">Modificare l'esercizio 6 in modo che 
      <b>Nest</b> ed <b>Egg</b> contengano ognuno dati <b>private</b>. Rendere 
      <b>friend</b> per permettere che le classi incluse possano accedere i dati 
      privati.</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia">Creare una classe con i membri dato 
      distribuiti tra numerose sezioni <b>public</b>, <b>private </b>e<b> protected. 
      </b>Aggiungere una funzione membro <b>showMap()</b> che stampa i nomi di 
      ognudo di questi membri dato ed i loro indirizzi. Se possibile, compilare 
      ed eseguire questo programma su pi&ugrave; di un compilatore e/o computer 
      e/o sistema operativo per vedere se ci sono differenze di layout nell'oggetto.</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia">Copiare l'implementazione e i file 
      di test per <b>Stash</b> del Capitolo 4 in modo che si pu&ograve; compilare 
      e testare <b>Stash.h</b> in questo capitolo. </font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia">Piazzare gli oggetti della classe <b>Hen</b> 
      dell'esercizio 6 in uno <b>Stash</b>. Accedere ad esse e stamparli ( se 
      ancora non si &egrave; fatto cos&igrave;, bisogna aggiungere <b>Hen::print(&#160;)</b>).</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia">Modificare <b>Cheshire</b> in <b>Handle.cpp</b> 
      e verificare che il proprio manager del progetto ricompila e linka solo 
      questo file, ma non ricompila <b>UseHandle.cpp</b>.</font></DIV>
  </li>
  <li> 
    <DIV ALIGN="LEFT"><font face="Georgia">Creare una classe <b>StackOfInt</b> 
      ( uno stack che gestisce interi) usando la tecnica &quot;Cheshire cat&quot;, 
      che nasconde la struttura dei dati a basso livello che si usa per memorizzare 
      gli elementi in una classe chiamata <b>StackImp</b>. Implementare due versioni 
      di <b>StackImp</b>: una che usa un array di <b>int</b> a lunghezza fissa 
      e una che usa <b>vector&lt;int&gt;</b>. Si usi una dimensione grande in 
      modo da non preoccuparsi di incrementare la dimensione dell'array nella 
      prima versione. Notare che la classe <b>StackOfInt.h</b> non deve essere 
      cambiata con <b>StackImp</b>.</font></DIV>
  </li>
</ol>
<FONT FACE = "Verdana"><H1 ALIGN="LEFT">
</H1></FONT>
<DIV ALIGN="LEFT"></DIV>
<FONT FACE = "Verdana"><H1 ALIGN="LEFT">
</H1></FONT>

<HR><DIV ALIGN="LEFT">
  <P><A NAME="fn36" HREF="#fnB36">[36]</A><FONT FACE="Georgia" SIZE=2> Come notato 
    prima, a volte il controllo di accesso &egrave; indicato come incapsulamento.</FONT><BR>
  </P></DIV>
<DIV ALIGN="LEFT">
  <P><A NAME="fn37" HREF="#fnB37">[37]</A><FONT FACE="Georgia" SIZE=2> Questo 
    nome &egrave; attribuito a John Carolan, uno dei primi pionieri del C++, e 
    naturalmente, Lewis Carroll. Questa tecnica pu&ograve; anche essere vista 
    come un tipo di design pattern &quot;bridge&quot;, descritto nel Volume 2</FONT><font face="Georgia" size="2">.</font><BR>
  </P></DIV>

<DIV ALIGN="CENTER"> <font face="Verdana" size=2>[ </font><a href="Capitolo04.html"><u><font face="Verdana" size=2 color="#0000ff">Capitolo 
  Precedente </font></u></a><font face="Verdana" size=2> ] [ </font><a href="Contents.html"><u><font face="Verdana" size=2 color="#0000ff">Indice 
  Generale</font></u></a><font face="Verdana" size=2> ] [ </font><a href="DocIndex.html"><u><font face="Verdana" size=2 color="#0000ff">Indice 
  Analitico </font></u></a><font face="Verdana" size=2> ] [ </font><a href="Capitolo06.html"><u><font face="Verdana" size=2 color="#0000ff">Prossimo 
  Capitolo</font></u></a><font face="Verdana" size=2> ] </font><BR>
  Ultimo Aggiornamento: 08/02/2003</DIV>

</BODY>

</HTML>
