<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (X11; I; SunOS 5.5.1 sun4m) [Netscape]">
   <title>10: Controllo dei Nomi</title>
</head>
<body bgcolor="#FFFFFF">

<center><a href="http://www.MindView.net/"><img SRC="mindview-head.gif" ALT="MindView Inc." BORDER=0 height=81 width=636></a>
</center><p><center><font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="README-HTML.txt">Suggerimenti</a></font></u>
] [ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/SolutionGuide.html">Soluzioni
degli Esercizi</a></font></u>] [ <u><font color="#0000FF"><a href="http://www.mindview.net/ThinkingInCPP2e.html">Volume
2</a></font></u> ] [ <u><font color="#0000FF"><a href="http://www.mindview.net/MailingList.html">Newsletter
Gratuita</a></font></u> ]</font></font>
<br><font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/#PublicSeminars">Seminari</a></font></u>
] [ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/#SeminarsOnCD">Seminari
su CD ROM</a></font></u> ] [ <u><font color="#0000FF"><a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulenza</a></font></u>]</font></font></center>

<center>
<h2>
<font face="Verdana">Pensare in C++, seconda ed. Volume 1</font></h2></center>

<center>
<h3>
<font face="Verdana">&copy;2000 by Bruce Eckel</font></h3></center>

<center>
  <font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="Capitolo09.html">Capitolo 
  Precedente </a></font></u>] [ <u><font color="#0000FF"><a href="Contents.html">Indice 
  Generale</a></font></u> ] [ <u><font color="#0000FF"><a href="DocIndex.html">Indice 
  Analitico </a></font></u>] [ <u><font color="#0000FF"><a href="Capitolo11.html">Prossimo 
  Capitolo</a></font></u> ]</font></font> 
  <p><font face="Georgia, Times New Roman, Times, serif"><font size=-1>trad.
italiana e adattamento a cura di Giacomo Grande</font></font></center>

<h1> <font face="Verdana, Arial, Helvetica, sans-serif">10: Controllo dei Nomi<o:p></o:p></font><o:p></o:p></h1>
<p><span lang=IT style='font-size:13.5pt;font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif" size="4">Inventare nomi 
  è un'attività fondamentale nella programmazione, e quando un progetto diventa 
  molto grande il numero di nomi puo' diventare opprimente.</font> </span></p>
<p><font face="Georgia, Times New Roman, Times, serif">Il</font><font face="Georgia, Times New Roman, Times, serif"> 
  C++ fornisce una gran quantità di controlli sulla creazione e visibiltà dei 
  nomi, sulla loro posizione in memoria e sul linkage. La parola chiave <b>static</b> 
  è stata sovraccaricata (di significato) in C prima ancora che la gente conoscesse 
  il significato del termine "overload" e il C++ ha aggiunto anche un altro significato. 
  Il concetto base per tutti gli usi che si fanno della parola <b>static</b> sembra 
  essere "qualcosa che ricorda la sua posizione" (come l'elettricità statica), 
  che si tratti della posizione fisica in memoria o della visibilità all'interno 
  di un file. In questo capitolo impareremo come la parola chiave <b>static</b> 
  controlla l'allocazione e la visibilità, vedremo un modo migliore per controllare 
  l'accesso ai nomi, attraverso il concetto di <i>namespace</i> (spazio dei nomi) 
  proprio del C++. Scopriremo anche come usare le funzioni scritte e compilate 
  in C.</font></p>
<h2> <font face="Verdana, Arial, Helvetica, sans-serif">Elementi statici dal C<o:p></o:p></font><o:p></o:p></h2>
<font face="Georgia">Sia in C che in C++ la parola chiave <b>static</b>
assume due significati di base, che sfortunatamente spesso si intrecciano:</font> 
<ol start=1 type=1>
<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Allocato
una volta per tutte ad un indirizzo fisso; cioè l'oggetto viene creato
in una speciale <i>area di dati statica</i> piuttosto che nello stack ogni
volta che viene chiamata una funzione. Questo è il concetto di <i>allocazione
statica</i>.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Locale
ad una particolare unità di compilazione (e locale allo scope di una classe
in C++, come vedremo). Qui la parola <b>static</b> controlla la <i>visibilità</i>
del nome, cosicchè il nome non puo' essere visto al di fuori dell'unità
di compilazione o della classe. Questo descrive anche il concetto di <i>linkage</i>,
che determina quali nomi sono visibili al linker.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>
</ol>
<font face="Georgia">Questa sezione spiega i due precedenti significati
della parola <b>static</b> così come sono stati ereditati dal C.</font> 
<h3> <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">variabili statiche all'interno 
  di funzioni<o:p></o:p></font><o:p></o:p></span></h3>
<p><font face="Georgia">Quando creiamo una variabile locale all'interno di una 
  funzione, il compilatore le alloca memoria sullo stack ogni volta che la funzione 
  viene chiamata, spostando opportunamente in avanti lo stack pointer. Se c'è 
  una sequenza di inizializzazione per la variabile, questa viene eseguita ad 
  ogni chiamata della funzione. A volte, tuttavia, si vuole mantenere il valore 
  di una variabile tra una chiamata e l'altra di una funzione. Questo lo si puo' 
  ottenere utilizzando una variabile globale, ma questa sarebbe visibile a tutti 
  e non solo alla funzione in esame. Il C e il C++ permettono di creare oggetti 
  <b>static</b> all'interno di funzioni; l'allocazione di memoria per questi oggetti 
  non avviene sullo stack, ma all'interno dell'area dati statica del programma. 
  L'oggetto viene inizializzato una sola volta, la prima volta che la funzione 
  viene chiamata, e poi mantiene il suo valore tra una chiamata e l'altra della 
  funzione. Per esempio, la seguente funzione restituisce il carattere successivo 
  nell'array ogni volta che la funzione viene chiamata:</font> </p>
<BLOCKQUOTE><FONT SIZE = "+1">
<PRE><font color="#009900">//: C10:VariabiliStaticheInFunzioni.cpp
</font>#include <font color="#004488">"../require.h"
</font>#include &lt;iostream>
<font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;

<font color="#0000FF">char</font> unChar(<font color="#0000FF">const</font> <font color="#0000FF" >char</font><font >* charArray = 0) {
&nbsp; <font color="#0000FF">static</font></font> <font color="#0000FF">const</font> <font color="#0000FF" >char</font><font >* s;
&nbsp; <font color="#0000FF">if</font>(charArray) {
&nbsp;&nbsp;&nbsp; s = charArray;
&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> *s;
&nbsp; }
&nbsp; <font color="#0000FF">else
</font>&nbsp;&nbsp;&nbsp; require(s, <font color="#004488">"s non-inizializzata"</font>);
&nbsp; <font color="#0000FF">if</font>(*s == '\0')
&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> 0;
&nbsp; <font color="#0000FF">return</font> *s++;
}

<font color="#0000FF">char</font>* a = <font color="#004488">"abcdefghijklmnopqrstuvwxyz"</font>;

<font color="#0000FF">int</font> main() {
&nbsp; <font color="#009900">// unChar(); // require() fallisce
</font>&nbsp; unChar(a); <font color="#009900">// Inizializza s con il valore di a
</font></font>  <font color="#0000FF" size="+1">char</font><font > c;
  <font color="#0000FF">while</font>((c = unChar()) != 0)
    cout &lt;&lt; c &lt;&lt; endl;
} <font color="#009900">///:~</font></font></pre></FONT>
</blockquote>
<font face="Georgia">La variabile <b>static char* s </b>mantiene il suo
valore tra le chiamate a <b>unChar( )</b> perchè la sua locazione di
memoria non è parte dello spazio di stack della funzione, ma è dentro
l'area statica del programma. Quando viene chiamata la funzione <b>unChar(
)</b> con un argomemto di tipo <b>char *</b>, all'argomento viene assegnato
<b>s</b>
e viene restituito il primo carattere dell'array. Tutte le chiamate successive
alla funzione <b>unChar()</b>, fatte senza argomento, producono il valore
di default zero per <b>charArray</b>, il che indica alla funzione che si
stanno ancora estraendo caratteri dal valore precedentemente inizializzato
di <b>s</b>. La funzione continua a produrre caratteri fino a quando non
incontra il terminatore null dell'array di caratteri, momento in cui smette
di incrementare il puntatore in modo da non sfondare il limite dell'array. Ma
cosa succede se chiamiamo la funzione <b>unChar()</b> senza argomenti
e senza preventivamente inizializzare il valore di <b>s</b>? Nella definizione
di <b>s</b> potremmo fornire un valore iniziale,</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">static</font> <font color="#0000FF">char</font>* s = 0;</font></pre></font>
</blockquote>
<font face="Georgia">ma anche se non effettuiamo l'inizializzazione di
una variabile statica di un tipo predefinito, il compilatore garantisce
che questa variabile sarà inizializzata a zero (convertita ad un tipo
appropriato) allo start-up del programma. Cosicchè, la prima volta che
viene chiamata la funzione <b>unChar()</b>, <b>s</b> è zero. In questo
caso, l'istruzione condizionale <b>if(!s)</b> lo proverebbe. L'inizializzazione
di <b>s</b> fatta sopra è molto semplice, ma in generale l'inizializzazione
di oggetti statici (come per tutti gli altri) puo' essere fatta con espressioni
che coinvolgono costanti, variabili dichiarate precedentemente e funzioni. Bisogna
essere consapevoli che la funzione di sopra è molto vulnerabile ai problemi
del multithreading; ogni qualvolta si introducono funzioni con variabili
statiche bisogna stare attenti al multithreading.</font> 
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">oggetti di classi statiche 
  all'interno di funzioni<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Le regole sono le stesse di quelle per oggetti statici
di tipi definiti dall'utente, compreso il fatto che l'oggetto richiede
una qualche inizializzazione. Tuttavia l'assegnamento del valore zero è
significativo solo per tipi predefiniti; i tipi definiti dall'utente necessitano
di un costruttore per essere inizializzati. Percio', se non si specificano
gli argomenti per il costruttore in fase di definizione di un oggetto statico,
viene usato un costruttore di default, che ogni classe deve fornire. Per
esempio,</font>  
<blockquote><font size="+1">
  <pre><font face="Georgia"><font color="#009900">//: C10:OggettiStaticiInFunzioni.cpp
</font>#include &lt;iostream>
<font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;

<font color="#0000FF">class</font> X {
&nbsp; <font color="#0000FF">int</font> i;
<font color="#0000FF">public</font>:
&nbsp; X(<font color="#0000FF">int</font> ii = 0) : i(ii) {} <font color="#009900">// Default
</font>&nbsp; ~X() { cout &lt;&lt; <font color="#004488">"X::~X()"</font> &lt;&lt; endl; }
};

<font color="#0000FF">void</font> f() {
&nbsp; <font color="#0000FF">static</font> X x1(47);
&nbsp; <font color="#0000FF">static</font> X x2; <font color="#009900">// Richiesto il costruttore di Default
</font>}

<font color="#0000FF">int</font> main() {
&nbsp; f();
} <font color="#009900">///:~</font></font></pre></FONT>
</blockquote>
<font face="Georgia">Gli oggetti statici di tipo <b>X</b> all'interno di <b>f()</b> possono
essere inizializzati sia con una lista di argomenti passati al costruttore,
sia con il costruttore di default. Questa costruzione avviene la prima
volta che il controllo passa attraverso la definizione, e solo la prima
volta.</font> 
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Distruttori di oggetti 
  statici<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">I distruttori per oggetti statici (cioè tutti quelli
con locazione statica, non solo quelli statici locali come nell'esempio
sopra) vengono chiamati quando si esce dal <b>main()</b> o quando viene
chiamata esplicitamente la funzione <b>exit()</b> della libreria standard
del C. In molte implementazioni la funzione <b>exit()</b> viene chiamata
all'uscita del <b>main()</b>. Questo significa che è dannoso chiamare
la funzione <b>exit()</b> all'interno di un distruttore, in quanto si potrebbe
cadere in un loop infinito. I distruttori di oggetti statici non vengono
chiamati se si esce dal programma usando la funzione di libreria <b>abort()</b>. Si
possono specificare le azioni che il programma deve svolgere all'uscita
del <b>main()</b> (o alla chiamata di <b>exit()</b>) usando la funzione
della libreria standard del C <b>atexit()</b>. In questo caso le funzioni
registrate con <b>atexit()</b> possono essere chiamate prima dei distruttori
per tutti gli oggetti costruiti, prima di uscire dal <b>main()</b> (o della
chiamata ad <b>exit()</b>).</font>  

<p style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><span 
lang=IT style='mso-ansi-language:IT'><font face="Georgia">La
distruzione di oggetti statici, come per quelli ordinari, avviene nell'ordine
inverso rispetto all'inizializzazione. Tuttavia, solo gli oggetti costruiti
vengono distrutti. Fortunatamente i tools di sviluppo del C++ tengono traccia
dell'ordine di inizializzazione e degli oggetti che sono stati costruiti
(per i quali, cioè, è stato chiamato un costruttore). Gli oggetti globali
vengono sempre costruiti prima di entrare nel
<b>main</b>() e distrutti
all'uscita del <b>main</b>(), ma se una funzione che contiene un oggetto
statico locale non viene mai chiamata, il costruttore di tale oggetto non
viene mai eseguito e quindi neanche il distruttore sarà eseguito. Per
esempio,</font><o:p></o:p></span>
<blockquote><FONT SIZE = "+1">
<pre><font color="#009900">//: C10:DistruttoriStatici.cpp
// Distruttori di oggetti statici
</font>#include &lt;fstream>
<font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;
ofstream out(<font color="#004488">"statdest.out"</font>); <font color="#009900">// file di tracciamento

</font><font color="#0000FF">class</font> Obj {
&nbsp; <font color="#0000FF">char</font> c; <font color="#009900">// Identificatore
</font><font color="#0000FF">public</font>:
&nbsp; Obj(<font color="#0000FF">char</font> cc) : c(cc) {
&nbsp;&nbsp;&nbsp; out &lt;&lt; <font color="#004488">"Obj::Obj() per "</font> &lt;&lt; c &lt;&lt; endl;
&nbsp; }
&nbsp; ~Obj() {
&nbsp;&nbsp;&nbsp; out &lt;&lt; <font color="#004488">"Obj::~Obj() per "</font> &lt;&lt; c &lt;&lt; endl;
&nbsp; }
};

Obj a('a'); <font color="#009900">// Globale (memorizzazione statica)
// Costruttore &amp; distruttore sempre chiamati

</font><font color="#0000FF">void</font> f() {
&nbsp; <font color="#0000FF">static</font> Obj b('b');
}

<font color="#0000FF">void</font> g() {
&nbsp; <font color="#0000FF">static</font> Obj c('c');
}

<font color="#0000FF">int</font> main() {
&nbsp; out &lt;&lt; <font color="#004488">"dentro il main()"</font> &lt;&lt; endl;
&nbsp; f(); <font color="#009900">// Chiama il costruttore statico per b
</font>&nbsp; <font color="#009900">// g() non chiamata
</font>&nbsp; out &lt;&lt; <font color="#004488">"all'uscita del main()"</font> &lt;&lt; endl;
} <font color="#009900">///:~</font></pre></FONT>
</blockquote>
<font face="Georgia">In <b>Obj</b> la variabile <b>char c</b> funge da
identificatore, in modo tale che il costruttore e il distruttore possono
stampare informazioni riguardo all'oggetto su cui stanno agendo. La variabile
<b>Obj
a</b> è un oggetto globale, per cui il suo costruttore viene sempre chiamato
prima di entrare nel <b>main()</b>, ma i costruttori di <b>static Obj b</b>
dentro <b>f()</b> e di <b>static Obj c</b> dentro <b>g()</b> vengono eseguiti
solo se queste funzioni vengono chiamate. Per
dimostrare quali costruttori e distruttori vengono eseguiti, è stata chiamata
solo la funzione <b>f()</b>. L'output del programma è</font>  
<blockquote><font size=+1>
<pre><font face="Georgia">Obj::Obj() <font color="#0000FF">per</font> a
dentro il main()
Obj::Obj() <font color="#0000FF">per</font> b
all'uscita del main()
Obj::~Obj() <font color="#0000FF">per</font> b
Obj::~Obj() <font color="#0000FF">per</font> a</font></pre></font>
</blockquote>
<font face="Georgia">Il costruttore per <b>a</b> viene chiamato prima di
entrare nel <b>main()</b>, mentre il costruttore per <b>b</b> viene chiamato
solo perchè viene chiamata la funzione <b>f()</b>. Quando si esce dal
<b>main()</b>,
i distruttori degli oggetti per i quali è stato eseguito il costruttore
vengono eseguiti nell'ordine inverso rispetto alla costruzione. Questo
significa che se viene chiamata anche <b>g()</b>, l'ordine di distruzione
di <b>b</b> e <b>c</b> dipende dall'ordine di chiamata di <b>f()</b> e
<b>g()</b>. Notare che anche l'oggetto <b>out</b>, di tipo <b>ofstream</b>, è statico, in
quanto definito all'esterno di qualsiasi funzione, e vive nell'area di
memoria statica. E' importante che la sua definizione (al contrario di
una dichiarazione <b>extern</b>) appaia all'inizio del file, prima che
<b>out</b>
possa essere usata. Altrimenti si potrebbe usare un oggetto prima che questo
venga opportunamente inizializzato. In
C++ il costruttore di un oggetto statico globale viene chiamato prima di
entrare nel <b>main()</b>, cosicchè abbiamo un modo molto semplice e portabile
per eseguire del codice prima di entrare nel <b>main()</b> e di eseguire
codice con il distruttore all'uscita dal <b>main()</b>. In C questo richiede
di mettere le mani al codice di start-up in linguaggio assembler, fornito
insieme al compilatore.</font> 
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Il controllo del linkage<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">Ordinariamente, qualsiasi nome con scope a livello
di file (cioè non annidato all'interno di una classe o di una funzione)
è visibile attraverso tutte le unità di compilazione in un programma.
Questo spesso è chiamato <i>linkage esterno</i>, in quanto durante il
link il nome è visibile al linker dovunque, esternamente a tale unità
di compilazione. Le variabili globali e le funzioni ordinarie hanno questo
tipo di linkage. Ci
sono casi in cui si vuole limitare la visibilità di un nome. Si potrebbe
volere che una variabile sia visibile a livello di file, in modo che tutte
le funzioni definite in quel file possano accedervi, ma si vuole impedire
l'accesso alle funzioni al di fuori del file o evitare una collisione di
nomi con identificatori definiti in altri file.</font>  

<p style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><span 
lang=IT style='mso-ansi-language:IT'><font face="Georgia">Un nome di oggetto o 
  di funzione con visibilità a livello di file esplicitamente dichiarata con <b>static</b> 
  è locale alla sua unità di compilazione (nell'accezione di questo libro vuol 
  dire il file .<b>cpp</b> dove avviene la dichiarazione). Questo nome ha un&nbsp;</font></span><font face="Georgia"><span 
lang=IT style='font-family:Georgia;mso-ansi-language:IT'><i>linkage</i></span><i><span 
lang=IT style='mso-ansi-language:IT'> interno</span><span lang=IT
style='mso-ansi-language:IT'></span></i><span lang=IT
style='mso-ansi-language:IT'>. Questo significa che si puo' usare lo stesso nome 
  in altre unità di compilazione senza creare conflitto. Un vantaggio del linkage 
  interno è il fatto che i nomi possono essere piazzati in un file di intestazione 
  senza temere conflitti durante il link. I nomi che vengono comunemente messi 
  nei file di intestazione, come le definizioni <b>const</b> e le funzioni <b>inline</b>, 
  hanno per default un linkage interno (tuttavia, <b>const</b> ha un linkage interno 
  solo in C++, mentre per il C il default è esterno). Notare, inoltre, che il 
  concetto di linkage si applica solo a quegli elementi per i quali l'indirizzo 
  viene calcolato a tempo di link o di load; ad esempio alle dichiarazioni di 
  classi e alle variabili locali non si applica il concetto di linkage.</span></font>
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><span lang=IT style='font-size:13.5pt;font-family:Verdana;mso-ansi-language:
IT'> <font face="Verdana, Arial, Helvetica, sans-serif">Confusione<o:p></o:p></font><o:p></o:p></span></h4>
<p><font face="Georgia, Times New Roman, Times, serif">Qui c'è un esempio di come 
  le due accezioni del termine ><b>static</b> possano intrecciarsi l'un l'altra. 
  Tutti gli oggetti globali hanno implicitamente una classe di memorizzazione 
  statica, così, se scriviamo (a livello di file), </font> </p>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">int</font> a = 0;</font></pre></font>
</blockquote>

<div style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><span 
lang=IT style='mso-ansi-language:IT'><font face="Georgia">l'allocazione
di <b>a</b> avviene nell'area dati statica del programma, e l'inizializzazione
di <b>a</b> avviene una sola volta, prima di entrare nel <b>main()</b>.
In più, la visibilità di <b>a</b> è globale rispetto a tutte le unità
di compilazione. In termini di visibilità l'opposto di <b>static</b> (visibile
solo in questa unità di compilazione) è <b>extern</b>, che asserisce
esplicitamente che la visibiltà è trasversale a tutte le unità di compilazione.
Percio' la definizione precedente è equivalente alla seguente:</font><o:p></o:p></span></div>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">extern</font> <font color="#0000FF">int</font> a = 0;</font></pre></font>
</blockquote>
<font face="Georgia">Ma se scriviamo,</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">static</font> <font color="#0000FF">int</font> a = 0;</font></pre></font>
</blockquote>
<font face="Georgia">tutto quello che abbiamo fatto è di alterare la visibilità
di <b>a</b>, così da conferirle un linkage interno. La classe di memorizzazione
non è cambiata, in quanto gli oggetti risiedono
nell'area dati statica sia che la visibilità sia <b>static</b> che <b>extern</b>. Quando
passiamo alle variabili locali, la parola <b>static</b> non agisce più
sulla visibilità, che è già limitata, ma altera la classe di memorizzazione. Se
dichiariamo come <b>extern</b> una variabile che altrimenti sarebbe locale,
significa che questa è già stata definita da qualche parte (quindi la
variabile è di fatto globale alla funzione). Per esempio:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:LocaleExtern.cpp
//{L} LocaleExtern2
</font>#include &lt;iostream>

<font color="#0000FF">int</font> main() {
&nbsp; <font color="#0000FF">extern</font> <font color="#0000FF">int</font> i;
&nbsp; std::cout &lt;&lt; i;
} <font color="#009900">///:~

//: C10:LocaleExtern2.cpp {O}
</font><font color="#0000FF">int</font> i = 5;
<font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Con i nomi di funzione (non funzioni membro di classi)
<b>static</b>
ed <b>extern</b> possono alterare solo la visibilità, così la dichiarazione</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">extern</font> <font color="#0000FF">void</font> f();</font></pre></font>
</blockquote>
<font face="Georgia">è equivalente a</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">void</font> f();</font></pre></font>
</blockquote>
<font face="Georgia">e la dichiarazione</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">static</font> <font color="#0000FF">void</font> f();</font></pre></font>
</blockquote>
<font face="Georgia">significa che <b>f()</b> è visibile solo all'interno
di questa unità di compilazione - detta a volte <i>file statico</i>.</font>  
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Altri specificatori di 
  classi di memorizzazione<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">Gli specificatori <b>static</b> ed <b>extern</b> si
usano abitualmente. Ma ci sono altri due specificatori di classi di memorizzazione
che si vedono meno frequentemente. Lo specificatore <b>auto</b> non è
quasi mai usato, in quanto esso istruisce il compilatore che una variabile
è locale. <b>auto</b>, infatti, è una forma abbreviata che sta per "automatic"
e si riferisce al modo in cui il compilatore automaticamente alloca memoria
per una variabile. Il compilatore è sempre in grado di determinare questo
fatto dal contesto, per cui l'uso di <b>auto</b> è ridontante. L'altro
specificatore è <b>register</b>. Una variabile <b>register</b> è di tipo
locale (<b>auto</b>). Con <b>register </b>si
avvisa il compilatore che questa variabile potrebbe essere usata pesantemente
e che quindi se puo' la deve memorizzare in un registro. In questo senso
è un aiuto all'ottimizzazione. Compilatori diversi rispondono in maniera
differente a questo suggerimento; essi hanno anche la possibilità di ignorarlo.
Se ad esempio si prende l'indirizzo di una variabile, lo specificatore
<b>register</b>
è del tutto inutile e quindi quasi certamente viene ignorato. Si dovrebbe
evitare l'uso eccessivo di <b>register</b>, in quanto è probabile che
il compilatore effettui l'ottimizzazione meglio di noi.</font>
<h2 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Spazio dei nomi (namespaces)<o:p></o:p></font><o:p></o:p></span></h2>
<font face="Georgia">Anche se i nomi possono essere annidati all'interno
di classi, i nomi di funzioni globali, di variabili globali e di classi
sono comunque in un unico spazio di nomi. La parola chiave <b>static</b>
ci permette un certo controllo su questo, permettendoci di conferire alle
variabili e alle funzioni un linkage interno (cioè rendendoli file statici).
Ma in un progetto vasto, la perdita di controllo sullo spazio dei nomi
globale puo' causare problemi. Per risolvere questo problema per le classi,
spesso i fornitori creano lunghi nomi complicati che difficilmente possono
confliggere, ma ci costringono poi a digitare questi nomi (Si puo' usare
<b>typedef</b>
per semplificarli). Non è una soluzione elegante, supportata dal linguaggio. Possiamo
suddividere lo spazio dei nomi globale in tanti pezzi più maneggevoli,
usando una caratteristica propria del C++, ottenuta con la parola chiave
<i>namespace</i>.
La parola chiave <b>namespace</b>, come <b>class</b>,
<b>struct</b>, <b>enum</b>
ed <b>union</b>, pone i nomi dei suoi membri in uno spazio distinto.</font> 
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Creazione di uno spazio 
  dei nomi<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">La creazione di uno spazio dei nomi è simile a quella
di una <b>class</b>:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:MiaLib.cpp
</font><font color="#0000FF">namespace</font> MiaLib {
&nbsp; <font color="#009900">// Dichiarazioni
</font>}
<font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Questa definizione crea un nuovo spazio dei nomi che
contiene le dichiarazioni racchiuse tra parentesi. Ma ci sono differenze
significative rispetto a <b>class</b>, <b>struct</b>,
<b>union</b> ed <b>enum:</b></font>  
<ul type=disc>
<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Una
definizione namespace puo' apparire solo a livello globale o nidificata
in un altro namespace.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Non
è necessario il punto e virgola dopo le parentesi che racchiudono la definizione.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">La
definizione di un namespace puo' continuare attraverso file di intestazione
multipli, usando una sintassi che per le classi provocherebbe delle ridefinizioni:</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>
</ul>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Header1.h
</font>#ifndef HEADER1_H
#define HEADER1_H
<font color="#0000FF">namespace</font> MiaLib {
&nbsp; <font color="#0000FF">extern</font> <font color="#0000FF">int</font> x;
&nbsp; <font color="#0000FF">void</font> f();
&nbsp; <font color="#009900">// ...
</font>}</font></pre></font>
</blockquote>

<blockquote><font size=+1>
<pre><font face="Georgia">#endif <font color="#009900">// HEADER1_H ///:~
//: C10:Header2.h
</font>#ifndef HEADER2_H
#define HEADER2_H
#include <font color="#004488">"Header1.h"
</font><font color="#009900">// Aggiungere più nomi a MiaLib
</font><font color="#0000FF">namespace</font> MiaLib { <font color="#009900">// NON è una ridefinizione!
</font>&nbsp; <font color="#0000FF">extern</font> <font color="#0000FF">int</font> y;
&nbsp; <font color="#0000FF">void</font> g();
&nbsp; <font color="#009900">// ...
</font>}</font></pre></font>
</blockquote>

<blockquote><font size=+1>
<pre><font face="Georgia">#endif <font color="#009900">// HEADER2_H ///:~
//: C10:Continuazione.cpp
</font>#include <font color="#004488">"Header2.h"
</font><font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>

<ul type=disc>
<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo9;tab-stops:list .5in">
<span lang=IT
     style='mso-ansi-language:IT'><font face="Georgia">Un
nome di namespace puo' essere sostituito con uno <i>pseudonimo</i>, così
non siamo costretti a digitare un ingombrante nome creato da un fornitore
di librerie.</font><o:p></o:p></span></li>
</ul>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:BobsSuperDuperLibreria.cpp
</font><font color="#0000FF">namespace</font> BobsSuperDuperLibreria {
&nbsp; <font color="#0000FF">class</font> Widget { <font color="#009900">/* ... */</font> };
&nbsp; <font color="#0000FF">class</font> Poppit { <font color="#009900">/* ... */</font> };
&nbsp; <font color="#009900">// ...
</font>}
<font color="#009900">// Troppo lungo da digitare! Usiamo un alias (pseudonimo):
</font><font color="#0000FF">namespace</font> Bob = BobsSuperDuperLibreria;
<font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>

<ul type=disc>
<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l4 level1 lfo12;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Non
si possono creare istanze di un namespace come per una classe.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>
</ul>

<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Namespace senza nome<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Ogni unità di compilazione contiene un <i>namespace</i>
senza nome che si puo' aggiungere utilizzando la parola chiave "<b>namespace</b>"
senza identificatore:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:NamespaceSenzaNome.cpp
</font><font color="#0000FF">namespace</font> {
&nbsp; <font color="#0000FF">class</font> Braccio { <font color="#009900">/* ... */</font> };
&nbsp; <font color="#0000FF">class</font> Gamba   { <font color="#009900">/* ... */</font> };
&nbsp; <font color="#0000FF">class</font> Testa   { <font color="#009900">/* ... */</font> };
&nbsp; <font color="#0000FF">class</font> Robot   {
&nbsp;&nbsp;&nbsp; Braccio braccio[4];
&nbsp;&nbsp;&nbsp; Gamba   gamba[16];
&nbsp;&nbsp;&nbsp; Testa   testa[3];
&nbsp;&nbsp;&nbsp; <font color="#009900">// ...
</font>&nbsp; } xanthan;
&nbsp; <font color="#0000FF">int</font> i, j, k;
}
<font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">I nomi in questo spazio sono automaticamente disponibili
in questa unità di compilazione senza qualificazione. E' garantito che
uno spazio senza nome è unico per ogni unità di compilazione. Ponendo
nomi locali in namespace senza nome si evita la necessità di usare la
parola <b>static</b> per conferirgli un linkage interno. Il
C++ depreca l'uso dei file statici a favore dei namespace senza nome.</font>
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Friends<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Si puo' <i>iniettare</i> una dichiarazione <b>friend</b>
in un namespace inserendola dentro una classe:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:IniezioneFriend.cpp
</font><font color="#0000FF">namespace</font> Me {
&nbsp; <font color="#0000FF">class</font> Noi {
&nbsp;&nbsp;&nbsp; <font color="#009900">//...
</font>&nbsp;&nbsp;&nbsp; <font color="#0000FF">friend</font> <font color="#0000FF">void</font> tu();
&nbsp; };
}&nbsp;
<font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">In questo modo la funzione <b>tu()</b> è un membro
del namespace <b>Me</b>. Se
si introduce un <b>friend</b> all'interno di una classe in un <i>namespace</i>
globale, il <b>friend</b> viene inserito globalmente.</font>  
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Usare uno spazio dei nomi<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">Ci si puo' riferire ad un nome all'interno di un namespace
in tre modi: specificando il nome
usando l'operatore di risoluzione di scope, con una direttiva <b>using
</b>per
introdurre tutti i nomi nel namespace, oppure una dichiarazione
<b>using
</b>per
introdurre nomi uno alla volta.</font>  
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Risoluzione di scope<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Ogni nome in un namespace puo' essere esplicitamente
specificato usando l'operatore di risoluzione di scope allo stesso modo
in cui ci si puo' riferire ad un nome all'interno di una classe:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:RisoluzioneDiScope.cpp
</font><font color="#0000FF">namespace</font> X {
&nbsp; <font color="#0000FF">class</font> Y {
&nbsp;&nbsp;&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> i;
&nbsp; <font color="#0000FF">public</font>:
&nbsp;&nbsp;&nbsp; <font color="#0000FF">void</font> f();
&nbsp; };
&nbsp; <font color="#0000FF">class</font> Z;
&nbsp; <font color="#0000FF">void</font> funz();
}
<font color="#0000FF">int</font> X::Y::i = 9;</font></pre></font>
</blockquote>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">class</font> X::Z {
&nbsp; <font color="#0000FF">int</font> u, v, w;
<font color="#0000FF">public</font>:
&nbsp; Z(<font color="#0000FF">int</font> i);
&nbsp; <font color="#0000FF">int</font> g();
};</font></pre></font>
</blockquote>

<blockquote><font size=+1>
<pre><font face="Georgia">X::Z::Z(<font color="#0000FF">int</font> i) { u = v = w = i; }
<font color="#0000FF">int</font> X::Z::g() { <font color="#0000FF">return</font> u = v = w = 0; }</font></pre></font>
</blockquote>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">void</font> X::funz() {
&nbsp; X::Z a(1);
&nbsp; a.g();
}
<font color="#0000FF">int</font> main(){} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Notare che la definizione
<b>X::Y::i</b>
potrebbe essere tranquillamente riferita a un dato membro della classe
<b>Y</b>
annidata nella classe <b>X</b> invece che nel namespace
<b>X</b>. Quindi,
i namespace si presentano molto simili alle classi.</font> 
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">La direttiva using<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Siccome digitare l'intero qualificatore per un nome
in un namespace potrebbe presto diventare tedioso, la parola chiave <b>using</b>
ci permette di importare un intero namespace in un colpo solo. Quando questa
viene usata insieme alla parola chiave <b>namespace</b> si ottiene quella
che si chiama <i>direttiva using </i>. La direttiva <b>using</b> fa si
che i nomi appaiano come se appartenessero al namespace più vicino che
la racchiude, cosicchè possiamo usare convenientemente nomi senza qualificatori.
Consideriamo un semplice namespace:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:NamespaceInt.h
</font>#ifndef NAMESPACEINT_H
#define NAMESPACEINT_H
<font color="#0000FF">namespace</font> Int {
&nbsp; <font color="#0000FF">enum</font> segno { positivo, negativo };
&nbsp; <font color="#0000FF">class</font> Intero {
&nbsp;&nbsp;&nbsp; <font color="#0000FF">int</font> i;
&nbsp;&nbsp;&nbsp; segno s;
&nbsp; <font color="#0000FF">public</font>:
&nbsp;&nbsp;&nbsp; Intero(<font color="#0000FF">int</font> ii = 0)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : i(ii),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s(i >= 0 ? positivo : negativo)
&nbsp;&nbsp;&nbsp; {}
&nbsp;&nbsp;&nbsp; segno getSegno() <font color="#0000FF">const</font> { <font color="#0000FF">return</font> s; }
&nbsp;&nbsp;&nbsp; <font color="#0000FF">void</font> setSegno(segno sgn) { s = sgn; }
&nbsp;&nbsp;&nbsp; <font color="#009900">// ...
</font>&nbsp; };
}&nbsp;
#endif <font color="#009900">// NAMESPACEINT_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Un uso della direttiva
<b>using </b>è quello di includere
tutti i nomi definiti in <b>Int</b> dentro un altro namespace, lasciando
che questi nomi siano annidati dentro questo secondo namespace:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:NamespaceMat.h
</font>#ifndef NAMESPACEMAT_H
#define NAMESPACEMAT_H
#include <font color="#004488">"NamespaceInt.h"
</font><font color="#0000FF">namespace</font> Mat {
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> Int;
&nbsp; Intero a, b;
&nbsp; Intero divide(Intero, Intero);
&nbsp; <font color="#009900">// ...
</font>}&nbsp;
#endif <font color="#009900">// NAMESPACEMAT_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Si possono anche includere tutti i nomi definiti in
<b>Int</b>
dentro una funzione, ma in questo modo i nomi sono annidati nella funzione:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Aritmetica.cpp
</font>#include <font color="#004488">"NamespaceInt.h"
</font><font color="#0000FF">void</font> aritmetica() {
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> Int;
&nbsp; Intero x;
&nbsp; x.setSegno(positivo);
}
<font color="#0000FF">int</font> main(){} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Senza la direttiva <b>using</b>, tutti i nomi di un
namespace hanno bisogno di essere completamente qualificati. Un
aspetto della direttiva <b>using</b> potrebbe sembrare controintuitiva
all'inizio. La visibilità dei nomi introdotti con una direttiva <b>using</b>
corrisponde allo scope in cui la direttiva è posizionata. Ma si possono
nascondere i nomi provenienti da una direttiva <b>using</b>, come
se fossero dichiarati a livello globale!</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:SovrapposizioneNamespace1.cpp
</font>#include <font color="#004488">"NamespaceMat.h"
</font><font color="#0000FF">int</font> main() {
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> Mat;
&nbsp; Intero a; <font color="#009900">// Nasconde Mat::a;
</font>&nbsp; a.setSegno(negativo);
&nbsp; <font color="#009900">// Adesso è necessaria la risoluzione di scope
</font>&nbsp; <font color="#009900">// per selezionare Mat::a :
</font>&nbsp; Mat::a.setSegno(positivo);
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Supponiamo di avere un secondo namespace che contiene
alcuni dei nomi definiti nel <b>namespace Mat</b>:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:SovrapposizioneNamespace2.h
</font>#ifndef SOVRAPPOSIZIONENAMESPACE2_H
#define SOVRAPPOSIZIONENAMESPACE2_H
#include <font color="#004488">"NamespaceInt.h"
</font><font color="#0000FF">namespace</font> Calcolo {
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> Int;
&nbsp; Intero divide(Intero, Intero);
&nbsp; <font color="#009900">// ...
</font>}&nbsp;
#endif <font color="#009900">// SOVRAPPOSIZIONENAMESPACE2_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Siccome con la direttiva <b>using</b> viene
introdotto anche questo namespace, c'è la possibilità di una collisione.
Tuttavia l'ambiguità si presenta soltanto nel punto in cui si <i>usa</i>
il nome e non a livello di direttiva <b>using</b>:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:AmbiguitaDaSovrapposizione.cpp
</font>#include <font color="#004488">"NamespaceMat.h"
</font>#include <font color="#004488">"SovrapposizioneNamespace2.h"
</font><font color="#0000FF">void</font> s() {
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> Mat;
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> Calcolo;
&nbsp; <font color="#009900">// Tutto ok finchè:
</font>&nbsp; <font color="#009900">//! divide(1, 2); // Ambiguità
</font>}
<font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Così, è possibile scrivere direttive <b>using</b>
per introdurre tanti namaspace con nomi che confliggono senza provocare
mai ambiguità.</font>
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">La dichiarazione using<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Si possono inserire uno alla volta dei nomi dentro
lo scope corrente con una <i>dichiarazione using</i>. A differenza della
direttiva <b>using</b>, che tratta i nomi come se fossero dichiarati a
livello globale, una dichiarazione <b>using</b> è una dichiarazione interna
allo scope corrente. Questo significa che puo' sovrapporre nomi provenienti
da una direttiva <b>using</b>:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:DichiarazioniUsing.h
</font>#ifndef DICHIARAZIONIUSING_H
#define DICHIARAZIONIUSING_H
<font color="#0000FF">namespace</font> U {
&nbsp; <font color="#0000FF">inline</font> <font color="#0000FF">void</font> f() {}
&nbsp; <font color="#0000FF">inline</font> <font color="#0000FF">void</font> g() {}
}
<font color="#0000FF">namespace</font> V {
&nbsp; <font color="#0000FF">inline</font> <font color="#0000FF">void</font> f() {}
&nbsp; <font color="#0000FF">inline</font> <font color="#0000FF">void</font> g() {}
}&nbsp;
#endif <font color="#009900">// DICHIARAZIONIUSING_H ///:~</font></font></pre></font>
</blockquote>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:DichiarazioneUsing1.cpp
</font>#include <font color="#004488">"DichiarazioniUsing.h"
</font><font color="#0000FF">void</font> h() {
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> U; <font color="#009900">// Direttiva using
</font>&nbsp; <font color="#0000FF">using</font> V::f; <font color="#009900">// Dichiarazione using
</font>&nbsp; f(); <font color="#009900">// Chiama V::f();
</font>&nbsp; U::f(); <font color="#009900">// Bisogna qualificarla completamente per chiamarla
</font>}
<font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">La dichiarazione <b>using</b> fornisce il nome di
un identificatore completamente specificato, ma non da informazioni sul
suo tipo. Questo vuol dire che se il namespace contiene un set di funzioni
sovraccaricate con lo stesso nome, la dichiarazione <b>using</b> dichiara
tutte le funzioni del set sovraccaricato. Si puo' mettere una dichiarazione
<b>using</b>
dovunque è possibile mettere una normale dichiarazione. Una dichiarazione
<b>using</b>
agisce come una normale dichiarazione eccetto per un aspetto: siccome non
gli forniamo una lista di argomenti, è possibile che la dichiarazione
<b>using</b>
causi un sovraccaricamento di funzioni con lo stesso tipo di argomenti
(cosa che non è permessa con un normale sovraccaricamento). Questa ambiguità,
tuttavia, non si evidenzia nel momento della dichiarazione, bensì nel
momento dell'uso. Una
dichiarazione <b>using</b> puo' apparire anche all'interno di un namespace,
e ha lo stesso effetto della dichiarazione dei nomi all'interno del namespace:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:DichiarazioneUsing2.cpp
</font>#include <font color="#004488">"DichiarazioniUsing.h"
</font><font color="#0000FF">namespace</font> Q {
&nbsp; <font color="#0000FF">using</font> U::f;
&nbsp; <font color="#0000FF">using</font> V::g;
&nbsp; <font color="#009900">// ...
</font>}
<font color="#0000FF">void</font> m() {
&nbsp; <font color="#0000FF">using</font> <font color="#0000FF">namespace</font> Q;
&nbsp; f(); <font color="#009900">// Chiama U::f();
</font>&nbsp; g(); <font color="#009900">// Chiama V::g();
</font>}
<font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Una dichiarazione <b>using</b> è un alias, e permette
di dichiarare le stesse funzioni in namespace diversi. Se si finisce per
ridichiarare la stessa funzione importando namespace diversi, va bene,
non ci saranno ambiguità o duplicazioni.</font>
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">L' uso dei namespace<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">Alcune delle regole di sopra possono sembrare scoraggianti
all'inizio, specialmente se si pensa di doverle usare continuamente.
In generale, invece, si puo' fare un uso molto semplice dei namespace,
una volta capito come funzionano. Il concetto chiave da ricordare è che
introducendo una direttiva <b>using</b> globale (attraverso una "<b>using
namespace</b>" esterna a qualsiasi scope) si apre il namespace per il file
in cui è inserita. Questo in generale va bene per i file di implementazione
(un file "<b>cpp</b>") perchè la direttiva <b>using</b> ha effetto solo
fino alla fine della compilazione del file. Cioè non ha effetto su nessun
altro file, percio' si puo' effettuare il controllo dei namespace un file
di implementazione alla volta. Ad esempio, se si scopre un conflitto di
nomi a causa dell'uso di diverse direttive <b>using</b> in un particolare
file di implementazione, è semplice modificare quel file in modo che usi
qualificazioni esplicite o dichiarazioni <b>using</b> per eliminare il
conflitto, senza modificare altri file di implementazione.</font> 

<p style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt">&nbsp;
<span lang=IT style='font-family:Georgia;
mso-ansi-language:IT'><font face="Georgia">Per
gli header file le cose sono diverse. Non si dovrebbe mai introdurre una
direttiva <b>using</b> all'interno di un header file, perchè questo significherebbe
che tutti i file che lo includono si ritrovano il namespace aperto (e un
header file puo' includere altri header file).</font>
<p style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt">&nbsp;
<span lang=IT style='font-family:Georgia;mso-ansi-language:
IT'><font face="Georgia">Così,
negli header file si potrebbero usare sia qualificazioni esplicite o direttive
<b>using</b>
a risoluzione di scope che dichiarazioni <b>using</b>. Questa è la pratica
che si usa in questo libro e seguendola non si rischia di "inquinare" il
namespace globale e cadere nel mondo C++ precedente all'introduzione dei
namespace.</font>
<h2 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Membri Statici in C++<o:p></o:p></font><o:p></o:p></span></h2>
<font face="Georgia">A volte si presenta la necessità per tutti i membri
di una classe di usare un singolo blocco di memoria. In C si puo' usare
una variabile globale, ma questo non è molto sicuro. I dati globali possono
essere modificati da chiunque, e i loro nomi possono collidere con altri
nomi identici in un progetto grande. L'ideale sarebbe che il dato venisse
allocato come se fosse globale, ma fosse nascosto all'interno di una classe
e chiaramente associato a tale classe. Questo
è ottenuto con dati membro <b>static</b> all'interno di una classe. C'è
un singolo blocco di memoria per un dato membro <b>static</b>, a prescindere
da quanti oggetti di quella classe vengono creati. Tutti gli oggetti condividono
lo stesso spazio di memorizzione <b>static</b> per quel dato membro, percio'
questo è un modo per loro di "comunicare" l'un l'altro. Ma il dato <b>static</b>
appartiene alla classe; il suo nome è visibile solo all'interno della
classe e puo' essere <b>public</b>,
<b>private</b>, o <b>protected</b>.</font> 
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Definire lo spazio di memoria 
  per i dati membri statici</font><o:p></o:p></span></h3>
<font face="Georgia">Siccome i dati membri <b>static</b> hanno un solo
spazio di memoria a prescindere da
quanti oggetti sono stati creati, questo spazio di memoria deve essere
definito in un solo punto. Il compilatore non alloca memoria. Il linker
riporta un errore se un dato membro <b>static</b> viene dichiarato ma non
definito. La
definizione deve essere fatta al di fuori della classe (non sono permesse
definizioni inline), ed è permessa solo una definizione. Percio' è usuale
mettere la definizione nel file di implementazione della classe. La sintassi
a volte crea dubbi, ma in effetti è molto logica. Per esempio, se si crea
un dato membro statico dentro una classe, come questo:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">class</font> A {
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> i;
<font color="#0000FF">public</font>:
&nbsp; <font color="#009900">//...
</font>};</font></pre></font>
</blockquote>
<font face="Georgia">Bisogna definire spazio di memoria per questo dato
membro statico nel file di definizione, così:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">int</font> A::i = 1;</font></pre></font>
</blockquote>
<font face="Georgia">Se vogliamo definire una variabile globale ordinaria,
dobbiamo scrivere:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">int</font> i = 1;</font></pre></font>
</blockquote>
<font face="Georgia">ma qui per specificare
<b>A::i</b> vengono usati l'operatore
di risoluzione di scope e il nome della classe. Alcuni
provano dubbi all'idea che <b>A::i</b> sia <b>private</b> e che qui c'è
qualcosa che sembra manipolarlo portandolo allo scoperto. Non è che questo
rompe il meccanismo di protezione? E' una pratica completamente sicura
per due motivi. Primo, l'unico posto in cui l'inizializzazione è legale
è nella definizione. In effetti se il dato <b>static</b> fosse stato un
oggetto con un costruttore, avremmo potuto chiamare il costruttore invece
di usare l'operatore <b>=</b> (uguale). Secondo, una volta che la definizione
è stata effettuata, l'utente finale non puo' effettuarne una seconda, il
linker riporterebbe un errore. E il creatore della classe è forzato a
creare una definizione, altrimenti il codice non si linka durante il test.
Questo assicura che la definizione avvenga una sola volta ed è gestita
dal creatore della classe.</font></span><font face="Georgia"> L'intera
espressione di inizializzazione per un membro statico ricade nello scope
della classe. Per esempio,</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Statinit.cpp
// Scope di inizializzatore static
</font>#include &lt;iostream>
<font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;

<font color="#0000FF">int</font> x = 100;

<font color="#0000FF">class</font> ConStatic {
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> x;
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> y;
<font color="#0000FF">public</font>:
&nbsp; <font color="#0000FF">void</font> print() <font color="#0000FF">const</font> {
&nbsp;&nbsp;&nbsp; cout &lt;&lt; <font color="#004488">"ConStatic::x = "</font> &lt;&lt; x &lt;&lt; endl;
&nbsp;&nbsp;&nbsp; cout &lt;&lt; <font color="#004488">"ConStatic::y = "</font> &lt;&lt; y &lt;&lt; endl;
&nbsp; }
};

<font color="#0000FF">int</font> ConStatic::x = 1;
<font color="#0000FF">int</font> ConStatic::y = x + 1;
<font color="#009900">// ConStatic::x NON ::x

</font><font color="#0000FF">int</font> main() {
&nbsp; ConStatic cs;
&nbsp; cs.print();
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Qui la qualificazione <b>ConStatic::</b> estende
lo scope di <b>ConStatic</b> all'intera definizione.</font> 
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Inizializzazione di array 
  static<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Il capitolo 8 ha introdotto la variabile <b>static
const</b> che permette di definire un valore costante all'interno del corpo
di una classe. E' anche possibile creare array di oggetti <b>static</b>,
sia <b>const</b> che non-<b>const</b>. La sintassi è ragionevolmente consistente:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:ArrayStatico.cpp
// Inizializzazione di array statici nelle classi
</font><font color="#0000FF">class</font> Valori {
&nbsp; <font color="#009900">// static consts vengono inizializzati sul posto:
</font>&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> <font color="#0000FF">int</font> scSize = 100;
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> <font color="#0000FF">long</font> scLong = 100;
&nbsp; <font color="#009900">// Il conteggio automatico funziona con gli array statici.
</font>&nbsp; <font color="#009900">// Gli Array statici, sia non-integrali che non-const,
</font>&nbsp; <font color="#009900">// vanno inizializzati esternamente:
</font>&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> <font color="#0000FF">int</font> scInteri[];
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> <font color="#0000FF">long</font> scLongs[];
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> <font color="#0000FF">float</font> scTabella[];
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> <font color="#0000FF">char</font> scLettere[];
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> size;
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> <font color="#0000FF">float</font> scFloat;
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">float</font> tabella[];
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">char</font> lettere[];
};

<font color="#0000FF">int</font> Valori::size = 100;
<font color="#0000FF">const</font> <font color="#0000FF">float</font> Valori::scFloat = 1.1;

<font color="#0000FF">const</font> <font color="#0000FF">int</font> Valori::scInteri[] = {
&nbsp; 99, 47, 33, 11, 7
};

<font color="#0000FF">const</font> <font color="#0000FF">long</font> Valori::scLongs[] = {
&nbsp; 99, 47, 33, 11, 7
};

<font color="#0000FF">const</font> <font color="#0000FF">float</font> Valori::scTabella[] = {
&nbsp; 1.1, 2.2, 3.3, 4.4
};

<font color="#0000FF">const</font> <font color="#0000FF">char</font> Valori::scLettere[] = {
&nbsp; 'a', 'b', 'c', 'd', 'e',
&nbsp; 'f', 'g', 'h', 'i', 'j'
};

<font color="#0000FF">float</font> Valori::tabella[4] = {
&nbsp; 1.1, 2.2, 3.3, 4.4
};

<font color="#0000FF">char</font> Valori::lettere[10] = {
&nbsp; 'a', 'b', 'c', 'd', 'e',
&nbsp; 'f', 'g', 'h', 'i', 'j'
};

<font color="#0000FF">int</font> main() { Valori v; } <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Con <b>static const</b>s di tipi integrali si possono
fornire definizioni all'interno della classe, ma per qualsiasi altra cosa
(incluso array di tipi integrali, anche se sono <b>static const</b>) bisogna
fornire un'unica definizione esterna per il membro. Queste definizioni
hanno un linkage interno, cosicchè essi possono essere messi negli header
file. La sintassi per inizializzare gli array statici è la stessa di qualunque
altro aggregato, incluso il conteggio automatico.</font></span><font face="Georgia"> Si
possono creare anche oggetti <b>static
const</b> di tipi di classi e array di questi oggetti. Tuttavia non si
possono inizializzare con la "sintassi
inline" permessa per i tipi integrali <b>static</b> <b>const</b>s predefiniti.</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:ArrayDiOggettiStatici.cpp
// Array static di oggetti di classi
</font><font color="#0000FF">class</font> X {
&nbsp; <font color="#0000FF">int</font> i;
<font color="#0000FF">public</font>:
&nbsp; X(<font color="#0000FF">int</font> ii) : i(ii) {}
};

<font color="#0000FF">class</font> Stat {
&nbsp; <font color="#009900">// Questo non funziona:
//!&nbsp; static const X x(100);
</font>&nbsp; <font color="#009900">// Gli oggetti di classi statiche, sia const che non-const,
</font>&nbsp; <font color="#009900">// vanno inizializzati esternamente:
</font>&nbsp; <font color="#0000FF">static</font> X x2;
&nbsp; <font color="#0000FF">static</font> X xTabella2[];
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> X x3;
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">const</font> X xTabella3[];
};

X Stat::x2(100);

X Stat::xTabella2[] = {
&nbsp; X(1), X(2), X(3), X(4)
};

<font color="#0000FF">const</font> X Stat::x3(100);

<font color="#0000FF">const</font> X Stat::xTabella3[] = {
&nbsp; X(1), X(2), X(3), X(4)
};

<font color="#0000FF">int</font> main() { Stat v; } <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">L'inizializzazione di array di oggetti di classi sia
<b>const</b>
che non-<b>const</b> <b>static</b> deve essere effettuata allo stesso modo,
seguendo la tipica sintassi della definizione <b>static</b>.</font>  
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Classi nidificate e locali<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">Si possono facilmente mettere membri dati statici
dentro classi nidificate all'interno di altre classi. La definizione di
tali membri è un'estensione ovvia ed intuitiva - semplicemente si usa
un altro livello di risoluzione di scope. Tuttavia non si possono avere
dati membri <b>static</b> dentro classi locali (una classe locale è una
classe definita dentro una funzione). Così,</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Locale.cpp
// Membri statici &amp; classi locali
</font>#include &lt;iostream>
<font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;

<font color="#009900">// Classi nidificate POSSONO avere dati membri statici:
</font><font color="#0000FF">class</font> Esterna {
&nbsp; <font color="#0000FF">class</font> Interna {
&nbsp;&nbsp;&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> i; <font color="#009900">// OK
</font>&nbsp; };
};

<font color="#0000FF">int</font> Esterna::Interna::i = 47;

<font color="#009900">// Classi Locali NON possono avere dati membri statici:
</font><font color="#0000FF">void</font> f() {
&nbsp; <font color="#0000FF">class</font> Locale {
&nbsp; <font color="#0000FF">public</font>:
<font color="#009900">//! static int i;&nbsp; // Errore
</font>&nbsp;&nbsp;&nbsp; <font color="#009900">// (Come si potrebbe definire i?)
</font>&nbsp; } x;
}&nbsp;

<font color="#0000FF">int</font> main() { Esterna x; f(); } <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Si puo' notare subito un problema con i membri <b>static</b>
in una classe locale: Come descrivere un dato membro a livello di file
allo scopo di definirlo? Nella pratica le classi locali sono usate raramente.</font>  
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">funzioni membro static<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">Si possono creare anche funzioni membro <b>static</b> che, 
come i dati membro <b>static</b>, funzionano per la classe nel suo insieme, piuttosto 
che per un particolare oggetto della classe. Invece di costruire una funzione 
globale che vive e "inquina" il namespace globale e locale, si pone la funzione 
dentro la classe. Quando si crea una funzione membro <b>static</b> si esprime 
un'associazione con una classe particolare.</font><font face="Georgia"> Si puo' 
chiamare una funzione membro <b>static</b> nel modo ordinario, con il punto o 
la freccia, in associazione con un oggetto. Tuttavia è più usuale chiamare una 
funzione membro <b>static</b> da sola, senza nessun oggetto specifico, utilizzando 
l'operatore di risoluzione di scope, come nell'esempio seguente:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:FunzioneSempliceMembroStatico.cpp&nbsp;
</font><font color="#0000FF">class</font> X {
<font color="#0000FF">public</font>:
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">void</font> f(){};
};

<font color="#0000FF">int</font> main() {
&nbsp; X::f();
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Quando si vedono funzioni membro statiche in una classe,
bisogna ricordarsi che il progettista aveva in mente che la funzione fosse
concettualmente associata alla classe nella sua interezza. Una
funzione membro <b>static</b> non puo' accedere ai dati membro ordinari,
ma solo i membri <b>static</b>. Puo' chiamare solo altre funzioni membro
<b>static</b>.
Normalmente, quando una funzione membro viene chiamata le viene tacitamente
passato l'indirizzo dell'oggetto corrente (<b>this</b>), ma un membro <b>static</b>
non ha un puntatore <b>this</b>, e questa è la ragione per cui una funzione
membro <b>static</b> non puo' chiamare i membri ordinari. Si ottiene anche
un leggero aumento nella velocità di esecuzione, come per le funzioni
globali, per il fatto che le funzioni membro <b>static</b> non hanno l'extra
overhead di passare il parametro
<b>this</b>. Nello stesso tempo si sfrutta
il beneficio di avere la funzione dentro la classe. Per
i dati membro, <b>static</b> indica che esiste un solo spazio di memoria
per i dati membri per tutti gli oggetti di una classe. Questo parallelizza
l'uso di <b>static</b> per definire
oggetti <i>dentro</i> una funzione, per indicare che viene usata una sola
copia di una variabile locale per tutte le chiamate alla funzione. Qui
c'è un esempio che mostra membri dati <b>static</b> e funzioni membro
<b>static</b>
usati insieme:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:FunzioniMembroStatiche.cpp
</font><font color="#0000FF">class</font> X {
&nbsp; <font color="#0000FF">int</font> i;
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> j;
<font color="#0000FF">public</font>:
&nbsp; X(<font color="#0000FF">int</font> ii = 0) : i(ii) {
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#009900">// Funzioni membro non-static possono accedere a
</font>&nbsp;&nbsp;&nbsp;&nbsp; <font color="#009900">// funzioni membro o dati statici:
</font>&nbsp;&nbsp;&nbsp; j = i;
&nbsp; }
&nbsp; <font color="#0000FF">int</font> val() <font color="#0000FF">const</font> { <font color="#0000FF">return</font> i; }
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> incr() {
&nbsp;&nbsp;&nbsp; <font color="#009900">//! i++; // Errore: le funzioni membro statiche
</font>&nbsp;&nbsp;&nbsp; <font color="#009900">// non possono accedere ai dati membro non-static
</font>&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> ++j;
&nbsp; }
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> f() {
&nbsp;&nbsp;&nbsp; <font color="#009900">//! val(); // Errore: le funzioni membro static
</font>&nbsp;&nbsp;&nbsp; <font color="#009900">// non possono accedere alle funzioni membro non-static
</font>&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> incr(); <font color="#009900">// OK -- chiama una funzione static
</font>&nbsp; }
};

<font color="#0000FF">int</font> X::j = 0;

<font color="#0000FF">int</font> main() {
&nbsp; X x;
&nbsp; X* xp = &amp;x;
&nbsp; x.f();
&nbsp; xp->f();
&nbsp; X::f(); <font color="#009900">// Funziona solo con membri static
</font>} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Per il fatto di non disporre del puntatore <b>this</b>,
le funzioni membro <b>static</b> nè possono accedere ai dati membri non-<b>static</b>
nè possono chiamare funzioni membro non-<b>static</b>. Notare
in <b>main( )</b> che un membro <b>static</b> puo' essere selezionato utilizzando
l'usuale sintassi con il punto o con la freccia, associando la funzione
con un oggetto, ma anche senza nessun oggetto (perchè un membro <b>static</b>
è associato alla classe e non ad un particolare oggetto), usando il nome
della classe e l'operatore di risoluzione di scope. Qui
c'è un'importante caratteristica: a causa del modo in cui avviene l'inizializzazione
di un oggetto membro <b>static</b>, si puo' mettere un dato membro <b>static</b>
della stessa classe <i>all'interno</i> della classe. Qui c'è un esempio
che permette ad un solo oggetto di tipo <b>Uovo</b> di esistere rendendo
il costruttore private. Si puo' accedere all'oggetto, ma non si puo' creare
un nuovo oggetto di tipo <b>Uovo</b>:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:UnicoEsemplare.cpp
// Membri statici di un qualche tipo, assicurano che
// esiste solo un oggetto di questo tipo.
// Viene detto anche "unico" esemplare ("singleton" pattern).
</font>#include &lt;iostream>
<font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;

<font color="#0000FF">class</font> Uovo {
&nbsp; <font color="#0000FF">static</font> Uovo u;
&nbsp; <font color="#0000FF">int</font> i;
&nbsp; Uovo(<font color="#0000FF">int</font> ii) : i(ii) {}
&nbsp; Uovo(<font color="#0000FF">const</font> Uovo&amp;); <font color="#009900">// Previene la&nbsp; copy-costruzione
</font><font color="#0000FF">public</font>:
&nbsp; <font color="#0000FF">static</font> Uovo* istanza() { <font color="#0000FF">return</font> &amp;u; }
&nbsp; <font color="#0000FF">int</font> val() <font color="#0000FF">const</font> { <font color="#0000FF">return</font> i; }
};

Uovo Uovo::u(47);

<font color="#0000FF">int</font> main() {
<font color="#009900">//!&nbsp; Uovo x(1); // Errore -- non puo' creare un Uovo
</font>&nbsp; <font color="#009900">// Si puo' accedere alla singola istanza:
</font>&nbsp; cout &lt;&lt; Uovo::istanza()->val() &lt;&lt; endl;
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">L'inizializzazione di <b>u</b> avviene dopo che è
stata completata la dichiarazione della classe, così il compilatore ha
tutte le informazioni di cui ha bisogno per allocare memoria ed effettuare
la chiamata al costruttore. Per
prevenire del tutto la creazione di un qualsiasi altro oggetto, è stato
aggiundo qualcos'altro: un secondo costruttore private, detto <i>copy-constructor
(costruttore di copia)</i>. A questo punto del libro non possiamo sapere perchè
questo è necessario, perchè il costruttore di copia sarà introdotto nel
prossimo capitolo. Tuttavia, come piccola anticipazione, se rimuoviamo
il costruttore di copia definito nell'esempio precedente, potremmo creare
un oggetto Uovo come questo:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia">Uovo u = *Uovo::istanza();
Uovo u2(*Uovo::istanza());</font></pre></font>
</blockquote>
<font face="Georgia">Entrambe le istruzioni di sopra usano il costruttore di copia,
così per escludere questa possibilità il costruttore di copia è dichiarato
come private (nessuna definizione è necessaria, perchè esso non sarà
mai chiamato). Una larga parte del prossimo capitolo è dedicata al costruttore di copia
e così sarà molto più chiaro.</font> 
<h2 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Dipendenza dall' inizializzazione 
  di oggetti statici<o:p></o:p></font><o:p></o:p></span></h2>
<font face="Georgia">All'interno di un'unità di compilazione l'ordine
di inizializzazione di oggetti statici è garantito essere uguale all'ordine
in cui le definizioni degli oggetti appaiono nel file. L'ordine di distruzione
è garantito essere l'inverso di quello di inizializzazione.  Tuttavia
non c'è nessuna garanzia nell'ordine di inizializzazione di oggetti statici
<i>trasversalmente</i>
alle unità di compilazione, e il linguaggio non fornisce nessun modo per
specificare tale ordine. Questo puo' causare problemi significativi. Come
esempio disastroso (che potrebbe causare l'interruzione del sistema operativo
e la morte dei processi), se un file contiene</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Out.cpp {O}
// Primo file
</font>#include &lt;fstream>
std::ofstream out(<font color="#004488">"out.txt"</font>);<u> <font color="#009900">///:~</font></u></font></pre></font>
</blockquote>
<font face="Georgia">e un altro file usa l'oggetto
<b>out</b> in uno dei
suoi inizializzatori</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Oof.cpp
// Secondo file
//{L} Out
</font>#include &lt;fstream>
<font color="#0000FF">extern</font> std::ofstream out;
<font color="#0000FF">class</font> Oof {
<font color="#0000FF">public</font>:
&nbsp; Oof() { std::out &lt;&lt; <font color="#004488">"ahi"</font>; }
} oof;</font></pre></font>
</blockquote>

<blockquote><font size=+1>
<pre><u><font face="Georgia"><font color="#0000FF">int</font> main() {} <font color="#009900">///:~</font></font></u></pre></font>
</blockquote>
<font face="Georgia">il programma potrebbe funzionare, ma potrebbe anche non funzionare. 
Se l'ambiente di programmazione costruisce il programma in modo che il primo file 
viene inizializzato prima del secondo, non ci sarà nessun problema. Tuttavia se 
il secondo file viene inizializzato prima del primo file, il costruttore di <b>Oof</b> 
fa affidamento sull'esistenza di <b>out</b>, il quale pero' non è stato ancora 
costruito e questo provoca un caos. Questo problema succede soltanto con gli inizializzatori 
di oggetti statici che dipendono l'un l'altro. Gli oggetti statici in un'unità 
di compilazione vengono inizializzati prima che venga invocata qualsiasi funzione 
in tale unità - ma potrebbe essere dopo il <b>main( )</b>. Non si puo' essere 
sicuri dell'ordine di inizializzazione di oggetti statici che risiedono su file 
diversi. Un esempio subdolo puo' essere trovato in ARM.</font><font face="Georgia"><a href="#fn47"><span lang=IT style='mso-ansi-language:
IT'>[47]</span><span lang=IT style='font-family:Georgia;mso-ansi-language:
IT'></span></a><span lang=IT style='font-family:Georgia;mso-ansi-language:
IT'> In un file si ha, a livello globale:</span></font><span lang=IT style='font-family:Georgia;mso-ansi-language:
IT'> 
<p style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt">&nbsp;
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">extern</font> <font color="#0000FF">int</font> y;
<font color="#0000FF">int</font> x = y + 1;</font></pre></font>
</blockquote>
<font face="Georgia">e in un secondo file si ha, sempre a livello globale:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">extern</font> <font color="#0000FF">int</font> x;
<font color="#0000FF">int</font> y = x + 1;</font></pre></font>
</blockquote>
<font face="Georgia">Per tutti gli oggetti statici, il meccanismo di linking-loading
garantisce l'inizializzazione a zero prima che abbia luogo l'inizializzazione
dinamica del programmatore. Nell'esempio precedente, l'azzeramento della
memoria occupata dall'oggetto <b>fstream out</b> non ha un significato particolare,
percio' essa è semplicemente indefinita fino a quando non viene chiamato
il costruttore. Tuttavia, per i tipi predefiniti l'inizializzazione a zero
ha sempre senso e se i file sono inizializzazti nell'ordine mostrato sopra,
<b>y</b>
ha valore iniziale zero e così <b>x</b> diventa uno e <b>y</b> diventa
dinamicamente due. Ma se i file vengono inizializzati nell'ordine inverso,
<b>x</b>
viene staticamente inizializzato a zero, <b>y</b> viene dinamicamente inizializzato
a uno e quindi <b>x</b> diventa due. I
programmatori devono essere consapevoli di questo, altrimenti potrebbero
creare un programma con dipendenze da inizializzazioni statiche che possono
funzionare su una piattaforma, ma spostandoli su un'altra piattaforma potrebbero
misteriosamente non funzionare.</font> 
<h3 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Cosa fare<o:p></o:p></font><o:p></o:p></span></h3>
<font face="Georgia">Ci sono tre approcci per gestire questo problema:</font>  
<ol start=1 type=1>
<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo15;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Non
farlo. Evitare le dipendenze da inizializzazione statica è la soluzione
migliore.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo15;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Se
bisogna farlo, è bene mettere le definizioni critiche di oggetti statici
in un solo file, così da controllare la loro inizializzazione in modo
portabile, mettendoli nell'ordine giusto.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo15;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Se
si è convinti che è inevitabile sparpagliare oggetti statici in varie
unità di compilazione - come nel caso di una libreria, dove non si puo'
controllare l'uso che il programmatore ne fa - ci sono due tecniche di
programmazine per risolvere il problema.</font>  </span></li>
</span></ol><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Tecnica numero uno<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Questa tecnica è stata introdotta da Jerry Schwarz
mentre creava la libreria iostream (giacchè
le definizioni di <b>cin</b>,
<b>cout</b> e <b>cerr</b> sono <b>static
</b>e
vivono in file separati). Questa è attualmente meno usata della seconda,
ma è stata usata per molto tempo e ci si potrebbe imbattere in codice
che la usa; percio' è importante capire come funziona. Questa
tecnica richiede una classe addizionale nell'header file della libreria.
Questa classe è responsabile dell'inizializzazione dinamica degli oggetti
statici della libreria. Questo è un semplice esempio:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Inizializzatore.h
// Tecnica di inizializzazione di oggetti static
</font>#ifndef INIZIALIZZATORE_H
#define INIZIALIZZATORE_H
#include &lt;iostream>
<font color="#0000FF">extern</font> <font color="#0000FF">int</font> x; <font color="#009900">// Dichiarazioni, non definizioni
</font><font color="#0000FF">extern</font> <font color="#0000FF">int</font> y;

<font color="#0000FF">class</font> Inizializzatore {
&nbsp; <font color="#0000FF">static</font> <font color="#0000FF">int</font> initCount;
<font color="#0000FF">public</font>:
&nbsp; Inizializzatore() {
&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <font color="#004488">"Inizializzatore()"</font> &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp; <font color="#009900">// Inizializza solo la prima volta
</font>&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font>(initCount++ == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <font color="#004488">"effettua l'inizializzazione"
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 100;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 200;
&nbsp;&nbsp;&nbsp; }
&nbsp; }
&nbsp; ~Inizializzatore() {
&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <font color="#004488">"~Inizializzatore()"</font> &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp; <font color="#009900">// Cancella solo l'ultima volta
</font>&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font>(--initCount == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <font color="#004488">"effettua la cancellazione"</font>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#009900">// Qualsiasi altra pulizia qui
</font>&nbsp;&nbsp;&nbsp; }
&nbsp; }
};

<font color="#009900">// L'istruzione seguente crea un oggetto in ciascun file
// in cui Inizializzatore.h viene incluso, ma questo oggetto è visibile solo in questo file:
</font><font color="#0000FF">static</font> Inizializzatore init;
#endif <font color="#009900">// INIZIALIZZATORE_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Le dichiarazioni di <b>x</b> e <b>y</b> annunciano
solo che questi oggetti esistono, ma non allocano memoria per essi. Tuttavia,
la definizione di <b>Inizializzatore
init</b> alloca memoria per questo oggetto in tutti i file in cui l'header file è incluso. Ma siccome il nome è <b>static</b> (che controlla la
visibilità, non il modo in cui viene allocata la memoria; la memorizzazione
è a livello di file per default), esso è visibile solo all'interno dell'unità
di compilazione e il linker non si "arrabbia" per questa definizione multipla. Qui
c'è il file per le definizioni di <b>x</b>, <b>y</b>, e <b>initCount</b>:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:DefinInizializzatore.cpp {O}
// Definizioni per Inizializzatore.h
</font>#include <font color="#004488">"Inizializzatore.h"
</font><font color="#009900">// L'inizializzazione Static forza
// tutti questi valori a zero:
</font><font color="#0000FF">int</font> x;
<font color="#0000FF">int</font> y;
<font color="#0000FF">int</font> Inizializzatore::initCount;
<font color="#009900">///:~</font></font></pre></font>
</blockquote>

<div style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><span 
style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT><font face="Georgia">(Naturalmente,
un'istanza di <b>init</b> viene posta anche in questo file quando l'header
viene incluso.) Supponiamo che l'utente della libreria crei altri due file:</font></span></span></div><span 
style='font-family:Georgia;mso-ansi-language:IT'>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Inizializzatore.cpp {O}
// Inizializzazione Static
</font>#include <font color="#004488">"Inizializzatore.h"
</font><font color="#009900">///:~</font></font></pre></font>
</blockquote>

<div style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><span 
style='font-family:Georgia'><font face="Georgia">e</font></span></div>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Inizializzatore2.cpp
//{L} DefinInizializzatore
// Inizializzazione Static
</font>#include <font color="#004488">"Inizializzatore.h"
</font><font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;

<font color="#0000FF">int</font> main() {
&nbsp; cout &lt;&lt; <font color="#004488">"dentro il main()"</font> &lt;&lt; endl;
&nbsp; cout &lt;&lt; <font color="#004488">"all'uscita del main()"</font> &lt;&lt; endl;
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Adesso non ha importanza quale unità di compilazione
viene inizializzata per prima. La prima volta che una unità di compilazione
contenente <b>Inizializzatore.h </b>viene inizializzata, <b>initCount</b> sarà
posto a zero e così l'inizializzazione sarà effettuata (questo dipende
pesantemente dal fatto che l'area di memoria statica viene inizializzata
a zero prima che qualsiasi inizializzazione dinamica abbia luogo). Per
tutte le altre unità di compilazione, <b>initCount </b>sarà diverso da
zero e l'inizializzazione viene saltata. La cancellazione avviene nell'ordine
inverso e <b>~Inizializzatore( )</b>
assicura che cio' avvenga una volta sola. Questo
esempio ha usato tipi predefiniti come oggetti statici globali. La tecnica
funziona anche con le classi, ma questi oggetti devono essere inizializzati
dinamicamente dalla classe <b>Inizializzatore</b>. Un modo per fare questo
è di creare classi senza costruttori e distruttori, ma con funzioni membro
per l'inizializzazione e la cancellazione che usano nomi diversi. Un approccio
più comune, comunque, è quello di avere puntatori ad oggetti e di crearli
usando <b>new</b> dentro <b>Inizializzatore( )</b>.</font> 
<h4 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Tecnica numero due<o:p></o:p></font><o:p></o:p></span></h4>
<font face="Georgia">Dopo tanto tempo che era in uso la prima tecnica,
qualcuno (non so chi), ha introdotto la tecnica presentata in questa sezione,
che è molto più semplice e chiara della prima. Il fatto che c'è voluto
tanto tempo per scoprirla è il tributo da pagare alla complessità del
C++. La
tecnica si basa sul fatto che gli oggetti statici all'interno delle funzioni
vengono inizializzati (soltanto) la prima volta che la funzione viene chiamata.
Bisogna ricordare che il problema che stiamo cercando di risolvere non
è <i>quando</i> gli oggetti statici
vengono inizializzati (cosa che possiamo controllare separatamente), ma
piuttosto assicurare che l'inizializzazione avvenga nell'ordine appropriato. Questa
tecnica è molto pulita e intelligente. Per ogni oggetto che ha una dipendenza
dall'inizializzazione, poniamo un oggetto statico all'interno della funzione
che restituisce un riferimento a quell'oggetto. Così, l'unico modo che
abbiamo per accedere all'oggetto statico è chiamare la funzione, e se
quest'oggetto ha la necessità di accedere ad altri oggetti statici da
cui esso dipende, deve chiamare le <i>loro</i>
funzioni. E la prima volta che la funzione viene chiamata, forza l'inizializzazione.
La correttezza dell'ordine di inizializzazione statica è garantita dal
modo in cui viene costruito il codice e non da un ordine arbitrario stabilito
dal linker. Per fare un esempio, qui ci sono due classi che dipendono l'una
dall'altra. La prima contiene un <b>bool
</b>che è inizializzato soltanto
dal costruttore, così possiamo verificare se il costruttore è stato chiamato
per un'istanza statica della classe (l'area di memorizzazione statica viene
inizializzata a zero allo startup del programma, il che da luogo ad un
valore <b>false</b> per un <b>bool</b> se il costruttore non è stato chiamato):</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Dipendenza1.h
</font>#ifndef DIPENDENZA1_H
#define DIPENDENZA1_H
#include &lt;iostream>

<font color="#0000FF">class</font> Dipendenza1 {
&nbsp; <font color="#0000FF">bool</font> init;
<font color="#0000FF">public</font>:
&nbsp; Dipendenza1() : init(<font color="#0000FF">true</font>) {
&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <font color="#004488">"Costruzione di Dipendenza1"</font>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl;
&nbsp; }
&nbsp; <font color="#0000FF">void</font> print() <font color="#0000FF">const</font> {
&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <font color="#004488">"Init di Dipendenza1: "</font>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; init &lt;&lt; std::endl;
&nbsp; }
};
#endif <font color="#009900">// DIPENDENZA1_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Il costruttore, inoltre, si annuncia quando viene
chiamato e quindi possiamo stampare, con <b>print( )</b>, lo stato dell'oggetto
per scoprire se è stato inizializzato. La
seconda classe viene inizializzata da un oggetto della prima classe, che
è quello che causa la dipendenza:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Dipendenza2.h
</font>#ifndef DIPENDENZA2_H
#define DIPENDENZA2_H
#include <font color="#004488">"Dipendenza1.h"

</font><font color="#0000FF">class</font> Dipendenza2 {
&nbsp; Dipendenza1 d1;
<font color="#0000FF">public</font>:
&nbsp; Dipendenza2(<font color="#0000FF">const</font> Dipendenza1&amp; dip1): d1(dip1){
&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; <font color="#004488">"Costruzione di Dipendenza2"</font>;
&nbsp;&nbsp;&nbsp; print();
&nbsp; }
&nbsp; <font color="#0000FF">void</font> print() <font color="#0000FF">const</font> { d1.print(); }
};
#endif <font color="#009900">// DIPENDENZA2_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Il costruttore annuncia se stesso e stampa lo stato
dell'oggetto <b>d1</b> cosicchè possiamo vedere se è stato inizializzato
nel momento in cui il costruttore viene chiamato. Per
dimostrare cosa puo' andare storto, il file seguente pone dapprima le definizioni
degli oggetti statici nell'ordine sbagliato, come potrebbe succedere se
il linker inizializzasse dapprima
l'oggetto <b>Dipendenza2</b> rispetto all'oggetto <b>Dipendenza1</b>. Successivamente
l'ordine di definizione viene invertito per mostrare come funziona correttamente
se l'ordine di inizializzazione è "giusto." Per ultimo, viene dimostrata
la tecnica numero due.  Per
fornire un output più leggibile, viene creata la funzione <b>separatore(
)</b>. Il trucco è quello di non permettere di chiamare una funzione globalmente
a meno che la funzione non è usata per effettuare l'inizializzazione di
una variabile, così la funzione <b>separatore( )</b> restituisce un valore
fittizio che viene usato per inizializzare una coppia di variabili globali.</font>
<div style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><p>&nbsp;</p><span 
lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></div>

<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Tecnica2.cpp
</font>#include <font color="#004488">"Dipendenza2.h"
</font><font color="#0000FF">using</font> <font color="#0000FF">namespace</font> std;

<font color="#009900">// Restituisce un valore cosicchè puo' essere chiamata
// come inizializzatore globale:
</font><font color="#0000FF">int</font> separatore() {
&nbsp; cout &lt;&lt; <font color="#004488">"---------------------"</font> &lt;&lt; endl;
&nbsp; <font color="#0000FF">return</font> 1;
}

<font color="#009900">// Simula il problema della dipendenza:
</font><font color="#0000FF">extern</font> Dipendenza1 dip1;
Dipendenza2 dip2(dip1);
Dipendenza1 dip1;
<font color="#0000FF">int</font> x1 = separatore();

<font color="#009900">// Ma se avviene in questo ordine funziona correttamente:
</font>Dipendenza1 dip1b;
Dipendenza dip2b(dip1b);
<font color="#0000FF">int</font> x2 = separatore();

<font color="#009900">// Seguono oggetti static inglobati all'interno di funzioni
</font>Dipendenza1&amp; d1() {
&nbsp; <font color="#0000FF">static</font> Dipendenza1 dip1;
&nbsp; <font color="#0000FF">return</font> dip1;
}

Dipendenza2&amp; d2() {
&nbsp; <font color="#0000FF">static</font> Dipendenza2 dip2(d1());
&nbsp; <font color="#0000FF">return</font> dip2;
}

<font color="#0000FF">int</font> main() {
&nbsp; Dipendenza2&amp; dip2 = d2();
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Le funzioni <b>d1( )</b> e <b>d2( )</b> inglobano
istance statiche degli oggetti <b>Dipendenza1</b> e <b>Dipendenza2</b>.
A questo punto, l'unico modo che abbiamo per ottenere gli oggetti statici
è quello di chiamare le funzioni e quindi forzare l'inizializzazione degli
oggetti statici alla prima chiamata delle funzioni. Questo significa che
l'inizializzazione è garantita essere corretta, come si puo' vedere facendo
girare il programma e osservando l'output. Qui è mostrato come organizzare
effettivamente il codice per usare la tecnica esposta. Ordinariamente gli
oggetti statici dovrebbero essere definiti in file separati (perchè si
è costretti per qualche motivo; ma va ricordato che la definizione degli
oggetti in file separati è cio' che causa il problema), qui invece definiamo
le funzioni contenitrici in file separati. Ma è necessario definirle in
header file:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Dipendenza1StatFun.h
</font>#ifndef DIPENDENZA1STATFUN_H
#define DIPENDENZA1STATFUN_H
#include <font color="#004488">"Dipendenza1.h"
</font><font color="#0000FF">extern</font> Dipendenza1&amp; d1();
#endif <font color="#009900">// DIPENDENZA1STATFUN_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">In realtà lo specificatore "extern" è ridondante
per la dichiarazione di una funzione. Qui c'è il secondo header file:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Dipendenza2StatFun.h
</font>#ifndef DIPENDENZA2STATFUN_H
#define DIPENDENZA2STATFUN_H
#include <font color="#004488">"Dipendenza2.h"
</font><font color="#0000FF">extern</font> Dipendenza2&amp; d2();
#endif <font color="#009900">// DIPENDENZA2STATFUN_H ///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">A questo punto, nei file di implementazione dove prima
avremmo messo la definizione degli oggetti statici, mettiamo la definizione
delle funzioni contenitrici:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Dipendenza1StatFun.cpp {O}
</font>#include <font color="#004488">"Dipendenza1StatFun.h"
</font>Dipendenza1&amp; d1() {
&nbsp; <font color="#0000FF">static</font> Dipendenza1 dip1;
&nbsp; <font color="#0000FF">return</font> dip1;
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Presumibilmente andrebbe messo altro codice in questo
file. Segue l'altro file:</font> 
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Dipendenza2StatFun.cpp {O}
</font>#include <font color="#004488">"Dipendenza1StatFun.h"
</font>#include <font color="#004488">"Dipendenza2StatFun.h"
</font>Dipendenza2&amp; d2() {
&nbsp; <font color="#0000FF">static</font> Dipendenza2 dip2(d1());
&nbsp; <font color="#0000FF">return</font> dip2;
} <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Così adesso ci sono due file che potrebbero essere
linkati in qualsiasi ordine e se contenessero oggetti statici ordinari
potrebbero dar luogo ad un ordine di inizializzazione qualsiasi. Ma siccome
essi contengono funzioni che fanno da contenitore, non c'è nessun pericolo
di inizializzazione errata:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#009900">//: C10:Tecnica2b.cpp
//{L} Dipendenza1StatFun Dipendenza2StatFun
</font>#include <font color="#004488">"Dipendenza2StatFun.h"
</font><font color="#0000FF">int</font> main() { d2(); } <font color="#009900">///:~</font></font></pre></font>
</blockquote>
<font face="Georgia">Quando facciamo girare questo programma possiamo vedere
che l'inizializzazione dell'oggetto statico <b>Dipendenza1</b> avviene
sempre prima dell'inizializzazione dell'oggetto statico <b>Dipendenza2</b>.
Possiamo anche notare che questo approccio è molto più semplice della
tecnica numero uno.  Si
puo' essere tentati di scrivere <b>d1( )</b> e <b>d2( )</b> come funzioni
inline dentro i rispettivi header file, ma questa è una cosa che dobbiamo
evitare. Una funzione inline puo' essere duplicata in tutti i file in cui
appare- e la duplicazione <i>include</i> la definizione dell' oggetto statico.
Siccome le funzioni inline hanno per default un linkage interno, questo
puo' significare avere oggetti statici multipli attraverso le varie unità
di compilazione, che potrebbe sicuramente creare problemi. Percio' dobbiamo
assicurare che ci sia una sola definizione di ciascuna funzione contenitrice,
e questo significa non costruire tali funzioni inline.</font> 
<h2 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Specificazione di linkage 
  alternativi<o:p></o:p></font><o:p></o:p></span></h2>
<font face="Georgia">Cosa succede se stiamo scrivendo un programma in C++
e vogliamo usare una libreria C? Se prendiamo la dichiarazione di funzione
C,</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">float</font> f(<font color="#0000FF">int</font> a, <font color="#0000FF">char</font> b);</font></pre></font>
</blockquote>
<font face="Georgia">il compilatore C++ decorerà questo nome con qualcosa
tipo <b>_f_int_char</b> per supportare l' overloading di funzioni (e il
linkage tipo-sicuro). Tuttavia il compilatore C che ha compilato la libreria
certamente non ha decorato il nome della funzione, così il suo nome interno
sarà <b>_f</b>. Percio' il linker non sarà in grado di risolvere in C++
la chiamata a <b>f( )</b>. La scappatoia fornita dal C++ è la <i>specificazione
di linkage alternativo</i>, che si ottiene con l'overloading della parola
chiave <b>extern</b>. La parola <b>extern</b> viene fatta seguire da una
stringa che specifica il linkage che si vuole per la dichiarazione, seguita
dalla dichiarazione stessa:</font>
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">extern</font> <font color="#004488">"C"</font> <font color="#0000FF">float</font> f(<font color="#0000FF">int</font> a, <font color="#0000FF">char</font> b);</font></pre></font>
</blockquote>
<font face="Georgia">Questo dice al compilatore di conferire un linkage
tipo C ad <b>f( )</b> così il compilatore non decora il nome. Gli unici
due tipi di specificazioni di linkage supportati dallo standard sono&nbsp;<b>"C"</b>
e <b>"C++,"</b> ma i fornitori di compilatori hanno l'opzione di supportare
altri linguaggi allo stesso modo. Se
si ha un gruppo di dichiarazioni con linkage alternativi, bisogna metterle
tra parentesi graffe, come queste:</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">extern</font> <font color="#004488">"C"</font> {
&nbsp; <font color="#0000FF">float</font> f(<font color="#0000FF">int</font> a, <font color="#0000FF">char</font> b);
&nbsp; <font color="#0000FF">double</font> d(<font color="#0000FF">int</font> a, <font color="#0000FF">char</font> b);
}</font></pre></font>
</blockquote>
<font face="Georgia">Oppure, per un header file,</font>  
<blockquote><font size=+1>
<pre><font face="Georgia"><font color="#0000FF">extern</font> <font color="#004488">"C"</font> {
#include <font color="#004488">"Mioheader.h"
</font>}</font></pre></font>
</blockquote>
<font face="Georgia">Molti fornitori di compilatori C++ gestiscono le specificazioni
di linkage alternativi all'interno dei loro header file che funzionano
sia con il C che con il C++, in modo che non ci dobbiamo preoccupare al
riguardo.</font> 
<h2 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Sommario<o:p></o:p></font><o:p></o:p></span></h2>
<font face="Georgia">La parola chiave <b>static</b> puo' generare confusione,
in quanto in alcune situazioni controlla la posizione in memoria, mentre
in altre controlla la visibilità e il linkage dei nomi. Con
l'introduzione dei namespaces, caratteristica propria del C++, abbiamo
un'alternativa migliore e molto più flessibile per controllare la proliferazione
dei nomi in progetti grandi. L'uso di <b>static</b> all'interno delle classi
è un modo ulteriore di controllare i nomi in un programma. I nomi (all'interno
delle classi) non confliggono con quelli globali e la visibilità e l'accesso
sono tenuti dentro i confini del programma, fornendo maggior controllo
nella manutenzione del codice.</font>
<h2 style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"> 
  <span lang=IT style='font-family:Verdana;mso-ansi-language:
IT'><font face="Verdana, Arial, Helvetica, sans-serif">Esercizi<o:p></o:p></font><o:p></o:p></span></h2>

<div style="tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt"><span 
lang=IT style='font-size:10.0pt;font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Le
soluzioni agli esercizi selezionati possono essere trovate nel documento
elettronico <i>The Thinking in C++ Annotated Solution Guide</i>, disponibile
in cambio di un piccolo onorario su www.BruceEckel.com.</font></span></div><span 
lang=IT style='font-size:10.0pt;font-family:Georgia;mso-ansi-language:IT'>

<ol start=1 type=1>
<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una funzione con una variabile statica che è un puntatore (con un argomento
di default a zero). Quando il chiamante fornisce un valore per questo argomento,
questo viene usato per puntare all'inizio di un array di <b>int</b>.
Se la funzione viene chiamata senza argomenti (usando l'argomento di default),
la funzione restituisce il valore successivo nell'array, fino a quando
non incontra il valore "-1" nell'array (che agisce come indicatore di fine
array). Utilizzare questa funzione nel <b>main( )</b>.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una funzione che restituisce il valore successivo in una sequenza di Fibonacci,
ogni volta che viene chiamata. Aggiungere un argomento che è un <b>bool</b>
con valore di default a <b>false</b> cosicchè quando si passa l'argomento
con valore <b>true</b> esso "resetta" la funzione al valore iniziale della
sequenza di Fibonacci. Utilizzare questa funzione nel <b>main( )</b>.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una classe che memorizza un array di <b>int</b>s. Settare la dimensione
dell'array usando <b>static const int</b> all'interno della classe. Aggiungere
una variabile <b>const</b> <b>int</b> e inizializzarla dentro la lista
di inizializzazione del costruttore; rendere il costruttore <b>inline</b>.
Aggiungere una variabile <b>static</b> <b>int</b> e inizializzarla ad un
valore specifico. Aggiungere una funzione membro <b>static</b> che stampa
il dato membro <b>static</b>. Aggiungere una funzione membro <b>inline</b>
chiamata <b>print( )</b> per stampare tutti I valori nell'array e chiamare
tutte le funzioni membro <b>static</b>. Utilizzare questa classe nel <b>main(
)</b>.</font></span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una classe chiamata <b>Monitor </b>che tiene traccia del numero di volte
che la funzione membro <b>incident( )</b> è stata chiamata. Aggiungere
una funzione membro <b>print( )</b> che mostra il numero di chiamate ad
incident(). Ora creare una funzione globale (non membro) che contiene un
oggetto di tipo <b>static</b> <b>Monitor</b>. Ogni volta che viene chiamata,
questa funzione deve chiamare <u><b>incident( )</b>,<b> </b></u>e poi la
funzione membro <b>print( )</b> per stampare il contatore incident. Utilizzare
questa funzione nel <b>main( )</b>.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Modificare
la classe <b>Monitor</b> dell'Esercizio 4 in modo che si possa decrementare,
con <b>decrement( ),</b> il contatore incident. Costruire una classe <b>Monitor2</b>
che accetta come argomento del suo costruttore un puntatore alla classe
e che memorizza il puntatore e chiama le funzioni <b>incident(
)</b> e <b>print( )</b>. Nel distruttore di <b>Monitor2</b> chiamare <b>decrement(
)</b> e <b>print( )</b>. Adesso creare un oggetto <b>static<span style="mso-spacerun: yes"></span></b><span style="mso-spacerun: yes">&nbsp;</span>di
tipo <b>Monitor2</b> dentro la funzione. All'interno del <b>main( )</b>,
vedere cosa succede con il distruttore di <b>Monitor2 </b>se si chiama
oppure non si chiama la funzione.</font></span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
un oggetto globale di tipo <b>Monitor2</b> e vedere cosa succede.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una classe con un distruttore che stampa un messaggio e poi chiama <b>exit(
)</b>. Creare un oggetto globale di questa classe e vedere cosa succede.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">In
<b>DistruttoriStatici.cpp</b>,
fare delle prove con l'ordine di chiamata del costruttore<span 
     style="mso-spacerun: yes">&nbsp;</span>e
del distruttore, con le chiamate alle funzioni <b>f( )</b> e <b>g( )</b>
dentro il <b>main( )</b> in ordini diversi. Come si comporta il vostro
compilatore, li chiama nell'orrdine corretto (il costruttore e il distruttore,
s'intende)?</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">In
<b>DistruttoriStatici.cpp</b>,
testare la gestione di default degli errori del vostro ambiente, cambiando
la definizione originale di <b>out</b>
in una dichiarazione <b>extern</b> e mettendo l'attuale definizione dopo
quella di <b>a</b> (il cui costruttore <b>Obj</b> invia informazioni ad
<b>out</b>).
Assicurarsi che non ci sia nient'altro di importante che gira sulla vostra
macchina mentre gira il vostro programma o che la vostra macchina sappia
gestire in maniera robusta gli errori.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Provare
che le variabili di tipo "file static" (cioè statiche ma visibili solo
al livello di file) definite in file di intestazione non collidono l'una
con l'altra se incluse in più file <b>cpp</b>.</font></span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una semplice classe contenente un <b>int</b>, un construttore che inizializza
l'<b>int</b> con il suo argomento, una funzione membro che setta l'<b>int</b>
con il suo argomento, e una funzione <b>print( )</b> che stampa <b>int</b>.
Mettere la classe in un header file e includere il file in due file <b>cpp</b>.
In un file <b>cpp</b> creare un'istanza della classe, e nell'altro dichiarare
questo identificatore come <b>extern</b> e testare il tutto nel <b>main(
)</b>. Ricordate che i due file oggetto devono essere linkati o altrimenti
il linker non trova gli oggetti.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Porre
l'istanza dell'oggetto nell'Esercizio 11 come <b>static</b> e verificare
che esso non puo' essere trovato dal linker.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Dichiarare
una funzione in un header file. Definire la funzione in un file <b>cpp</b>
e chiamarla nel <b>main( )</b> in un secondo file <b>cpp</b>. Compilare
e verificare che funziona. Adesso cambiare la definizione della funzione
in modo che sia <b>static</b> e verificare che il linker la puo' trovare.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Modificare
<b>Volatile.cpp</b>
dal capitolo 8 per trasformare <b>comm::isr( )</b> in qualcosa che possa
funzionare come routine di servizio di un interrupt. Suggerimento: una
routine di interrupt non ha argomenti.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Scrivere
e compilare un semplice programma che contiene le parole chiave <b>auto</b>
e <b>register</b>.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
un header file che contiene un <b>namespace</b>. Dentro il <b>namespace</b>
creare diverse dichiarazioni di funzioni. Adesso creare un secondo header
file che include il primo e continua la definizione del <b>namespace</b>,
aggiungendo diverse altre dichiarazioni di funzioni. Adesso creare un file
<b>cpp</b>
che include il secondo header file. Sostituire il nome del namespace con
uno pseudonimo (più corto). All'interno di una definizione di funzione,
chiamare una delle funzioni con la risoluzione di scope. All'interno di
una definizione di funzione separata, scrivere una direttiva <b>using</b>
per inserire il namespace nello scope di questa funzione e mostrare che
non è necessario usare la risoluzione di scope per chiamare le funzioni
dal namespace.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
un header file con un namespace senza nome. Includere l' header in due
file <b>cpp</b> separati e mostrare che un namespace senza nome è unico
per ogni unità di compilazione.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Usando
l'header file dell'Esercizio 17, mostrare che i nomi di un namespace senza
nome sono disponibili automaticamente in un'unità di compilazione, senza
qualificazione.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Modificare
<b>IniezioneFriend.cpp</b>
per aggiungere una definizione per una funzione friend e per chiamare la
funzione all'interno del <b>main( )</b>.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">In
<b>Aritmetica.cpp</b>,
dimostrare che la direttiva <b>using</b> non si estende al di fuori della
funzione in cui la direttiva è stata inserita.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Rimediare
al problema in <b>AmbiguitaDaSovrapposizione.cpp</b>, prima con la risoluzione
di scope, poi invece usando la dichiarazione <b>using</b> che costringe
il compilatore a scegliere una dei nomi di funzione identici.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">In
due header file, creare due namespace, ciascuno contenente una classe(con
tutte definizioni inline) con un nome identico a quella dell'altro namespace.
Creare un file <b>cpp</b> che include entrambi gli header file. Creare
una funzione e al suo interno usare la direttiva <b>using</b> per introdurre
entrmbi i namespace. Provare a creare un oggetto di questa classe e vedere
cosa succede. Rendere globale le direttive <b>using</b> (esterne alle funzioni)
per vedere se c'è qualche differenza. Risolvere il problema usando la
risoluzione di scope e creare oggetti di entrambe le classi.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Rimediare
al problema nell'Esercizio 22 con una dichiarazione <b>using</b> che costringe
il compilatore a scegliere uno dei nomi di classe identici.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Estrarre
le dichiarazioni di namespace in <b>BobsSuperDuperLibrary.cpp</b> e <b>NamespaceSenzaNome.cpp</b>
e metterle in header file separati, e dare un nome al namespace attualmente
senza nome. In un terzo header file creare un nuovo namespace che combina
gli elementi degli altri due namespace con dichiarazioni <b>using</b>.
Nel <b>main( )</b>, introdurre il nuovo namespace con una direttiva <b>using</b>
e accedere a tutti gli elementi del namespace.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare<span 
     style="mso-spacerun: yes">&nbsp;</span>un
header file che include <b>&lt;string></b> e <b>&lt;iostream></b> ma che
non usa nessuna direttiva o dichiarazione <b>using</b>. Aggiungere "include
guards" come abbiamo visto negli header file in questo libro. Creare una
classe con tutte funzioni inline che contiene un membro di tipo <b>string</b>,
con un costruttore che inizializza questa <b>string</b> con il suo argomento
e una funzione <b>print( )</b> che mostra la <b>string</b>. Creare un file
<b>cpp</b>
e utilizzare la classe nel <b>main( )</b>.</font></span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una<span 
     style="mso-spacerun: yes">&nbsp;</span>classe contenente
uno <b>static</b> <b>double</b> e un <b>long</b>. Scrivere una funzione
membro <b>static</b> che ne stampa i valori.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una<span 
     style="mso-spacerun: yes">&nbsp;</span>classe contenente
un <b>int</b>, un costruttore che inizializza l' <b>int</b> con il suo
argomento e una funzione <b>print( )</b> per mostrare l' <b>int</b>. Adesso
creare una seconda classe che contiene un oggetto <b>static</b> della prima
classe. Aggiungere una funzione membro <b>static</b> che chiama la funzione <b>print(
)<span 
     style="mso-spacerun: yes"></span></b><span 
     style="mso-spacerun: yes">&nbsp;</span>dell'oggetto <b>static</b>.
Utilizzare la classe nel <b>main( )</b>.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una classe contenente array di <b>int</b> sia
<b>const</b>
che non-<b>const</b> <b>static</b>. Scrivere metodi <b>static</b> per stampare
gli array. Utilizzare la classe nel <b>main( )</b>.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una classe contenente una <b>string</b>, con un costruttore che inizializza
la <b>string</b> con il suo argomento e una funzione <b>print( )</b> per
mostrare la <b>string</b>. Creare un'altra classe contenente array di oggetti
della prima classe, sia <b>const </b>che non-<b>const</b> <b>static</b>,
e metodi <b>static</b> per stampare questi array. Utilizzare questa seconda
classe nel <b>main( )</b>.&nbsp;</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una <b>struct</b> che contiene un <b>int</b> e un costruttore di default
che inizializza l' <b>int</b> a zero. Rendere questa <b>struct</b> locale
ad una funzione. All'interno della funzione creare un array di oggetti
della <b>struct</b> e dimostrare che ciascun <b>int</b> nell' array è
stato automaticamente inizializzato a zero.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Creare
una classe che rappresenta una connessione ad una stampante e che permette
di avere solo una stampante.</font>  </span></li><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">In
un header file, creare una classe <b>Mirror </b>che contiene due dati membro:
un puntatore a un oggetto <b>Mirror </b>e un <b>bool</b>. Fornirgli due
costruttori: il costruttore di default inizializza il <b>bool</b> a <b>true</b>
e il puntatore <b>Mirror </b>a zero. Il secondo costruttore prende come
argomento un puntatore a un oggetto <b>Mirror</b>, che esso assegnerà
al puntatore interno all'oggetto; in più setta il <b>bool</b> a <b>false</b>.
Aggiungere una funzione membro <b>test( )</b>: se il puntatore all'oggetto
è diverso da zero, esso restituisce il valore di <b>test( ) </b>chiamato
attraverso il puntatore. Se il puntatore è zero, restituisce il <b>bool</b>.
Adesso creare cinque file <b>cpp</b>, ciascuno dei quali include l'header
<b>Mirror</b>.
Il primo file <b>cpp</b> definisce un oggetto<span style="mso-spacerun:
     yes">&nbsp;</span><b>Mirror
</b>globale,
usando il costruttore di default. Il secondo file dichiara come <b>extern</b>
l'oggetto del primo file e definisce un oggetto <b>Mirror
</b>globale,
usando il secondo costruttore, con un puntatore al primo oggetto. Continuare
così fino all'ultimo file, che dovrà contenere anche la definizione di
un oggetto globale. In questo file, il <b>main( )</b> dovrebbe chiamare
la funzione <b>test( )</b> e riportare il risultato. Se il risultato è
<b>true</b>,
vedere come cambiare l'ordine di link per il vostro linker e cambiare l'ordine
fino a quando il risultato è <b>false</b>.</font></span><span lang=IT style='mso-ansi-language:
     IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Rimediare
al problema nell'Esercizio 32 usando la tecnica numero uno mostrata in
questo libro.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Rimediare
al problema nell'Esercizio 32
usando la tecnica numero due mostrata in questo libro.</font></span><span lang=IT
     style='mso-ansi-language:IT'><o:p></o:p></span></li>

<li class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo19;tab-stops:list .5in">
<span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><font face="Georgia">Senza
includere header file, dichiarare la funzione <b>puts( )</b> della Libreria
Standard del C. Chiamare questa funzione dal <b>main( )</b>.</font></span><span 
     lang=IT style='mso-ansi-language:IT'><o:p></o:p></span></li>
</span></span></span></span></span></span></span></span></ol><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'><span lang=IT
     style='font-family:Georgia;mso-ansi-language:IT'>

<hr>
<a href="#fnB47" NAME="fn47">[47]</a><font face="Georgia"><font size=-1>Bjarne 
Stroustrup and Margaret Ellis, <i>The Annotated C++ Reference Manual</i>, Addison-Wesley, 
1990, pp. 20-21.</font></font> 
<center>
  <font face="Verdana"><font size=-1>[ <u><font color="#0000FF"><a href="Capitolo09.html">Capitolo 
  Precedente </a></font></u>] [ <u><font color="#0000FF"><a href="Contents.html">Indice 
  Generale</a></font></u> ] [ <u><font color="#0000FF"><a href="DocIndex.html">Indice 
  Analitico </a></font></u>] [ <u><font color="#0000FF"><a href="Capitolo11.html">Prossimo 
  Capitolo</a></font></u> ]</font></font> <br>
  <font face="Georgia">Ultima modifica:24/12/2002</font> 
</center>

</span></span></span></span></span></span></span></span></span></span></span></span></span>
</body>
</html>
