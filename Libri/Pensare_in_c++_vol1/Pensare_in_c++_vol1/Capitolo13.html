<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=us-ascii">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./Capitolo13_file/filelist.xml">
<link rel=Edit-Time-Data href="./Capitolo13_file/editdata.mso">
<title>13: Creazione dinamica di oggetti</title>
</head>

<body bgcolor=white lang=IT link=blue vlink=blue style='tab-interval:35.4pt'>

<div class=Section1>

<p class=MsoNormal align=center style='text-align:center'><a
href="http://www.MindView.net"><span style='text-decoration:none;text-underline:
none'><img border=0 width=750 height=96 id="_x0000_i1025"
src=mindview-head.gif alt="MindView Inc."></span></a></p>

<p align=center style='text-align:center'><span style='font-size:10.0pt;
font-family:Verdana'>[ </span><a href="README-HTML.txt"><span style='font-size:
10.0pt;font-family:Verdana'>Suggerimenti</span></a><span style='font-size:10.0pt;
font-family:Verdana'> ] [ </span><a
href="http://www.mindview.net/CPPServices/SolutionGuide.html"><span
style='font-size:10.0pt;font-family:Verdana'>Soluzioni degli Esercizi</span></a><span
style='font-size:10.0pt;font-family:Verdana'>] [ </span><a
href="http://www.mindview.net/ThinkingInCPP2e.html"><span style='font-size:
10.0pt;font-family:Verdana'>Volume 2</span></a><span style='font-size:10.0pt;
font-family:Verdana'> ] [ </span><a
href="http://www.mindview.net/MailingList.html"><span style='font-size:10.0pt;
font-family:Verdana'>Newsletter Gratuita</span></a><span style='font-size:10.0pt;
font-family:Verdana'> ] <br>
[ </span><a href="http://www.mindview.net/CPPServices/#PublicSeminars"><span
style='font-size:10.0pt;font-family:Verdana'>Seminari</span></a><span
style='font-size:10.0pt;font-family:Verdana'> ] [ </span><a
href="http://www.mindview.net/CPPServices/#SeminarsOnCD"><span
style='font-size:10.0pt;font-family:Verdana'>Seminari su CD ROM</span></a><span
style='font-size:10.0pt;font-family:Verdana'> ] [ </span><a
href="http://www.mindview.net/CPPServices/#ConsultingServices"><span
style='font-size:10.0pt;font-family:Verdana'>Consulenza</span></a><span
style='font-size:10.0pt;font-family:Verdana'>] </span></p>

<h2 align=center style='text-align:center'><span style='font-family:Verdana'>Pensare
in C++, seconda ed. </span><span lang=EN-GB style='font-family:Verdana;
mso-ansi-language:EN-GB'>Volume 1</span><span lang=EN-GB style='mso-ansi-language:
EN-GB'><o:p></o:p></span></h2>

<h3 align=center style='text-align:center'><span lang=EN-GB style='font-family:
Verdana;mso-ansi-language:EN-GB'>&copy;2000 by Bruce Eckel</span><span lang=EN-GB
style='mso-ansi-language:EN-GB'><o:p></o:p></span></h3>

<p align=center style='text-align:center'><span style='font-size:10.0pt;
font-family:Verdana'>[ </span><a href="Capitolo12.html"><span style='font-size:
10.0pt;font-family:Verdana'>Capitolo Precedente </span></a><span
style='font-size:10.0pt;font-family:Verdana'>] [ </span><a href="Contents.html"><span
style='font-size:10.0pt;font-family:Verdana'>Indice Generale</span></a><span
style='font-size:10.0pt;font-family:Verdana'> ] [ </span><a href="DocIndex.html"><span
style='font-size:10.0pt;font-family:Verdana'>Indice Analitico </span></a><span
style='font-size:10.0pt;font-family:Verdana'>] [ </span><a
href="Capitolo14.html"><span style='font-size:10.0pt;font-family:Verdana'>Prossimo
Capitolo</span></a><span style='font-size:10.0pt;font-family:Verdana'> ] </span></p>

  <p align=center style='text-align:center'><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">trad. 
    italiana e adattamento a cura di Umberto Sorbo</font></span></p>

  <h1><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">13: 
    Creazione dinamica di oggetti<o:p></o:p><o:p></o:p></font><o:p></o:p></span></h1>

  <p><span style='font-size:13.5pt;font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif" size="4">A 
    volte si conosce l'esatta quantit&agrave;, tipo e tempo di vita degli oggetti 
    del nostro programma. Ma non sempre.</font></span></p>  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Quanti 
    aeroplani gestir&agrave; un sistema di traffico aereo? Quante figure user&agrave; 
    un sistema CAD? Quanti nodi ci saranno in una rete?</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Per 
    risolvere il problema della programmazione generale, &egrave; essenziale che 
    si possa creare e distruggere gli oggetti a tempo di esecuzione. Naturalmente, 
    il C ha sempre fornito funzioni per l<i>'allocazione dinamica della memoria 
    </i><b>malloc() </b>e<b> free() </b>( insieme con le varianti di <b>malloc()</b>) 
    che allocano memoria nella heap ( anche detta memoria libera ) a runtime.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Tuttavia, 
    queste non funzioneranno in C++. Il costruttore non permette di maneggiare 
    l'indirizzo della memoria da inizializzare e per una buona ragione. Se lo 
    si potesse fare, si potrebbe:</span></font></p>
  <ol start=1 type=1>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo1;tab-stops:list 36.0pt'>
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Dimenticare. L'inizializzazione garantita degli oggetti in C++ non 
        sarebbe tale. </span></font></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo1;tab-stops:list 36.0pt'>
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Accidentalmente fare qualcosa all'oggetto prima di inizializzarlo, 
        aspettandosi che accada la cosa giusta.</span> </font></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo1;tab-stops:list 36.0pt'>
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Maneggiare l'oggetto di dimensioni sbagliate. </span></font></p>
    </li>
  </ol>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>E 
    naturalmente, persino se si &egrave; fatto tutto correttamente, chiunque modificasse 
    il nostro programma &egrave; incline agli stessi errori. L'impropria inizializzazione 
    &egrave; responsabile di un gran numero di problemi della programmazione, 
    perci&ograve; &egrave; molto importante garantire le chiamate ai costruttori 
    per gli oggetti creati nella heap.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Perci&ograve; 
    come fa il C++ a garantire una corretta inizializzazione e pulizia, ma permettere 
    di creare oggetti dinamicamente nella heap?</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    risposta &egrave; di portare la creazione dinamica nel nucleo del linguaggio 
    <b>malloc(&nbsp;)</b> e <b>free()</b> sono funzioni di libreria e cos&igrave; 
    fuori dal controllo del compilatore. Tuttavia, se si ha un operatore per eseguire 
    l'atto combinato dell'allocazione dinamica della memoria e l'inizializzazione 
    ed un altro operatore per eseguire l'atto combinato di pulizia e rilascio 
    della memoria, il compilatore pu&ograve; ancora garantire che i costruttori 
    e distruttori saranno chiamati per tutti gli oggetti.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>In 
    questo capitolo, si imparer&agrave; come le funzioni <b>new</b> e <b>delete</b> 
    del C++ elegantemente risolvono questo problema, creando in modo sicuro gli 
    oggetti nella heap.</span></font></p>

  <h2><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Creazione 
    dell'oggetto<o:p></o:p></font><o:p></o:p></span></h2>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Quando 
    un oggetto C++ viene creato accadono due eventi:</font></span></p>
  <ol start=1 type=1>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo2;tab-stops:list 36.0pt'> 
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>La memoria &egrave; allocata per l'oggetto.</span> </font></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo2;tab-stops:list 36.0pt'> 
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Il costruttore viene chiamato per inizializzare la memoria.</span> 
        </font></p>
    </li>
  </ol>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Per 
    ora si dovrebbe credere che il passo due ci sia sempre. Il C++ lo impone perch&egrave; 
    oggetti non inizializzati sono la maggior fonte di bachi. Non importa dove 
    o come l'oggetto viene creato, il costruttore viene sempre chiamato.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Tuttavia, 
    pu&ograve; succedere che il passo uno venga attuato in diversi modi o in tempi 
    alterni:</span></font></p>
  <ol start=1 type=1>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo3;tab-stops:list 36.0pt'> 
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>La memoria pu&ograve; essere allocata nell'area di memoria statica 
        prima che il programma cominci. Questa memoria esiste durante tutta la 
        vita del programma.</span> </font></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo3;tab-stops:list 36.0pt'> 
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Lo spazio pu&ograve; essere creato nello stack ogni volta che viene 
        raggiunto un particolare punto di esecuzione ( una parentesi aperta). 
        Questo spazio viene rilasciato automaticamente in un punto complementare 
        di esecuzione ( la parentesi di chiusura). Queste operazioni di allocazione 
        nello stack vengono eseguite con le istruzioni proprie del processore 
        e sono molto efficienti. Tuttavia, si deve sapere esattamente di quante 
        variabili si ha bisogno quando si scrive il programma in modo che il compilatore 
        possa generare il giusto codice.</span> </font></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo3;tab-stops:list 36.0pt'> 
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Lo spazio pu&ograve; essere allocato da una zona di memoria detta 
        heap ( anche conosciuta come memoria libera). Ci&ograve; viene detta allocazione 
        dinamica della memoria. Per allocare questa memoria, viene chiamata una 
        funzione a run time (tempo di esecuzione); ci&ograve; significa che si 
        pu&ograve; decidere in qualsiasi momento che si vuole della memoria e 
        quanta se ne vuole. Si &egrave; anche responsabili del rilascio della 
        memoria, ci&ograve; significa che il tempo di vita della memoria &egrave; 
        a piacere e non dipende dallo scope. </span></font></p>
    </li>
  </ol>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Spesso 
    queste tre regioni sono piazzate in un singolo pezzo contiguo di memoria fisica: 
    l'area statica, lo stack e la heap ( in un ordine determinato dal progettista 
    del compilatore). Tuttavia, non ci sono regole. Lo stack pu&ograve; essere 
    in un posto speciale e la heap pu&ograve; essere implementato facendo chiamate 
    a pezzi di memoria dal sistema operativo. Per un programmatore, queste cose 
    sono normalmente nascoste, quindi tutto ci&ograve; che bisogna sapere &egrave; 
    che la memoria &egrave; disponibile quando serve.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">L'approccio 
    del C alla heap<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Per 
    allocare memoria dinamicamente a runtime, il C fornisce funzioni nella sua 
    libreria standard:<b> malloc() </b>e le sue varianti<b> calloc()</b> e <b>realloc()</b> 
    per allocare memoria nella heap, <b>free()</b> per rilasciare la memoria alla 
    heap. Queste funzioni sono pragmatiche ma primitive e richiedono comprensione 
    ed attenzione da parte del programmatore. Per creare un'istanza di una classe 
    nella heap usando le funzioni della memoria dinamica del C, si dovrebbe fare 
    qualcosa del genere:</font></span></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span style='color:#009900'>//: C13:MallocClass.cpp</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>// Malloc con oggetti di classi</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>// Cosa si deve fare se non      si vuole usare &quot;new&quot;</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      <span
style='color:#004488'>&quot;../require.h&quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstdlib&gt; <span
style='color:#009900'>// malloc() &amp; free()</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstring&gt; <span
style='color:#009900'>// memset()</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>class</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Oggetto {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>int</span> i, j, k;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>enum</span> { sz = 100 };<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>char</span> buf[sz];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>public</span>:</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span><span
style='color:blue'>void</span> inizializza() { <span style='color:#009900'>//      non si pu&ograve; usare il costruttore</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>cout      &lt;&lt; <span
style='color:#004488'>&quot;inizializzo Oggetto&quot;</span> &lt;&lt; endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>i      = j = k = 0;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>memset(buf, 0, sz);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span>}</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span><span
style='color:blue'>void</span> distruggi() <span style='color:blue'>const</span>      { <span
style='color:#009900'>// Non si pu&ograve; usare il distruttore</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>cout      &lt;&lt; <span
style='color:#004488'>&quot;distruggo Oggetto&quot;</span> &lt;&lt; endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span>}</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>};</pre>
  <pre style='margin-top:0cm;margin-right:36.0pt;
margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><o:p></o:p></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>int</span> main() {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span>Oggetto*      oggetto = (Oggetto*)malloc(<span
style='color:blue'>sizeof</span>(Oggetto));</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>require(oggetto != 0);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span>oggetto-&gt;inizializza();</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span><span
style='color:#009900'>// ... un p&ograve; dopo:</span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span style="mso-spacerun: yes">&nbsp; </span>oggetto-&gt;distruggi();</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span>free(oggetto);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>} <span style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Si 
    pu&ograve; vedere l'uso di <b>malloc()</b> per creare spazio per l'oggetto 
    nella linea:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">Oggetto* 
    oggetto = (Oggetto*)malloc(<span
style='color:blue'>sizeof</span>(Oggetto));</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Qui, 
    l'utente deve determinare le dimensioni dell'oggetto (un posto per un errore). 
    <b>malloc() </b>restituisce un <b>void*</b> perch&egrave; produce solo una 
    porzione di memoria, non un oggetto. Il C++ non permette di assegnare un puntatore 
    <b>void*</b> ad un qualsiasi altro puntatore, perci&ograve; bisogna effettuare 
    un cast.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Poich&egrave; 
    <b>malloc()</b> pu&ograve; fallire nel ricercare memoria libera ( in questo 
    caso restituisce zero), si deve controllare il puntatore restituito per essere 
    sicuri che tutto sia andato bene.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Ma 
    il problema peggiore &egrave; questa linea:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">oggetto-&gt;inizializza();</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Gli 
    utenti devono ricordasi di inizializzare l'oggetto prima di usarlo. Si noti 
    che non &egrave; stato usato un costruttore perch&egrave; il costruttore non 
    pu&ograve; essere chiamato esplicitamente<a
name=fnB50></a><a href="#fn50"><span style='mso-bookmark:fnB50'>[50]</span></a> 
    , esso viene chiamato per noi dal compilatore quando viene creato un oggetto 
    . Il problema qui &egrave; che l'utente ora ha la possibilit&agrave; di dimenticare 
    di eseguire l'inizializzazione prima che l'oggetto venga utilizzato, introducendo 
    cos&igrave; una grossa sorgente di bachi.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Molti 
    programmatori trovano che le funzioni per l'allocazione dinamica della memoria 
    in C sono molto complicate e fonte di confusione; &egrave; comune trovare 
    programmatori C che usano macchine di memoria virtuale che allocano enormi 
    array di variabili nell'area statica di memoria per evitare di pensare all'allocazione 
    dinamica della memoria. Poich&egrave; il C++ sta cercando di rendere sicure 
    e facili da usare le librerie per il programmatore inesperto, l'approccio 
    del C alla memoria dinamica &egrave; inaccettabile.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">operatore 
    new<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">La 
    soluzione del C++ &egrave; quella di combinare tutte le azioni necessarie 
    per creare un oggetto in un singolo operatore chiamato <b>new</b>. Quando 
    si crea un oggetto con <b>new</b>, esso alloca sufficiente memoria nella heap 
    per contenere l'oggetto e chiama il costruttore per quella memoria. Cosi , 
    se si scrive:</font></span></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">MioTipo 
    *fp = <span style='color:blue'>new</span> MioTipo(1,2);</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>a 
    runtime, viene chiamato l'equivalente di <b>malloc(sizeof(MioTipo))</b> (spesso, 
    &egrave; una chiamata a<b> malloc()</b>) ed il costruttore per <b>MioTipo</b> 
    viene chiamato con l'indirizzo risultante come il puntatore <b>this</b>, usando<b> 
    (1,2) </b>come lista argomenti. Il puntatore &egrave; poi assegnato a <b>fp</b>, 
    esso &egrave; un oggetto istanziato ed inizializzato, non ci si pu&ograve; 
    mettere le mani sopra prima di allora. Esso &egrave; anche il giusto tipo 
    <b>MioTipo</b> perci&ograve; non &egrave; necessario il cast. </span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    <b>new</b> di default controlla se l'allocazione della memoria &egrave; avvenuta 
    con successo prima di passare l'indirizzo al costruttore, perci&ograve; non 
    si deve esplicitamente determinare se la chiamata ha avuto successo. Pi&ugrave; 
    avanti nel capitolo si scoprir&agrave; cosa accade se non c'&egrave; pi&ugrave; 
    memoria libera.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Si 
    pu&ograve; creare una nuova espressione usando qualsiasi costruttore disponibile 
    per la classe. Se il costruttore non ha argomenti, si scrive l'espressione 
    new senza la lista di argomenti del costruttore:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">MioTipo 
    *fp = <span style='color:blue'>new</span> MioTipo;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Si 
    noti come il processo di creazione degli oggetti nella heap diventi semplicemente 
    una singola espressione, con tutti i controlli sulla dimensione, conversione 
    e sicurezza integrati dentro. &Egrave; facile creare un oggetto nella heap 
    come se lo si facesse nello stack.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">operatore 
    delete<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Il 
    complemento alla espressione new &egrave; l'espressione delete, che per prima 
    chiama il distruttore e poi libera la memoria ( spesso con una chiamata alla 
    <b>free()</b> ). Proprio come una espressione new ritorna un puntatore all'oggetto, 
    un' espressione di delete richiede l'indirizzo di un oggetto.</font></span></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span style='color:blue'>delete</span> 
    fp;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Ci&ograve; 
    distrugge e poi libera la memoria allocata per l'oggetto <b>MioTipo</b> creato 
    dinamicamente precedentemente.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><b><span style='font-family:Georgia'>delete 
    </span></b><span
style='font-family:Georgia'>pu&ograve; essere chiamata solo per un oggetto creato 
    con <b>new</b>. Se si usa<b> malloc(&nbsp;)</b> (o<b> calloc(&nbsp;)</b> o 
    <b>realloc(&nbsp;)</b>) e poi <b>delete</b>, il comportamento non &egrave; 
    definito. Poich&egrave; molte implementazioni di <b>new</b> e <b>delete</b> 
    usano<b> malloc()</b> e <b>free()</b>, si terminer&agrave; con il rilascio 
    della memoria senza chiamare il distruttore.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Se 
    il puntatore che si sta cancellando &egrave; zero, non accadr&agrave; niente. 
    Per questo motivo, spesso si raccomanda di impostare il puntatore a zero immediatamente 
    dopo che lo si &egrave; cancellato, in modo da prevenire la cancellazione 
    doppia. Cancellare un oggetto pi&ugrave; di una volta &egrave; una cosa completamente 
    sbagliata e causa problemi.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Un 
    semplice esempio<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Questo 
    semplice esempio mostra come avviene l'inizializzazione:</font></span></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span lang=EN-GB style='color:#009900;mso-ansi-language:
EN-GB'>//: C13:Tree.h</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#ifndef      TREE_H<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#define      TREE_H<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>class</span> Albero {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span><span
style='color:blue'>int</span> altezza;</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span
style='color:blue'>public</span>:</pre>
  <pre style='margin-top:0cm;margin-right:
36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>Albero(<span
style='color:blue'>int</span> altezzaAlbero) : altezza(altezzaAlbero) {}</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span>~Albero()      { std::cout &lt;&lt; <span
style='color:#004488'>&quot;*&quot;</span>; }</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>friend</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> std::ostream&amp;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>operator</span>&lt;&lt;(std::ostream&amp; os, <span
style='color:blue'>const</span> Albero* t) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>return</span> os &lt;&lt; <span style='color:#004488'>&quot;      altezza Albero:&quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span>&lt;&lt; t-&gt;altezza&lt;&lt; std::endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}; <o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#endif      <span
style='color:#009900'>// TREE_H ///:~</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//: C13:NewAndDelete.cpp</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>// semplice demo di new &amp;      delete</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      <span
style='color:#004488'>&quot;Tree.h&quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>int</span> main() {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span>Albero* t      = <span
style='color:blue'>new</span> Albero(40);</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>cout &lt;&lt; t;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp; </span><span
style='color:blue'>delete</span> t;</pre>
  <pre style='margin-top:0cm;margin-right:
36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'>} <span
style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    prova che il costruttore viene chiamato &egrave; data dalla stampa del valore 
    di <b>Albero</b>. Qui , viene fatto con l'overloading dell'operatore &lt;&lt; 
    per usarlo con un <b>ostream</b> ed un <b>Albero*</b>. Si noti, tuttavia, 
    che anche se la funzione &egrave; dichiarata come un <b>friend</b>, essa &egrave; 
    definita come una inline! Ci&ograve; &egrave; per pura convenienza, definire 
    una funzione <b>friend</b> come inline per una classe non cambia lo stato 
    di <b>friend</b> o il fatto che essa &egrave; una funzione globale e non una 
    funzione membro della classe. Si noti anche che il valore di ritorno &egrave; 
    il risultato di un' intera espressione, che &egrave; un <b>ostream&amp;</b> 
    ( cos&igrave; deve essere, per soddisfare il tipo del valore di ritorno della 
    funzione).</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Overhead 
    del manager della memoria<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Quando 
    si creano oggetti automatici nello stack, la dimensione degli oggetti ed il 
    loro tempo di vita &egrave; costruito direttamente nel codice generato, perch&egrave; 
    il compilatore conosce esattamente tipo, quantit&agrave; e visibilit&agrave;. 
    Creare oggetti nella heap implica maggior overhead, sia come tempo che come 
    spazio. Ecco un tipico scenario. (Si pu&ograve; rimpiazzare <b>malloc() </b>con 
    <b>calloc()</b> o <b>realloc ()</b> )</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Si 
    chiama <b>malloc()</b>, che richiede un blocco di memoria libera. ( Questo 
    codice potrebbe essere in realt&agrave; parte di <b>malloc()</b> )</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Viene 
    cercato un blocco di memoria libera grande abbastanza per soddisfare la richiesta. 
    Ci&ograve; avviene controllando una mappa che mostra quali blocchi sono correntemente 
    in uso e quali sono disponibili. &Egrave; un processo rapido, ma pu&ograve; 
    richiedere pi&ugrave; di un tentativo quindi potrebbe non essere deterministico, 
    cio&egrave; non si pu&ograve; pensare che <b>malloc()</b> richieda sempre 
    la stessa quantit&agrave; di tempo.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Prima 
    che un puntatore al blocco venga restituito, la dimensione e la locazione 
    del blocco deve essere memorizzato in modo che successive chiamate di <b>malloc() 
    </b>non lo usino e che quando si chiama <b>free(),</b> il sistema sappia quanta 
    memoria liberare.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    modo in cui tutto ci&ograve; viene implementato pu&ograve; variare enormemente. 
    Per esempio, non c'&egrave; niente che impedisce che le primitive per l'allocazione 
    della memoria siano implementate nel processore. Se si &egrave; curiosi, si 
    pu&ograve; scrivere dei programmi di test per provare a indovinare il modo 
    in cui <b>malloc()</b> &egrave; implementata. Si pu&ograve; anche leggere 
    la libreria del codice sorgente, se la si ha ( I sorgenti del C GNU sono sempre 
    disponibili).</span></font></p>

  <h2><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">I 
    primi esempi ridisegnati<o:p></o:p></font><o:p></o:p></span></h2>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Utilizzando 
    <b>new</b> e <b>delete</b>, l'esempio <b>Stash</b> introdotto precedentemente 
    in questo libro pu&ograve; essere riscritto usando tutte le caratteristiche 
    discusse nel libro finora. Esaminando il nuovo codice si avr&agrave; anche 
    una utile rassegna degli argomenti.</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>A 
    questo punto del libro, n&egrave; la classe <b>Stash</b> che la<b> Stack</b> 
    possederanno gli oggetti a cui puntano; cio&egrave;, quando l'oggetto <b>Stash</b> 
    o <b>Stack</b> perde visibilit&agrave;, non chiamer&agrave; <b>delete</b> 
    per tutti gli oggetti a cui punta. La ragione per cui ci&ograve; non &egrave; 
    possibile &egrave; data dal fatto che, in un tentativo di essere generici, 
    essi gestiscono puntatori <b>void</b>. Se si cancella un puntatore <b>void</b>, 
    la sola cosa che accade &egrave; che la memoria viene rilasciata, perch&egrave; 
    non c'&egrave; nessuna informazione sul tipo e non c'&egrave; modo per il 
    compilatore di sapere quale distruttore chiamare.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">delete 
    void* &egrave; probabilmente un bug<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Vale 
    la pena di chiarire che se si chiama <b>delete</b> per un <b>void*</b>, &egrave; 
    quasi certo che si tratta di bug nel nostro programma a meno che la destinazione 
    del puntatore sia molto semplice; in particolare, si dovrebbe non avere un 
    distruttore. Qui c'&egrave; un esempio per mostrare cosa accade:</font></span></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'>&nbsp;</p>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#009900" face="Georgia, Times New Roman, Times, serif">//:      C13:BadVoidPointerDeletion.cpp</font> </pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#009900" face="Georgia, Times New Roman, Times, serif">//      Deleting void pointers can cause memory leaks</font> </pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">#include      &lt;iostream&gt;</font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'> <font color="#0000ff" face="Georgia, Times New Roman, Times, serif">using</font>      <font color="#0000ff" face="Georgia, Times New Roman, Times, serif">namespace</font><font face="Georgia, Times New Roman, Times, serif">      std; </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">class</font><font face="Georgia, Times New Roman, Times, serif">      Object { </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">void</font><font face="Georgia, Times New Roman, Times, serif">*      data;<font color=#009900> // un p&ograve; di memoria</font></font> </pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">const</font>      <font color="#0000ff" face="Georgia, Times New Roman, Times, serif">int</font><font face="Georgia, Times New Roman, Times, serif">      size; </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">const</font>      <font color="#0000ff" face="Georgia, Times New Roman, Times, serif">char</font><font face="Georgia, Times New Roman, Times, serif">      id; </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">public</font><font face="Georgia, Times New Roman, Times, serif">:      Object(<font color=#0000ff>int</font> sz, <font color=#0000ff>char</font>      c) : size(sz), id(c) { </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">data      = <font color=#0000ff>new</font></font> <font color="#0000ff" face="Georgia, Times New Roman, Times, serif">char</font><font face="Georgia, Times New Roman, Times, serif">[size];      </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">cout      &lt;&lt; <font color=#004488>"Costruzione oggetto"</font></font> <font face="Georgia, Times New Roman, Times, serif">&lt;&lt;      id &lt;&lt; <font color=#004488>", dimensioni = "</font></font> <font face="Georgia, Times New Roman, Times, serif">&lt;&lt;      size &lt;&lt; endl; </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">} </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">~Object()      { </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">cout      &lt;&lt; <font color=#004488>"Distruzione oggetto"</font></font> <font face="Georgia, Times New Roman, Times, serif">&lt;&lt;      id &lt;&lt; endl; </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">delete</font><font face="Georgia, Times New Roman, Times, serif">      []data; <font color=#009900>// OK, rilascio solo la memoria</font></font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'> <font color="#009900" face="Georgia, Times New Roman, Times, serif">//      non &egrave; necessaria la chiamata al distruttore</font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">} </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">};      </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">int</font><font face="Georgia, Times New Roman, Times, serif">      main() { </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">Object*      a = <font color=#0000ff>new</font> Object(40, 'a'); </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">delete</font><font face="Georgia, Times New Roman, Times, serif">      a; </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">void</font><font face="Georgia, Times New Roman, Times, serif">*      b = <font color=#0000ff>new</font> Object(40, 'b'); </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font color="#0000ff" face="Georgia, Times New Roman, Times, serif">delete</font><font face="Georgia, Times New Roman, Times, serif">      b; </font></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">} <font color=#009900>///:~</font></font></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    classe </span><b>Object</b><span style='font-family:Georgia'> contiene un 
    <b>void*</b> che &egrave; inizializzato da dati &quot;grezzi&quot; ( non punta 
    ad oggetti che hanno un distruttore). Nel distruttore di </span><b>Object</b><span style='font-family:Georgia'>, 
    delete viene chiamato per questo <b>void*</b> senza effetti indesiderati, 
    poich&egrave; l'unica cosa di cui abbiamo bisogno che accada &egrave; che 
    sia rilasciata la memoria.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Tuttavia, 
    nel <b>main() </b>si pu&ograve; vedere che &egrave; indispensabile che <b>delete</b> 
    sappia con che tipo di oggetto sta lavorando. Questo &egrave; l'output:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">Costruzione 
    oggetto a, dimensione = 40</font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">Distruzione 
    oggetto a</font></p>
  <p style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">Costruzione 
    oggetto b, dimensione = 40</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Poich&egrave; 
    <b>delete a</b> sa che <b>a</b> punta ad un </span><b>Object</b><span style='font-family:Georgia'>, 
    il distruttore viene chiamato e cos&igrave; la memoria allocata per <b>data</b> 
    viene liberata. Tuttavia, se si manipola un oggetto tramite un <b>void*</b> 
    come nel caso di <b>delete b</b>, l'unica cosa che accade &egrave; che la 
    memoria di <b>Object</b> viene liberata, ma il distruttore non viene chiamato 
    quindi non c'&egrave; memoria rilasciata a cui <b>data</b> punta. Quando questo 
    programma viene compilato, probabilmente non si vedranno messaggi di warning; 
    il compilatore assume che si sappia cosa si sta facendo. Si ottiene quello 
    che in gergo viene detto un memory leak ( una falla di memoria).</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Se 
    si ha un memory leak nel programma, si ricerchino tutti i <b>delete</b> controllando 
    il tipo di puntatore che si sta cancellando. Se &egrave; un <b>void*</b> allora 
    si &egrave; trovata probabilmente una sorgente del memory leak (tuttavia il 
    C++ fornisce altre ampie opportunit&agrave; per i memory leak ).</span><span style='font-family:Verdana'> 
    </span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">La 
    responsabilit&agrave; della pulizia con i puntatori<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Per 
    rendere flessibili i contenitori <b>Stash</b> e <b>Stack</b> ( capaci di gestire 
    qualsiasi tipo di oggetto), essi gestiranno puntatori <b>void</b>. Ci&ograve; 
    significa che quanto viene restituito un puntatore dall'oggetto <b>Stash</b> 
    o <b>Stack</b>, si deve fare il cast di esso al tipo opportuno prima di usarlo; 
    come abbiamo visto sopra, si deve usare il cast verso il tipo opportuno prima 
    di cancellarlo o si avr&agrave; un memory leak.</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Gli 
    altri casi di memory leak hanno a che fare con la sicurezza che quel <b>delete</b> 
    &egrave; realmente chiamato per ogni puntatore ad oggetto gestito nel contenitore. 
    Il contenitore non pu&ograve; possedere un puntatore perch&egrave; lo gestisce 
    come un <b>void*</b> e quindi non pu&ograve; eseguire la corretta pulizia. 
    L'utente ha la responsabilit&agrave; della pulizia degli oggetti. Ci&ograve; 
    produce una serie di problemi se si aggiungono puntatori agli oggetti creati 
    nello stack ed oggetti creati nella heap dallo stesso contenitore perch&egrave; 
    l'espressione delete non &egrave; sicura per un puntatore che non era stato 
    allocato nella heap ( e quando si prende un puntatore dal container, come 
    facciamo a sapere dove &egrave; stato allocato il suo oggetto?). Quindi, si 
    deve essere sicuri che gli oggetti memorizzati nelle versioni che seguono 
    di <b>Stash</b> e <b>Stack</b> vengano fatti solo nella heap, sia tramite 
    una attenta programmazione o creando classi che possono solo essere allocate 
    nella heap.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>&Egrave; 
    anche importante essere sicuri che il programmatore client si prenda la responsabilit&agrave; 
    di pulizia di tutti i puntatori nel container. Si &egrave; visto negli esempi 
    precedenti come la classe <b>Stack</b> controlla nel suo distruttore che tutti 
    gli oggetti <b>Link</b> siano stati poppati. Per uno <b>Stash</b> di puntatori, 
    tuttavia, c'&egrave; bisogno di un altro approccio.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Stash 
    per puntatori<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Questa 
    nuova versione della classe <b>Stash</b>, chiamato <b>PStash</b> gestisce 
    puntatori ad oggetti che esistono di per s&egrave; nella heap, mentre la vecchia 
    <b>Stash</b> nei capitoli precedenti copiava gli oggetti per valore nel container 
    <b>Stash</b>. Usando <b>new</b> e <b>delete</b>, &egrave; facile e sicuro 
    gestire puntatori ad oggetti che sono stati creati nella heap.</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Qui 
    c'&egrave; l'header file per il puntatore Stash:</span></font></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span style='color:#009900'>//:      C13:PStash.h</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      Gestisce puntatori invece di oggetti</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#ifndef      PSTASH_H<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#define      PSTASH_H<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>class</span>      PStash {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>int</span> quantity; <span style='color:#009900'>// Numero      di spazio libero <o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'><span style="mso-spacerun: yes">&nbsp;&nbsp;</span></span><span
style='color:blue'>int</span> next; <span style='color:#009900'>// prossimo spazio      libero</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;      </span><span
style='color:#009900'>// puntatore allo spazio:</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>void</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>** storage;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span> inflate(<span style='color:blue'>int</span> increase);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>public</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>:<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>PStash() : quantity(0), storage(0), next(0) {}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>~PStash();<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>int</span> add(<span style='color:blue'>void</span>* element);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* <span style='color:blue'>operator</span>[](<span
style='color:blue'>int</span> index) <span style='color:blue'>const</span>; <span
style='color:#009900'>// accesso</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:#009900'>// rimuove il riferimento da questo PStash:</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>void</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>* remove(<span style='color:blue'>int</span>      index);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:#009900'>// Numero di elementi in Stash:</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>int</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> count() <span style='color:blue'>const</span>      { <span
style='color:blue'>return</span> next; }<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>};<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#endif      <span
style='color:#009900'>// PSTASH_H ///:~</span><o:p></o:p><o:p></o:p></span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>I 
    sottostanti elementi dei dati sono simili, ma ora </span><b>storage</b><span style='font-family:Georgia'> 
    &egrave; un array di puntatori <b>void</b> e l'allocazione dello spazio per 
    questo array &egrave; eseguita con <b>new</b> invece di <b>malloc()</b>. Nell'espressione</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span style='color:blue'>void</span>** 
    st = <span
style='color:blue'>new</span> <span style='color:blue'>void</span>*[quantity + 
    increase];</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>il 
    tipo di oggetto allocato &egrave; un <b>void*</b>, quindi l'espressione alloca 
    un array di puntatori <b>void</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    distruttore elimina lo spazio dove sono tenuti i puntatori <b>void</b> piuttosto 
    che tentare di cancellare ci&ograve; che essi puntano ( che, come precedentemente 
    notato, rilascer&agrave; la loro memoria e non chiamer&agrave; il distruttore 
    perch&egrave; un puntatore <b>void</b> non ha informazione di tipo).</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'altro 
    cambiamento &egrave; <b>operator[]</b> con<b> fetch()</b> , che ha pi&ugrave; 
    senso sintatticamente. Di nuovo, tuttavia, viene restituito un<b> void*</b>, 
    quindi l'utente deve ricordarsi quali tipi sono memorizzati nel container 
    ed eseguire un cast sui puntatori quando li usa ( un problema che sar&agrave; 
    risolto nei prossimi capitoli).</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Qui 
    ci sono le definizioni delle funzioni membro:</span></font></p>
  <p>&nbsp;</p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span style='color:#009900'>//:      C13:PStash.cpp {O}</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      definizioni Pointer Stash </span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>#include      <span style='color:#004488'>&quot;PStash.h&quot;</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      <span
style='color:#004488'>&quot;../require.h&quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstring&gt; <span
style='color:#009900'>// funzioni 'mem' </span><span style='color:blue'><o:p></o:p></span></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>int</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> PStash::add(<span
style='color:blue'>void</span>* element) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>const</span> <span style='color:blue'>int</span> inflateSize      = 10;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>if</span>(next&gt;= quantity)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>inflate(inflateSize);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>spazio[next++] = element;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>return</span>(next - 1); <span style='color:#009900'>// numero      indice</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:#009900;mso-ansi-language:
EN-GB'>// No ownership:</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>PStash::~PStash()      {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>for</span>(<span style='color:blue'>int</span> i = 0; i &lt;      next; i++)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span>require(storage[i] == 0, </pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
style='color:#004488'>&quot;PStash non ripulito&quot;</span>);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>delete</span> []storage; </pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'>}</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><o:p></o:p></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      overloading Operatore<span style="mso-spacerun: yes">&nbsp; </span>per rimpiazzare<span style="mso-spacerun: yes">&nbsp;      </span>fetch</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>void</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>* PStash::<span
style='color:blue'>operator</span>[](<span style='color:blue'>int</span> index)      <span
style='color:blue'>const</span> {<o:p></o:p></span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span>require(index&gt;= 0,</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:#004488'>&quot;PStash::operator[] indice negativo&quot;</span>);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>if</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>(index&gt;= next)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span><span
style='color:blue'>return</span> 0; <span style='color:#009900'>// Per indicare      la fine <o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      produce un puntatore all'elemento desiderato:<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>return</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> storage[index];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>void</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>* PStash::remove(<span
style='color:blue'>int</span> index) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* v = <span style='color:blue'>operator</span>[](index);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:#009900'>// &quot;Rimuove&quot; il<span style="mso-spacerun: yes">&nbsp;      </span>puntatore:</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>if</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>(v != 0) storage[index] = 0;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>return</span> v;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>void</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> PStash::inflate(<span
style='color:blue'>int</span> increase) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>      <span style="mso-spacerun: yes">&nbsp;</span><span
style='color:blue'>const</span> <span style='color:blue'>int</span> psz = <span
style='color:blue'>sizeof</span>(<span style='color:blue'>void</span>*);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>** st = <span style='color:blue'>new</span> <span
style='color:blue'>void</span>*[quantity + increase];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>memset(st, 0, (quantity + increase) * psz);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>memcpy(st, storage, quantity * psz);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span>quantity += increase;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>delete</span> []storage; <span style='color:#009900'>// Vecchio      spazio</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>storage = st; <span
style='color:#009900'>// Punta a memoria nuova</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>} <span style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    funzione <b>add()</b> &egrave; la stessa di prima, tranne che &egrave; memorizzato 
    un puntatore invece della copia di un intero oggetto.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    codice<b> inflate()</b> &egrave; stato modificato per gestire l'allocazione 
    di un array di<b> void*</b>, mentre nella versione precedente funzionava solo 
    con byte grezzi. Qui, invece di usare l'approccio di copiare con un indice 
    di array, viene usata prima la funzione della libreria Standard C <b>memset()</b> 
    per impostare a zero la memoria nuova (ci&ograve; non &egrave; strettamente 
    necessario, poich&egrave; <b>PStash</b> sta presumibilmente gestendo la memoria 
    correttamente, ma di solito non fa male un bit di attenzione in pi&ugrave;). 
    Poi <b>memcpy()</b> muove i dati esistenti dalla vecchia locazione alla nuova. 
    Spesso, funzioni come <b>memset()</b> e <b>memcpy()</b> sono state ottimizzate 
    nel tempo, quindi possono essere pi&ugrave; veloci dei loop mostrati precedentemente. 
    Ma con una funzione come <b>inflate()</b> che probabilmente non sar&agrave; 
    usata spesso, si per&ograve; non vedere questa differenza di performance. 
    Tuttavia, il fatto che le chiamate a funzione sono pi&ugrave; concise dei 
    loop possono aiutare a prevenire errori nel codice.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Per 
    addossare la responsabilit&agrave; della pulizia degli oggetti sulle spalle 
    del programmatore client, ci sono due modi di accedere ai puntatori in <b>PStash: 
    </b> l'<b>operator[],</b> che semplicemente restituisce il puntatore ma lo 
    lascia come un membro del container ed una seconda funzione membro <b>remove()</b>, 
    che restituisce il puntatore ma lo rimuove anche dal container assegnando 
    quella posizione a zero. Quando viene chiamato il distruttore per <b>PStash</b>, 
    esso controlla per essere sicuro che tutti i puntatori agli oggetti sono stati 
    rimossi; in caso contrario, si &egrave; avvertiti in modo che si pu&ograve; 
    prevenire un memory leak ( le soluzioni pi&ugrave; eleganti sono presenti 
    negli ultimi capitoli).</span></font></p>
  <p><o:p></o:p></p>

  <h4><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Un 
    test<o:p></o:p></font><o:p></o:p></span></h4>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">ecco 
    il vecchio programma di test per <b>Stash</b> riscritto per <b>PStash</b>:</font></span></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span style='color:#009900'>//:      C13:PStashTest.cpp</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//{L}      PStash</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      Test per puntatore Stash</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>#include      <span style='color:#004488'>&quot;PStash.h&quot;</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      <span
style='color:#004488'>&quot;../require.h&quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;fstream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;string&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>int</span>      main() {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>PStash stashIntero;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// 'new' funziona anche con tipi predefiniti. Si noti</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// la sintassi &quot;pseudo-costruttore&quot;:</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>for</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>(<span style='color:blue'>int</span>      i = 0; i &lt; 25; i++)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>stashIntero.add(<span
style='color:blue'>new</span> <span style='color:blue'>int</span>(i));<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>for</span>(<span style='color:blue'>int</span> j = 0; j &lt;      stashIntero.count(); j++)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span><span
lang=FR style='mso-ansi-language:FR'>cout &lt;&lt; <span style='color:#004488'>&quot;stashIntero[&quot;</span>      &lt;&lt; j &lt;&lt; <span
style='color:#004488'>&quot;] = &quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span></span><span
lang=DE style='mso-ansi-language:DE'>&lt;&lt; *(<span style='color:blue'>int</span>*)stashIntero[j]      &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=DE style='mso-ansi-language:DE'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
lang=EN-GB style='color:#009900;mso-ansi-language:EN-GB'>// pulizia:</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>for</span>(<span style='color:blue'>int</span> k = 0; k &lt;      stashIntero.count(); k++)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>delete</span> stashIntero.remove(k);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>ifstream in (<span
style='color:#004488'>&quot;PStashTest.cpp&quot;</span>);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span>assure(in, <span
style='color:#004488'>&quot;PStashTest.cpp&quot;</span>);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>PStash stashStringa;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>string linea;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>while</span>(getline(in, linea))</pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>stashStringa.add(<span
style='color:blue'>new</span> string(linea));</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// Stampa le stringhe:</span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span style='color:blue'>for</span>(<span
style='color:blue'>int</span> u = 0; stashStringa[u]; u++)</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>cout &lt;&lt; <span
style='color:#004488'>&quot;stashStringa[&quot;</span> &lt;&lt; u &lt;&lt; <span
style='color:#004488'>&quot;] = &quot;</span></pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span>&lt;&lt; *(string*)stashStringa[u] &lt;&lt; endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// Pulizia:</span></pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>for</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>(<span style='color:blue'>int</span>      v = 0; v &lt; stashStringa.count(); v++)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span><span
style='color:blue'>delete</span> (string*)stashStringa.remove(v);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>} <span style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Come 
    prima, gli Stash vengono creati ed in essi memorizzata l'informazione, ma 
    quest'ultima &egrave; il puntatore che si ottiene dalle <b>new</b>. Nel primo 
    caso, si noti la linea:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'>stashIntero.add(<span
style='color:blue'>new</span> <span style='color:blue'>int</span>(i));<o:p></o:p></span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'espressione<b> 
    new int(i)</b> usa la pseudo forma del costruttore, quindi la memoria per 
    un nuovo oggetto <b>int</b> viene creata nella heap e l'<b>int</b> &egrave; 
    inizializzato al valore <b>i</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Durante 
    la stampa, il valore restituito dall'operatore di <b>PStash::operator[ ]</b> 
    deve essere castato al tipo opportuno; ci&ograve; viene ripetuto per i restanti 
    oggetti <b>PStash</b> del programma. Non &egrave; un effetto desiderato usare 
    puntatori <b>void</b> e ci&ograve; verr&agrave; aggiustato nei prossimi capitoli.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    secondo test apre i file sorgenti e legge una linea alla volta dentro un altro 
    <b>PStash</b>. Ogni linea viene letta dentro una <b>string</b> usando <b>getline()</b>, 
    poi una nuova stringa viene creata da <b>linea</b> per fare una copia indipendente 
    di quella linea. Se passiamo solo l'indirizzo di <b>linea</b> ogni volta, 
    avremo un mucchio di puntatori a <b>linea</b>, che conterrebbero solo l'ultima 
    linea che &egrave; stata letta dal file.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Quando 
    si usa il puntatore si vede l'espressione:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">*(string*) 
    stashStringa[v]</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    puntatore ritornato dall'operatore <b>[] </b>deve essere castato ad un<b> 
    string*</b> per aver il giusto tipo. Poi la <b>string *</b> &egrave; dereferenziata 
    in modo da valutare l'espressione ad un oggetto, al punto in cui il compilatore 
    vede un oggetto <b>string</b> e lo manda a <b>cout</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'oggetto 
    creato nella heap deve essere distrutto con l'uso del comando<b> remove()</b> 
    o altrimenti si avr&agrave; un messaggio a runtime che ci dice che non sono 
    stati puliti completamente gli oggetti in <b>PStash</b>. Si noti che nel caso 
    di puntatori a <b>int</b>, nessun cast &egrave; necessario perch&egrave; non 
    c'&egrave; distruttore per un <b>int</b> e tutto ci&ograve; di cui abbiamo 
    bisogno &egrave; rilasciare la memoria:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span style='color:blue'>delete</span> 
    stashIntero.remove(k);</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Tuttavia, 
    per i puntatori <b>string</b>, se si dimentica di fare il cast si avr&agrave; 
    un altro memory leak, quindi il cast &egrave; essenziale:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>delete</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> (string*) 
    stringStash.remove(k);<o:p></o:p></span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Alcuni 
    di questi problemi ( ma non tutti ) possono essere eliminati usanto i template 
    ( che si impareranno ad usare nel Capitolo 16).</span></font></p>

  <h2><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">new 
    &amp; delete per gli array<o:p></o:p><o:p></o:p></font><o:p></o:p></span></h2>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Nel 
    C++, si possono creare array di oggetti nello stack o nella heap con uguale 
    facilit&agrave;, e (naturalmente) il costruttore viene chiamato per ogni oggetto 
    dell'array. C'&egrave; un vincolo, tuttavia: ci deve essere un costruttore 
    di default, tranne per l'inizializzazione dell'aggregato sullo stack ( si 
    veda il Capitolo 6), perch&egrave; un costruttore con nessun argomento deve 
    essere chiamato per ogni oggetto.</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Quando 
    si creano array di oggetti sulla heap usando <b>new</b>, c'&egrave; qualcosa 
    altro che si deve fare. Un esempio di tale array &egrave;</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">MioTipo* 
    fp = <span style='color:blue'>new</span> MioTipo[100];</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Questo 
    alloca sufficiente spazio nella heap per 100 oggetti <b>MioTipo</b> e chiama 
    il costruttore per ognuno. Ora, tuttavia, si ha semplicemente un <b>MioTipo*</b>, 
    che &egrave; esattamente lo stesso che si avrebbe se si avesse scritto</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">MioTipo* 
    fp2 = <span style='color:blue'>new</span> MioTipo;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>per 
    creare un singolo oggetto. Poich&egrave; noi abbiamo scritto il codice, sappiamo 
    che <b>fp</b> &egrave; realmente l'indirizzo di partenza di un array, quindi 
    ha senso selezionare gli elementi dell'array usando un espressione tipo <b>fp[3]</b>. 
    Ma cosa accade quando si distrugge l'array? Le due righe</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span style='color:blue'>delete</span> 
    fp2; <span
style='color:#009900'>// OK</span></font></p>
  <p style='margin-top:0cm;margin-right:
36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span
style='color:blue'>delete</span> fp;<span style="mso-spacerun: yes">&nbsp; </span><span
style='color:#009900'>// non si ottiene l'effetto desiderato </span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>sembrano 
    esattamente le stesse e i loro effetti saranno gli stessi. Il distruttore 
    sar&agrave; chiamato per l'oggetto <b>MioTipo</b> puntato dall'indirizzo dato 
    e poi la memoria sar&agrave; rilasciata. Per <b>fp2</b> ci&ograve; va bene, 
    ma per <b>fp</b> ci&ograve; significa che le altre 99 chiamate al distruttore 
    non saranno fatte. L'esatto totale della memoria sar&agrave; ancora liberato, 
    tuttavia, poich&egrave; &egrave; allocato in un grosso pezzo e la dimensione 
    dell'intero pezzo &egrave; conservata da qualche parte dalla routine di allocazione.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    soluzione richiede che si dia al compilatore l'informazione che questo &egrave; 
    in realt&agrave; l'indirizzo di partenza di un array. Questo viene fatto con 
    la seguente sintassi:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span style='color:blue'>delete</span> 
    []fp;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Le 
    parentesi vuote dicono al compilatore di generare codice che prende il numero 
    di oggetto dell'array, memorizzati da qualche parte quando l'array viene creato 
    e chiama il distruttore tante volte quanti sono gli oggetti. Questa &egrave; 
    realmente una sintassi migliorata dalla forma precedente, che si pu&ograve; 
    ancora vedere occasionalmente nei vecchi sorgenti:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span style='color:blue'>delete</span> 
    [100]fp;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>che 
    obbliga il programmatore ad includere il numero di oggetti dell' array ed 
    ad introdurre la possibilit&agrave; che il programmatore commetta un errore. 
    L'overhead aggiuntivo per il compilatore &egrave; molto basso ed &egrave; 
    stato preferito specificare il numero di oggetti in un posto invece che in 
    due.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Un 
    puntatore pi&ugrave; simile ad un array<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Come 
    digressione, <b>fp</b> definito sopra pu&ograve; puntare a qualsiasi cosa, 
    che non ha senso per l'indirizzo di partenza di un array. Ha pi&ugrave; senso 
    definirlo come una costante , in modo che qualsiasi tentativo di modificare 
    il puntatore sar&agrave; segnalato da un errore. Per ottenere questo effetto, 
    si pu&ograve; provare</font></span></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>int</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>const</span>* q = <span style='color:blue'>new</span> <span
style='color:blue'>int</span>[10];<o:p></o:p></span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='font-family:Georgia;mso-ansi-language:EN-GB'>oppure</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>const</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>int</span>* q = <span style='color:blue'>new</span> <span
style='color:blue'>int</span>[10];<o:p></o:p></span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>ma 
    in entrambi i casi il <b>const</b> sar&agrave; vincolato all' <b>int</b>, 
    cio&egrave;, ci&ograve; a cui si punta, piuttosto che la qualit&agrave; del 
    puntatore stesso. Invece, si deve scrivere:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>int</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>* <span
style='color:blue'>const</span> q = <span style='color:blue'>new</span> <span
style='color:blue'>int</span>[10];<o:p></o:p></span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Ora 
    gli elementi dell'array in <b>q</b> possono essere modificati, ma qualsiasi 
    cambiamento a q ( tipo <b>q++</b>) &egrave; illegale, come con un ordinario 
    identificatore di array.</span></font></p>

  <h2><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Esaurimento 
    della memoria<o:p></o:p></font><o:p></o:p></span></h2>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Cosa 
    accade quando l'operatore <b>new()</b> non trova un blocco contiguo di memoria 
    largo abbastanza per mantenere l'oggetto desiderato? Una speciale funzione 
    chiamata <b>gestore del new</b> viene chiamato. O piuttosto, un puntatore 
    ad una funzione viene controllato e se il puntatore non &egrave; zero, allora 
    la funzione a cui esso punta viene chiamata.</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    comportamento di default per il gestore del new &egrave; di<i> lanciare un'eccezione</i>, 
    un argomento trattato nel Volume 2. Tuttavia, se si sta usando l'allocazione 
    nella heap nel nostro programma, &egrave; saggio almeno rimpiazzare il gestore 
    del new con un messaggio che dice che si &egrave; terminata la memoria e termina 
    il programma. In questo modo, durante il debugging, si avr&agrave; un indizio 
    di ci&ograve; che &egrave; successo. Per il programma finale si avr&agrave; 
    bisogno di usare un recupero pi&ugrave; robusto.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Si 
    rimpiazza il gestore del new includendo <b>new.h</b> e chiamando poi<b> set_new_handler(&nbsp;)</b> 
    con l'indirizzo della funzione che si vuole :</span></font></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span style='color:#009900'>//:      C13:NewHandler.cpp</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      Cambiare<span style="mso-spacerun: yes">&nbsp; </span>il gestore del new</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstdlib&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;<span
style='color:blue'>new</span>&gt;<o:p></o:p></span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>using</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> <span style='color:blue'>namespace</span>      std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>int</span>      conteggio = 0;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><o:p></o:p></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>void</span>      fine_della_memoria() {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>cerr &lt;&lt; <span
style='color:#004488'>&quot;memoria esaurita dopo&quot;</span> &lt;&lt; conteggio</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>&lt;&lt;      <span style='color:#004488'>&quot; allocazioni!&quot;</span> &lt;&lt; endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>exit(1);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>int</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> main() {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>set_new_handler(fine_della_memoria);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>while</span>(1) {</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>conteggio++;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>new</span> <span style='color:blue'>int</span>[1000]; <span
style='color:#009900'>// esaurisce la memoria</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>}</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>} <span style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    funzione gestore del new deve non avere argomenti ed avere un valore di ritorno 
    <b>void</b>, il ciclo <b>while</b> manterr&agrave; allocati oggetti <b>int</b> 
    ( e getter&agrave; via i loro indirizzi di ritorno) fino a che la memoria 
    libera viene esaurita. Alla prossima chiamata di <b>new</b>, non pu&ograve; 
    essere allocata memoria, quindi il gestore del new verr&agrave; chiamato.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    comportamento del gestore del new &egrave; legato all'operatore <b>new(),</b> 
    si si vuole fare l'overload di<b> new ()</b> ( spiegato nella prossima sezione) 
    il gestore del new non sar&agrave; chiamato per default. Se si vuole ancora 
    chiamare il gestore del new si deve scrivere il codice per fare ci&ograve; 
    dentro operatore <b>new</b> sovraccaricato.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Naturalmente, 
    si possono scrivere gestori del new pi&ugrave; sofisticati, persino uno che 
    cerca di recuperare memoria ( comunemente conosciuto come garbage collector). 
    Questo non &egrave; un compito per programmatori novizi.</span></font></p>

  <h2><span lang=EN-GB style='font-family:Verdana;mso-ansi-language:EN-GB'><font face="Verdana, Arial, Helvetica, sans-serif">Overload 
    di new &amp; delete<o:p></o:p></font><o:p></o:p></span></h2>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Quando 
    si usa <b>new</b>, accadono due cose. Primo, la memoria viene allocata usando 
    l'operatore <b>new()</b>, poi viene chiamato il costruttore. Con <b>delete</b>, 
    viene chiamato distruttore, la memoria viene deallocata usando l'operatore 
    <b>delete()</b>. Le chiamate al costruttore e distruttore non sono mai sotto 
    il proprio controllo ( altrimenti le si potrebbero sovvertire accidentalmente), 
    ma si possono cambiare le funzioni di allocazione della memoria <b>new()</b> 
    e <b>delete().</b></font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    sistema di allocazione della memoria usato da <b>new</b> e <b>delete</b> &egrave; 
    progettato per scopi generali. In situazioni speciali, tuttavia, non soddisfa 
    i propri bisogni. Il motivo pi&ugrave; comune per cambiare l'allocatore &egrave; 
    l'efficienza: si potrebbe aver creato e distrutto cos&igrave; tanti oggetti 
    di una particolare classe che &egrave; diventato un collo di bottiglia per 
    la velocit&agrave;. Il C++ permette di utilizzare l'overload per <b>new</b> 
    e <b>delete</b> per implementare il proprio meccanismo di allocazione della 
    memoria, quindi si possono gestire problemi di questo genere.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Un 
    altro problema &egrave; la frammentazione della heap. Allocando oggetti di 
    dimensioni diverse &egrave; possibile frazionare la heap al punto che effettivamente 
    si finisce lo spazio. Cio&egrave;, la memoria potrebbe essere disponibile, 
    ma a causa della frammentazione nessun pezzo &egrave; grande abbastanza per 
    soddisfare le proprie esigenze. Creando il proprio allocatore per una particolare 
    classe, si garantisce che ci&ograve; non accada mai.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Nei 
    sistemi embedded e real-time, un programma pu&ograve; dover essere eseguito 
    per un lungo periodo di tempo con risorse ristrette. Tale sistema pu&ograve; 
    anche richiedere che l'allocazione della memoria prenda sempre lo stesso tempo 
    e non sia permessa la mancanza o frammentazione di memoria. Un allocatore 
    di memoria custom &egrave; la soluzione; altrimenti, i programmatori evitano 
    del tutto di usare <b>new</b> e <b>delete</b> in tali casi perdendo un elemento 
    prezioso del C++.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Quando 
    si utilizzano gli operatori <b>new</b>() e <b>delete()</b> sovraccaricati 
    &egrave; importante ricordare che si sta cambiando solo il modo in cui la 
    memoria grezza viene allocata. Il compilatore chiamer&agrave; semplicemente 
    la nostra <b>new</b> invece di quella di default per allocare memoria, poi 
    chiamer&agrave; il costruttore per quella memoria. Quindi, sebbene il compilatore 
    alloca memoria e chiama il costruttore quando vede una <b>new</b>, tutto ci&ograve; 
    che si pu&ograve; cambiare quando si utilizza l'overload di <b>new</b> &egrave; 
    la parte di allocazione della memoria. ( <b>delete</b> ha una limitazione 
    simile).</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Quando 
    si utilizza l'overload di <b>new()</b>, si pu&ograve; anche rimpiazzare il 
    comportamento quando si esaurisce la memoria, quindi si deve decidere cosa 
    fare nell'operatore <b>new()</b>: restituire zero, scrivere un ciclo per chiamare 
    il gestore di new e ritentare l'allocazione o (tipicamente) lanciare un eccezione 
    di bad_alloc ( discussa nel Volume 2)</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'overload 
    di <b>new</b> e <b>delete</b> &egrave; identico all'overload di qualsiasi 
    altro operatore. Tuttavia, si ha la possibilit&agrave; di fare l'overload 
    dell'allocatore globale oppure utilizzare un allocatore differente per una 
    particolare classe.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Overload 
    globale di new &amp; delete <o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Questo 
    &egrave; un approccio drastico, utilizzato quando le versioni globali di new 
    e delete non soddisfano l'intero sistema. Se si sovraccaricano le versioni 
    globali, si rendono le versioni di default completamente inaccessibili e non 
    le si possono chiamare nemmeno dentro le proprie ridefinizioni.</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    versione <b>new</b> sovraccaricata prende come argomento <b>size_t</b> ( il 
    tipo standard del C Standard per le dimensioni). Questo argomento viene generato 
    e passato a noi dal compilatore ed &egrave; la dimensione dell'oggetto di 
    cui si responsabile per l'allocazione. Si deve restituire un puntatore ad 
    un oggetto di quella dimensione ( o pi&ugrave; grande , se si ha una ragione 
    di farlo) o a zero se non c'&egrave; memoria libera ( in tal caso il costruttore 
    non viene chiamato!). Tuttavia, se non c'&egrave; memoria, si dovrebbe fare 
    qualcosa in pi&ugrave; che restituire solo zero, tipo chiamare il gestore 
    del new o lanciare un&#8217;eccezione per segnalare che c'&egrave; un problema.</span></font></p>
  <p class=MsoNormal><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    valore di ritorno dell'operatore <b>new()</b> &egrave; un<b> void*, </b>non 
    un puntatore ad un tipo particolare. Tutto ci&ograve; che si fa &egrave; produrre 
    memoria, non un oggetto finito, ci&ograve; non accade finch&egrave; il costruttore 
    non viene chiamato, un atto che il compilatore garantisce e che &egrave; fuori 
    dal nostro controllo.</span> </font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'operatore 
    <b>delete()</b> prende un <b>void*</b> alla memoria che &egrave; stata allocata 
    dall'operatore new. &Egrave; un <b>void*</b> perch&egrave; l'operatore delete 
    ottiene un puntatore solo dopo che &egrave; stato chiamato il distruttore, 
    che rimuove l'oggetto dalla memoria. Il tipo di ritorno &egrave; <b>void</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Ecco 
    un esempio che mostra come sovraccaricare le versioni globali di <b>new</b> 
    e <b>delete</b>:</span></font></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span lang=EN-GB style='color:#009900;mso-ansi-language:
EN-GB'>//: C13:GlobalOperatorNew.cpp</span><span lang=EN-GB style='mso-ansi-language:
EN-GB'><o:p></o:p></span></pre>
  <pre style='margin-top:0cm;margin-right:36.0pt;
margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span lang=EN-GB
style='color:#009900;mso-ansi-language:EN-GB'>// Overload globale di new/delete</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstdio&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstdlib&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>void</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>* <span
style='color:blue'>operator</span> <span style='color:blue'>new</span>(size_t      sz) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>printf(<span
style='color:#004488'>&quot;operatore new: %d Bytes\n&quot;</span>, sz);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* m = malloc(sz);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>if</span>(!m) puts(<span style='color:#004488'>&quot;fine della      memoria</span>);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>return</span> m;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>void</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>operator</span> <span style='color:blue'>delete</span>(<span
style='color:blue'>void</span>* m) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>puts(<span
style='color:#004488'>&quot;operatore delete&quot;</span>);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>free(m);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>class</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> S {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>int</span> i[100];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>public</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>:<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>S() { puts(<span
style='color:#004488'>&quot;S::S()&quot;</span>); }<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>~S() { puts(<span
style='color:#004488'>&quot;S::~S()&quot;</span>); }<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>};</pre>
  <pre style='margin-top:0cm;margin-right:36.0pt;
margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><o:p></o:p></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>int</span>      main() {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>puts(<span
style='color:#004488'>&quot;creazione &amp; distruzione di un int&quot;</span>);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>int</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>* p = <span style='color:blue'>new</span>      <span
style='color:blue'>int</span>(47);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>delete</span> p;</pre>
  <pre style='margin-top:0cm;margin-right:
36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>puts(<span
style='color:#004488'>&quot;creazione &amp; distruzione di un s&quot;</span>);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>S* s = <span style='color:blue'>new</span>      S;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>delete</span> s;</pre>
  <pre style='margin-top:0cm;margin-right:
36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>puts(<span
style='color:#004488'>&quot;creazione &amp; distruzione S[3]&quot;</span>);</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>S* sa = <span style='color:blue'>new</span>      S[3];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>delete</span> []sa;</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'>}      <span
style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Qui 
    si pu&ograve; vedere la forma generale dell'overload di new e delete. Esse 
    usano le funzioni del C Standard <b>malloc()</b> e <b>free()</b> per gli allocatori 
    ( che usano per default anche <b>new</b> e <b>delete</b>!). Tuttavia, esse 
    stampano anche messaggi di ci&ograve; che stanno facendo. Si noti che <b>printf()</b> 
    e <b>puts()</b> vengono usate al posto di <b>iostreams</b>, perch&egrave; 
    quando un oggetto <b>iostream</b> viene creato ( come <b>cin</b>, <b>cout</b> 
    e <b>cerr</b>), esso chiama <b>new</b> per allocare memoria. Con <b>printf()</b>, 
    non si incorre in un punto morto perch&egrave; non chiama <b>new</b> per inizializzarsi.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Nel 
    <b>main()</b>, gli oggetti dei tipi predefiniti vengono creati per provare 
    che <b>new</b> e <b>delete</b> sovraccaricati vengono chiamati anche in quel 
    caso. Poi un singolo oggetto di tipo <b>S</b> viene creato, seguito da un 
    array di <b>S</b>. Per l'array, si vedr&agrave; dal numero dei byte richiesti 
    che memoria aggiuntiva viene allocata per memorizzare ( dentro l'array) il 
    numero di oggetti gestiti. In tutti i casi vengono usate le versioni globali 
    di <b>new</b> e <b>delete</b> sovraccaricate.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Overload 
    di new &amp; delete per una classe</font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Sebbene 
    non si deve esplicitamente usare <b>static</b>, quando si sovraccarica <b>new</b> 
    e <b>delete</b> per una classe, si stanno creando funzioni membro statiche. 
    Come prima, la sintassi &egrave; la stessa usata per gli operatori. Quando 
    il compilatore vede che si usa <b>new</b> per creare un oggetto della propria 
    classe, esso sceglie il membro operatore<b> new()</b> al posto della versione 
    globale. Tuttavia, le versioni globali di <b>new</b> e <b>delete</b> vengono 
    usate per tutti gli altri tipi di oggetti ( a meno che essi non hanno i loro 
    <b>new</b> e <b>delete</b>).</font></span></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Nel 
    esempio seguente, viene creato un semplice sistema di allocazione della memoria 
    per la classe <b>Framis</b>. Un pezzo di memoria &egrave; impostato a parte 
    nell'area di memoria statica alla partenza del programma e quella memoria 
    viene usata per allocare spazio per gli oggetti di tipo <b>Framis</b>. Per 
    determinare quali blocchi sono stati allocati, viene usato un semplice array, 
    un byte per ogni blocco:</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><o:p></o:p></font></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span lang=EN-GB style='color:#009900;mso-ansi-language:
EN-GB'>//: C13:Framis.cpp</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:#009900;mso-ansi-language:
EN-GB'>// Local overloaded new &amp; delete</span><span lang=EN-GB
style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstddef&gt; <span
style='color:#009900'>// Size_t</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;fstream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;<span
style='color:blue'>new</span>&gt;<o:p></o:p></span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>using</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> <span style='color:blue'>namespace</span>      std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>ofstream      out(<span
style='color:#004488'>&quot;Framis.out&quot;</span>);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>class</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Framis {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>enum</span> { sz = 10 };<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>char</span> c[sz]; <span style='color:#009900'>// occupiamo      spazio, non utilizzato</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>static</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> <span style='color:blue'>unsigned</span>      <span
style='color:blue'>char</span> pool[];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>static</span> <span style='color:blue'>bool</span> mappa_allocazione[];</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>public</span>:</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>enum</span> { pdimensione = 100 };<span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// frami permesso</span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span lang=FR
style='mso-ansi-language:FR'>Framis() { out &lt;&lt; <span style='color:#004488'>&quot;Framis()\n&quot;</span>;      }<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;      </span>~Framis() { out &lt;&lt; <span
style='color:#004488'>&quot;~Framis() ... </span></span><span lang=EN-GB
style='color:#004488;mso-ansi-language:EN-GB'>&quot;</span><span lang=EN-GB
style='mso-ansi-language:EN-GB'>; }<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* <span style='color:blue'>operator</span> <span
style='color:blue'>new</span>(size_t) <span style='color:blue'>throw</span>(bad_alloc);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span> <span style='color:blue'>operator</span> <span
style='color:blue'>delete</span>(<span style='color:blue'>void</span>*);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>};<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>unsigned</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>char</span> Framis::pool[pdimensione * <span
style='color:blue'>sizeof</span>(Framis)];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:blue'>bool</span>      Framis::mappa_allocazione[pdimensione] = {<span
style='color:blue'>false</span>};</pre>
  <pre style='margin-top:0cm;margin-right:
36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><o:p></o:p></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      la dimensione &egrave; ignorata -- si assume<span style="mso-spacerun: yes">&nbsp;      </span>un oggetto Framis<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>void</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>* <o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>Framis::<span
style='color:blue'>operator</span> <span style='color:blue'>new</span>(size_t)      <span
style='color:blue'>throw</span>(bad_alloc) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>for</span>(<span style='color:blue'>int</span> i = 0; i &lt;      pdimensione; i++)</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>if</span>(!mappa_allocazione[i]) {</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span>out &lt;&lt; <span
style='color:#004488'>&quot;utilizzo del blocco&quot;</span> &lt;&lt; i &lt;&lt;      <span
style='color:#004488'>&quot; ... &quot;</span>;</pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span>mappa_allocazione[i] = <span
style='color:blue'>true</span>; <span style='color:#009900'>// memorizziamo che      &egrave; usato </span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>return</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> pool + (i * <span style='color:
blue'>sizeof</span>(Framis));<o:p></o:p></span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span>}</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>out &lt;&lt; <span
style='color:#004488'>&quot;fine della memoria&quot;</span> &lt;&lt; endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>throw</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> bad_alloc();<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>void</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Framis::<span
style='color:blue'>operator</span> <span style='color:blue'>delete</span>(<span
style='color:blue'>void</span>* m) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>if</span>(!m) <span style='color:blue'>return</span>; <span
style='color:#009900'>// Controlliamo se &egrave; un puntatore null<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      Si assume che sia stato creato nel pool</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// calcolo del numero del blocco</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>unsigned</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> <span style='color:blue'>long</span>      blocco = (<span
style='color:blue'>unsigned</span> <span style='color:blue'>long</span>)m<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>- (<span
style='color:blue'>unsigned</span> <span style='color:blue'>long</span>)pool;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span>blocco /= <span
style='color:blue'>sizeof</span>(Framis);</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>out &lt;&lt; <span
style='color:#004488'>&quot;rilascio blocco&quot;</span> &lt;&lt; blocco&lt;&lt;      endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// impostiamo libero</span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>mappa_allocazione[blocco] = <span
style='color:blue'>false</span>;</pre>
  <pre style='margin-top:0cm;margin-right:
36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span
lang=FR style='mso-ansi-language:FR'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='color:blue;mso-ansi-language:FR'>int</span><span
lang=FR style='mso-ansi-language:FR'> main() {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;      </span>Framis* f[Framis::pdimensione];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>try</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>for</span>(<span style='color:blue'>int</span> i = 0; i &lt;      Framis::pdimensione; i++)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span>f[i] = <span
style='color:blue'>new</span> Framis;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>new</span> Framis; <span style='color:#009900'>// Fine memoria</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>} <span
style='color:blue'>catch</span>(bad_alloc) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span>cerr &lt;&lt; <span
style='color:#004488'>&quot;Fine memoria!&quot;</span> &lt;&lt; endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>}</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>delete</span> f[10];</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>f[10] = 0;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:#009900'>// Uso della memoria liberata:</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=FR style='mso-ansi-language:FR'>Framis* x = <span style='color:blue'>new</span>      Framis;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>delete</span> x;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>for</span>(<span style='color:blue'>int</span> j = 0; j &lt;      Framis::pdimensione; j++)<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>delete</span> f[j]; <span style='color:#009900'>// Delete f[10]      OK</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'>}      <span
style='color:#009900'>///:~</span><o:p></o:p></span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Lo 
    spazio di memoria per la heap di <b>Framis</b> viene creato allocando un array 
    di byte grande abbastanza per gestire <b>pdimensione</b> oggetti <b>Framis</b>. 
    La mappa di allocazione &egrave; lunga <b>pdimensione</b> elementi, quindi 
    c'&egrave; un unico <b>bool</b> per ogni blocco. Tutti i valori della mappa 
    di allocazione sono inizializzati a <b>false</b>, usando un trucco di inizializzazione 
    che prevede di settare il primo elemento in modo che il compilatore automaticamente 
    inizializza tutti gli altri al valore di default ( che &egrave; false, nel 
    caso di <b>bool</b>).</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'operatore 
    locale new() ha la stessa sintassi di quello globale. Tutto ci&ograve; che 
    fa &egrave; cercare nella mappa di allocazione i valori <b>false</b>, poi 
    setta quella locazione a <b>true</b> per indicare che &egrave; stato allocato 
    e restituisce l'indirizzo del corrispondente blocco di memoria. Se non trova 
    memoria, stampa un messaggio per tracciare il file e lancia un eccezione <b>bad_alloc</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Questo 
    &egrave; il primo esempio di eccezione che si vede in questo libro. Questo 
    &egrave; un semplice utilizzo delle eccezioni, la cui discussione &egrave; 
    rimandata al Volume 2. Nel operatore <b>new()</b> ci sono due punti importanti. 
    Il primo, la lista degli argomenti della funzione &egrave; seguito da <b>throw(bad_alloc)</b>, 
    che dice al compilatore ed al lettore che questa funzione pu&ograve; lanciare 
    un eccezione di tipo <b>bad_alloc</b>. Secondo, se non c'&egrave; pi&ugrave; 
    memoria la funzione lancia davvero l'eccezione con l'istruzione <b>throw bad_alloc</b>. 
    Quando un eccezione viene lanciata, la funzione ferma l'esecuzione ed il controllo 
    viene passato ad un <i>gestore delle eccezione</i>, che &egrave; espresso 
    dalla clausola <b>catch</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Nel 
    <b>main()</b>, si vede l'altra parte della figura, che la clausola <i>try-catch</i>. 
    Il blocco <b>try</b> &egrave; circondato da parentesi e contiene il codice 
    che pu&ograve; lanciare le eccezioni, in questo caso qualsiasi chiamata a 
    <b>new</b> che coinvolge oggetti <b>Framis</b>. Segue immediatamente al blocco 
    <b>try</b> uno o pi&ugrave; clausole <b>catch</b>, ognuna delle quali specifica 
    il tipo di eccezione che trattano. In questo caso<b> catch(bad_alloc)</b> 
    indica che le eccezioni bad_alloc saranno trattate qui. Questo particolare 
    catch viene eseguito solo quando viene lanciata un'eccezione <b>bad_alloc</b> 
    e l'esecuzione continua dopo la fine dell'ultima clausola <b>catch</b> del 
    gruppo ( ce n'&egrave; una sola qui, ma ce ne potrebbero essere di pi&ugrave;).</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>In 
    questo esempio, va bene l'uso di iostreams perch&egrave; le versioni globali 
    dell'operatore <b>new() </b>e <b>delete() </b>non sono state toccate.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'operatore<b> 
    delete() </b>assume che l'indirizzo di <b>Framis</b> sia stato creato nel 
    pool. Ci&ograve; &egrave; corretto, perch&egrave; l'operatore locale <b>new() 
    </b>verr&agrave; chiamato ogni volta si crea un singolo oggetto <b>Framis</b> 
    nella heap, ma non un array di essi: il <b>new</b> globale viene usato per 
    gli array. Quindi l'utente potrebbe aver usato accidentalmente l'operatore 
    <b>delete()</b> senza la sintassi con le parentesi vuote per indicare la distruzione 
    dell'array. Ci&ograve; causerebbe un problema. L'utente potrebbe anche cancellare 
    un puntatore ad un oggetto creato nello stack. Se si pensa che queste cose 
    accadono, sarebbe meglio aggiungere una linea per essere sicuri che l'indirizzo 
    si trova nel pool e su un confine esatto ( si comincia a vedere anche il potenziale 
    di <b>new</b> e <b>delete</b> sovraccaricati per trovare i memory leak).</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>L'operatore 
    <b>delete() </b>calcola il blocco nel pool che questo puntatore rappresenta 
    e poi imposta il flag della mappa di allocazione per quel blocco a false per 
    indicare che il blocco &egrave; stato liberato.</span></font></p>
  <p class=MsoNormal style='margin-bottom:12.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>In<b> 
    main()</b>, vengono allocati tanti oggetti <b>Framis</b> quanto basta per 
    finire la memoria, ci&ograve; evidenzia il comportamento in questo caso. Poi 
    uno degli oggetti viene liberato ed un altro viene creato per mostrare che 
    la memoria liberata viene riusata.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Poich&egrave; 
    questo meccanismo di allocazione &egrave; specifico per gli oggetti <b>Framis</b>, 
    probabilmente &egrave; molto pi&ugrave; veloce di meccanismo di allocazione 
    generico usato per default da <b>new</b> e <b>delete</b>. Tuttavia, si dovrebbe 
    notare che non funziona automaticamete se viene utilizzata l'ereditariet&agrave; 
    ( discussa nel Capitolo 14).</span></font></p>
  <p><o:p></o:p></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Overload 
    di new &amp; delete per gli array<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Se 
    si vuole usare l'overload di <b>new</b> e <b>delete</b> per una classe, questi 
    operatori vengono chiamati ogni volta che si crea un oggetto di una classe. 
    Tuttavia, se si crea un array di questi oggetti delle classi, l'operatore 
    globale <b>new() </b>viene chiamato per allocare abbastanza spazio per l'array 
    tutto in una volta e l'operatore globale <b>delete()</b> viene chiamato per 
    rilasciare quella memoria. Si pu&ograve; controllare l'allocazione di array 
    di oggetti usando la versione speciale dell'overload per la classe. Ecco un 
    esempio che mostra quando due diverse versioni vengono chiamate:</font></span></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span lang=EN-GB style='color:#009900;mso-ansi-language:
EN-GB'>//: C13:ArrayOperatorNew.cpp</span><span lang=EN-GB style='mso-ansi-language:
EN-GB'><o:p></o:p></span></pre>
  <pre style='margin-top:0cm;margin-right:36.0pt;
margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'><span lang=EN-GB
style='color:#009900;mso-ansi-language:EN-GB'>// Operatore new per arrays</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;<span
style='color:blue'>new</span>&gt; <span style='color:#009900'>// Size_t definizione</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;fstream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>ofstream      trace(<span
style='color:#004488'>&quot;ArrayOperatorNew.out&quot;</span>);<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>class</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Widget {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>enum</span> { sz = 10 };<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>int</span> i[sz];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>public</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>:<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>Widget() { trace &lt;&lt; <span
style='color:#004488'>&quot;*&quot;</span>; }<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>~Widget() { trace &lt;&lt; <span
style='color:#004488'>&quot;~&quot;</span>; }<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* <span style='color:blue'>operator</span> <span
style='color:blue'>new</span>(size_t sz) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;Widget::new: &quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span></span><span
lang=DE style='mso-ansi-language:DE'>&lt;&lt; sz &lt;&lt; <span
style='color:#004488'>&quot; bytes&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=DE style='mso-ansi-language:DE'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>return</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> ::<span style='color:blue'>new</span>      <span
style='color:blue'>char</span>[sz];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span> <span style='color:blue'>operator</span> <span
style='color:blue'>delete</span>(<span style='color:blue'>void</span>* p) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;Widget::delete&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>::<span
style='color:blue'>delete</span> []p;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* <span style='color:blue'>operator</span> <span
style='color:blue'>new</span>[](size_t sz) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;Widget::new[]: &quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </span></span><span
lang=DE style='mso-ansi-language:DE'>&lt;&lt; sz &lt;&lt; <span
style='color:#004488'>&quot; bytes&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=DE style='mso-ansi-language:DE'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span><span
lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>return</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'> ::<span style='color:blue'>new</span>      <span
style='color:blue'>char</span>[sz];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span> <span style='color:blue'>operator</span> <span
style='color:blue'>delete</span>[](<span style='color:blue'>void</span>* p) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;Widget::delete[]&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>::<span
style='color:blue'>delete</span> []p;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>      <span style="mso-spacerun: yes">&nbsp;</span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>};<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>int</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> main() {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;new Widget&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>Widget* w = <span
style='color:blue'>new</span> Widget;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;\ndelete Widget&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>delete</span> w;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;\nnew Widget[25]&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>Widget* wa = <span
style='color:blue'>new</span> Widget[25];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>trace &lt;&lt; <span
style='color:#004488'>&quot;\ndelete []Widget&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
style='color:blue'>delete</span> []wa;</pre>
  <pre style='margin-top:0cm;
margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt'>}      <span
style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Qui, 
    le versioni globali di <b>new</b> e <b>delete</b> vengono chiamate in modo 
    che l'effetto &egrave; lo stesso di non avere le versioni con l'overload di 
    <b>new</b> e <b>delete</b> tranne che viene aggiunta un informazioni di trace. 
    Naturalmente, si pu&ograve; usare qualsiasi meccanismo di allocazione che 
    si vuole con <b>new</b> e <b>delete</b> sovraccaricate.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Si 
    pu&ograve; vedere che la sintassi di <b>new</b> e <b>delete</b> per gli array 
    &egrave; la stessa per gli oggetti individuali tranne per l'aggiunta delle 
    parentesi. In entrambi i casi si gestisce la dimensione della memoria che 
    si deve allocare. La dimensione per versione array sar&agrave; la dimensione 
    dell'intero array. Vale la pena di tenere in mente che l'unica cosa che &egrave; 
    richiesta di fare con l'operatore<b> new() </b>&egrave; di fornire un puntatore 
    ad un blocco di memoria abbastanza grande. Sebbene si pu&ograve; inizializzare 
    la memoria, normalmente questo &egrave; il lavoro del costruttore che sar&agrave; 
    chiamato automaticamente dal compilatore.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    costruttore ed il distruttore stampano quindi si pu&ograve; vedere quando 
    vengono chiamati. Ecco come appare il file di trace per un compilatore:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>new</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Widget<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'>Widget::<span
style='color:blue'>new</span>: 40 bytes<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'>*<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>delete</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Widget<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'>~Widget::<span
style='color:blue'>delete</span><o:p></o:p></span></font></p>
  <p style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>new</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Widget[25]<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'>Widget::<span
style='color:blue'>new</span>[]: 1004 bytes<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'>*************************<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>delete</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> []Widget<o:p></o:p></span></font></p>
  <p
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span lang=EN-GB style='mso-ansi-language:EN-GB'>~~~~~~~~~~~~~~~~~~~~~~~~~Widget::<span
style='color:blue'>delete</span>[] <o:p></o:p></span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Creare 
    un oggetto individuale richiede 40 byte, come ci si aspetta. (Questa macchina 
    usa quattro byte per un <b>int</b>). Viene chiamato prima l'operatore<b> new() 
    </b>e poi il costruttore( indicato da un *). In maniera complementare, chiamando 
    <b>delete</b> viene chiamato il prima il distruttore e poi l'operatore <b>delete()</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Quando 
    viene creato un array di <b>Widget</b>, viene usata la versione array dell'operatore<b> 
    new()</b>, come promesso. Ma si noti che la dimensione richiesta &egrave; 
    pi&ugrave; grande dei quattro byte che ci si aspetta. Questi ulteriori quattro 
    byte servono al sistema per le informazioni sull'array, in particolare, il 
    numero di oggetti dell'array. Quindi quando si scrive:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif"><span style='color:blue'>delete</span> 
    []Widget;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>le 
    parentesi dicono al compilatore che &egrave; un array di oggetti, quindi il 
    compilatore genera codice per conoscere il numero di oggetti nell'array e 
    per chiamare il distruttore tante volte quanto serve. Come si vede, sebbene 
    l'operatore <b>new() </b>e <b>delete()</b> per array sono chiamati solo una 
    volta per l'intero blocco di array, il costruttore ed il distruttore di default 
    vengono chiamati per ogni oggetto dell'array.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Chiamate 
    al costruttore<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Si 
    consideri</font></span></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">MioTipo* 
    f = <span style='color:blue'>new</span> MioTipo;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>chiama 
    <b>new</b> per allocare un pezzo di memoria grande quanto <b>MioTipo</b>, 
    poi invoca il costruttore di <b>MioTipo</b> sulla memoria, cosa accade se 
    non si riesce ad allocare memoria con <b>new</b>? Il costruttore non viene 
    chiamato in questo caso, quindi sebbene si crea un oggetto senza successo, 
    almeno non si invoca il costruttore e si gestisce un puntatore <b>this</b> 
    che vale zero. Ecco un esempio:</span></font></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span style='color:#009900'>//:      C13:NoMemory.cpp</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      Il Costruttore non viene chiamato se new fallisce</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;<span
style='color:blue'>new</span>&gt; <span style='color:#009900'>// definizione bad_alloc<o:p></o:p></span></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>class</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> NoMemory      {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>public</span><span lang=EN-GB style='mso-ansi-language:EN-GB'>:<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>FineMemoria() {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>cout &lt;&lt; <span
style='color:#004488'>&quot;FineMemoria::FineMemoria()&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* <span style='color:blue'>operator</span> <span
style='color:blue'>new</span>(size_t sz) <span style='color:blue'>throw</span>(bad_alloc){<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>cout &lt;&lt; <span
style='color:#004488'>&quot;FineMemoria::operatore new&quot;</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>throw</span> bad_alloc(); <span style='color:#009900'>// &quot;Fine      Memoria&quot;</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>};<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>int</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> main() {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>FineMemoria* nm = 0;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>try</span> {<o:p></o:p></span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>nm = <span
style='color:blue'>new</span> FineMemoria;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>} <span
style='color:blue'>catch</span>(bad_alloc) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span></span>cerr &lt;&lt; <span
style='color:#004488'>&quot;eccezione: Memoria terminata&quot;</span> &lt;&lt;      endl;</pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>cout &lt;&lt; <span
style='color:#004488'>&quot;nm = &quot;</span> &lt;&lt; nm &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>} <span style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Quando 
    il programma viene eseguito, non stampa il messaggio del costruttore, ma il 
    messaggio del operatore <b>new()</b> ed il messaggio del gestore dell'eccezione. 
    Poich&egrave; <b>new</b> non ritorna mai, il costruttore non viene mai chiamato 
    quindi il suo messaggio non viene stampato.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>&Egrave; 
    importante che <b>nm</b> sia inizializzato a zero poich&egrave; l'espressione 
    <b>new</b> non termina mai ed il puntatore dovrebbe essere zero per essere 
    sicuri che non se ne faccia un cattivo uso. Tuttavia, si dovrebbe fare qualcosa 
    in pi&ugrave; nel gestore dell'eccezione che stampare solo un messaggio e 
    continuare come se l'oggetto fosse stato creato correttamente. Idealmente 
    si far&agrave; qualcosa che risolver&agrave; il problema e si uscir&agrave; 
    dopo aver riportato l'errore su un file di log.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Nelle 
    prime versioni del C++ era una pratica normale restituire zero da un <b>new</b> 
    se falliva l'allocazione della memoria. Tuttavia, se si prova a restituire 
    zero da un <b>new</b> con un compilatore Standard, ci viene detto che si dovrebbe 
    invece lanciare un'eccezione di <b>bad_alloc</b>.</span></font></p>

  <h3><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">placement 
    new &amp; delete( new e delete con piazzamento)<o:p></o:p></font><o:p></o:p></span></h3>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Ci 
    sono altri due, meno comuni, utilizzi del overload per l'operatore <b>new().</b></font></span></p>
  <ol start=1 type=1>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l4 level1 lfo4;tab-stops:list 36.0pt'> 
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Si pu&ograve; volere piazzare un oggetto in una specifica locazione 
        di memoria. Ci&ograve; ha particolare importanza con i sistemi embedded 
        hardware dove un oggetto pu&ograve; essere sinonimo di un particolare 
        pezzo di hardware.</span></font></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l4 level1 lfo4;tab-stops:list 36.0pt'> 
      <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Si pu&ograve; volere scegliere fra diversi allocatori quando si 
        usa <b>new</b>.</span></font></p>
    </li>
  </ol>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Entrambe 
    le situazione sono gestite con lo stesso meccanismo: l'operatore <b>new() 
    </b>sovraccaricato accetta pi&ugrave; di un argomento. Come si &egrave; visto 
    prima, il primo argomento &egrave; sempre la dimensione dell'oggetto, che 
    &egrave; calcolato di nascosto e passato dal compilatore. Ma l'altro argomento 
    pu&ograve; essere qualsiasi cosa si voglia, l'indirizzo dove si vuole che 
    l'oggetto sia piazzato, un riferimento alla funzione di allocazione della 
    memoria oppure oggetto o qualsiasi altra cosa.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Il 
    modo in cui si passa l'argomento extra all'operatore <b>new()</b> durante 
    una chiamata pu&ograve; sembrare un p&ograve; curioso all'inizio. Si mette 
    la lista degli argomenti ( <i>senza</i> l'argomento <b>size_t</b>, che &egrave; 
    gestito dal compilatore) dopo la parola chiave new e prima del nome della 
    classe dell'oggetto che si sta creando. Per esempio,</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">X* 
    xp = <span style='color:blue'>new</span>(a) X;</font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>passer&agrave; 
    a come secondo argomento all'operatore <b>new().</b> Naturalmente, ci&ograve; 
    funziona solo se tale operatore<b> new() </b>&egrave; stato dichiarato.</span></font></p>
  <p style='margin-bottom:12.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Ecco 
    un esempio che mostra come su pu&ograve; piazzare un oggetto in una particolare 
    locazione:</span></font></p>
  <pre style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><span style='color:#009900'>//:      C13:PlacementOperatorNew.cpp</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      Piazzamento con operatore new()</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;cstddef&gt; <span
style='color:#009900'>// Size_t</span><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>#include      &lt;iostream&gt;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>using</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> <span
style='color:blue'>namespace</span> std;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>class</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> X {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>int</span> i;<o:p></o:p></span></pre>
  <pre style='margin-top:
0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;margin-bottom:
.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:EN-GB'>public</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'>:<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>X(<span
style='color:blue'>int</span> ii = 0) : i(ii) {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>cout &lt;&lt; <span
style='color:#004488'>&quot;this = &quot;</span> &lt;&lt; <span
style='color:blue'>this</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>~X() {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span>cout &lt;&lt; <span
style='color:#004488'>&quot;X::~X(): &quot;</span> &lt;&lt; <span
style='color:blue'>this</span> &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span><span
style='color:blue'>void</span>* <span style='color:blue'>operator</span> <span
style='color:blue'>new</span>(size_t, <span style='color:blue'>void</span>* loc)      {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;      </span><span
style='color:blue'>return</span> loc;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span>}<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'>};<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='color:blue;mso-ansi-language:
EN-GB'>int</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> main() {<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=EN-GB style='mso-ansi-language:EN-GB'><span style="mso-spacerun: yes">&nbsp;      </span></span><span
lang=FR style='color:blue;mso-ansi-language:FR'>int</span><span lang=FR
style='mso-ansi-language:FR'> l[10];<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;      </span>cout &lt;&lt; <span
style='color:#004488'>&quot;l = &quot;</span> &lt;&lt; l &lt;&lt; endl;<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span lang=FR style='mso-ansi-language:FR'><span style="mso-spacerun: yes">&nbsp;      </span></span>X* xp = <span
style='color:blue'>new</span>(l) X(47); <span style='color:#009900'>// X alla      locazione location l</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style="mso-spacerun: yes">&nbsp;      </span>xp-&gt;X::~X(); <span
style='color:#009900'>// Chiamata esplicita al distruttore<o:p></o:p></span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'><span style='color:#009900'>//      Da usare solo con il piazzamento!</span></pre>
  <pre
style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:36.0pt;
margin-bottom:.0001pt'>} <span style='color:#009900'>///:~</span></pre>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Si 
    noti che l'operatore <b>new</b> restituisce solo il puntatore che gli viene 
    passato. Quindi, il chiamante decide dove l'oggetto verr&agrave; situato ed 
    il costruttore viene chiamato per quella memoria come parte dell'espressione 
    new.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Sebbene 
    questo esempio mostra solo un argomento addizionale, nulla ci impedisce di 
    aggiungerne altri se ce ne &egrave; il bisogno per altri scopi. </span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Un 
    dilemma accade quando si vuole distruggere l'oggetto. C'&egrave; un'unica 
    versione dell'operatore <b>delete</b>, quindi non c'&egrave; modo di dire: 
    &quot;Usa il mio speciale deallocatore per questo oggetto&quot;. Si vuole 
    chiamare il distruttore, ma non si vuole che la memoria venga liberata dal 
    meccanismo che gestisce la memoria dinamica poich&egrave; non &egrave; stata 
    allocata nella heap.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>La 
    risposta &egrave; data da una sintassi molto speciale. Si pu&ograve; esplicitare 
    la chiamata del distruttore:</span></font></p>
  <p style='margin-top:0cm;margin-right:36.0pt;margin-bottom:0cm;margin-left:
36.0pt;margin-bottom:.0001pt'><font face="Georgia, Times New Roman, Times, serif">xp-&gt;X::~X(); 
    <span style='color:#009900'>// Chiamata esplicita al distruttore</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>Un 
    austero warning &egrave; di regola qui. Qualcuno vede ci&ograve; come un modo 
    per distruggere gli oggetti un p&ograve; di tempo prima della fine dello scope, 
    piuttosto che modificare lo scope o ( pi&ugrave; correttamente ) usare la 
    creazione dinamica degli oggetti se si vuole che il tempo di vita dell'oggetto 
    sia determinato a runtime. Si avranno seri problemi se si chiama il distruttore 
    in questo modo per un oggetto creato in modo normale sullo stack perch&egrave; 
    il distruttore verr&agrave; chiamato di nuovo alla fine dello scope. Se si 
    chiama il distruttore per un oggetto creato nella heap, il distruttore verr&agrave; 
    eseguito, ma la memoria non verr&agrave; rilasciata, che probabilmente non 
    &egrave; ci&ograve; che si vuole. L'unica ragione per cui il distruttore pu&ograve; 
    essere chiamato esplicitamente in questo modo &egrave; supportare la sintassi 
    per il piazzamento dell'operatore <b>new</b>.</span></font></p>
  <p><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:Georgia'>C'&egrave; 
    anche un operatore <b>delete</b> con piazzamento che viene chiamato solo se 
    un costruttore per un <b>new</b> con piazzamento lanci un' eccezione ( in 
    modo che la memoria viene automaticamente pulita durante l'eccezione). L'operatore 
    delete con piazzamento ha una lista di argomenti che corrisponde all'operatore 
    <b>new</b> con piazzamento che viene chiamato prima che il costruttore lancia 
    l'eccezione. Questo argomento verr&agrave; esplorato nel capitolo della gestione 
    delle eccezioni nel Volume 2.</span></font></p>

  <h2><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Sommario<o:p></o:p></font><o:p></o:p></span></h2>

  <p><span style='font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">&Egrave; 
    conveniente e molto efficiente creare oggetti automatici nello stack, ma per 
    risolvere il programma della programmazione generale si deve poter creare 
    e distruggere oggetti in ogni momento durante l'esecuzione di un programma, 
    in particolare per rispondere alle informazioni dall'esterno del programma. 
    Sebbene l'allocazione dinamica della memoria in C avverr&agrave; nella heap, 
    essa non fornisce la facilit&agrave; di utilizzo e le garanzie del C++. Portando 
    la creazione dinamica di oggetti nel nucleo del linguaggio con <b>new</b> 
    e <b>delete</b>, si possono creare oggetti nella heap facilmente come si fa 
    nello stack. In aggiunta, si ottiene una grande flessibilit&agrave;. Si pu&ograve; 
    cambiare il comportamento di <b>new</b> e <b>delete</b> se non sono adatti 
    ai propri bisogni, in particolare se non sono abbastanza efficienti. Si pu&ograve; 
    anche modificare ci&ograve; che avviene quando finisce lo spazio nella heap.</font></span></p>

  <h2><span style='font-family:Verdana'><font face="Verdana, Arial, Helvetica, sans-serif">Esercizi<o:p></o:p></font><o:p></o:p></span></h2>

  <p><span style='font-size:10.0pt;font-family:Georgia'><font face="Georgia, Times New Roman, Times, serif">Le 
    soluzioni agli esercizi selezionati possono essere trovate nel documento elettronico 
    <i>The Thinking in C++ Annotated Solution Guide</i>, disponibile in cambio 
    di un piccolo onorario su www.BruceEckel.com.</font></span></p>
  <ol start=1 type=1>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Creare una <b>classe Counted </b>che contiene un <b>int</b> <b>id</b> 
      ed un <b>static int count</b>. Il costruttore di default dovrebbe avere:</span><br>
      <b><span style='font-family:
     Georgia'><b>Counted</b></span><span style='font-family:Georgia'>(&nbsp;) 
      : id(</span><span style='font-family:
     Georgia'><b>count</b></span><span style='font-family:Georgia'>++) {</span></b><span
     style='font-family:Georgia'>. Dovrebbe anche stampare il suo <b>id</b> e 
      che &egrave; stato creato. Il distruttore dovrebbe stampare che &egrave; 
      l'oggetto &egrave; stato distrutto ed il suo <b>id</b>. Si testi la classe.</span> 
      </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Si provi che <b>new</b> e <b>delete</b> chiamano sempre i costruttori 
      e distruttori, creando un oggetto della classe <b>Counted</b>( dall'esercizio 
      1 ) con <b>new</b> e lo distruggendolo con <b>delete</b>. Creare e distruggere 
      un array di questi oggetti anche nella heap.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Creare un oggetto <b>PStash</b> e riempirlo di oggetti dell'esercizio 
      1. Osservare cosa accade quando questo oggetto <b>PStash</b> perde lo scope 
      e viene chiamato il suo distruttore.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Creare un <b>vector&lt; Counted*&gt;</b> riempirlo di oggetti <b>Counted</b>usando 
      <b>new</b> (dall'esercizio 1). Muoversi nel <b>vector</b> e stampare gli 
      oggetti <b>Counted</b>, poi spostandosi di nuovo eliminare ognuno di essi.</span> 
      </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Ripetere l'esercizio 4, ma aggiungere la funzione membro<b> f() 
      </b>a <b>Counted</b> che stampa un messaggio. Muoversi attraverso il vettore 
      e chiamare <b>f()</b> per ogni oggetto.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Ripetere l'esercizio 5 usando un <b>PStash</b>.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Ripetere l'esercizio 5 usando <b>Stack4.h</b> dal Capitolo 9.</span> 
      </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Creare dinamicamente un array di oggetti della classe <b>Counted</b>(dall'esercizio 
      1). Chiamare <b>delete</b> per il puntatore risultante , <i>senza le parentesi 
      quadrate</i>. Spiegare i risultati.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Creare un oggetto della classe Contati (Esercizio 1) usando <b>new</b>, 
      castare il puntatore risultante a <b>void* </b>e cancellarlo. Spiegare i 
      risultati.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Eseguire <b>NewHandler.cpp</b> sul proprio computer per vedere il 
      conteggio. Calcolare il totale di memoria libera disponibile per il proprio 
      programma.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Creare una classe con operatori <b>new</b> e <b>delete</b> sovraccaricati, 
      entrambi nelle versioni per oggetto singolo e array. Dimostrare che entrambe 
      le versioni funzionano.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Concepire un test per <b>Framis.cpp</b> per mostrare approssimatamente 
      quanto siano pi&ugrave; veloci le versioni custom di<b> new</b> e <b>delete</b> 
      delle loro versione globale.</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Modificare <b>NoMemory.cpp</b> in modo che contenga un array di 
      <b>int</b> e quindi che allochi davvero memoria invece di lanciare <b>bad_alloc</b>. 
      Nel <b>main()</b>, usare un ciclo <b>while</b> come in <b>NewHandler.cpp</b> 
      per esaurire la memoria e vedere cosa accade se l'operatore <b>new</b> non 
      verifica che la memoria &egrave; stata allocata con successo. Aggiungere 
      un controllo per l'operatore <b>new</b> e lanciare <b>bad_alloc</b>.</span> 
      </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Creare una classe con un <b>new</b> con piazzamento con secondo 
      argomento un tipo <b>string</b>. La classe dovrebbe contenere un <b>static 
      vector&lt;string&gt;</b> dove viene memorizzato il secondo argomento di 
      <b>new</b>. Il <b>new</b> con piazzamento dovrebbe allocare memoria normalmente. 
      Nel <b>main()</b>, chiamare pi&ugrave; volte ( si dovrebbero usare le macro 
      del preprocessore <b>__FILE__</b> e <b>__LINE__</b>).</span> </font></li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo5;tab-stops:list 36.0pt'><font face="Georgia, Times New Roman, Times, serif"><span style='font-family:
     Georgia'>Modificare <b>ArrayOperatorNew.cpp</b> aggiungendo un <b>static 
      vector&lt;Widget*&gt;</b> che aggiunge ogni indirizzo <b>Widget</b> che 
      &egrave; allocato nell'<b>operator new<u>( )</u></b> e lo rimuove quando 
      viene rilasciato con l'<b>operatore delete<u>( )</u></b> ( si potrebbe aver 
      bisogno di informazioni circa <b>vector</b> nella propria documentazione 
      della libreria Standard C++ o del secondo volume di questo libro). Creare 
      una seconda classe chiamata <b>MemoryChecker </b>che ha un distruttore che 
      stampa il numero di puntatori <b>Widget </b>nel<b> vector</b>. Creare un 
      programma con una singola istanza globale di <b>MemoryChecker</b> e in <b>main(&nbsp;)</b>, 
      allocare dinamicamente e distruggere molti oggetti e array di <b>Widget</b>. 
      Mostrare che <b>MemoryChecker</b> rivela memory leak.</span> </font></li>
  </ol>


<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>
  </div>
  <p><font face="Georgia, Times New Roman, Times, serif"><a name=fn50></a><a href="#fnB50"><span style='mso-bookmark:fn50'>[50]</span></a><span
style='font-size:10.0pt;font-family:Georgia'> C'&egrave; un sintassi speciale 
    chiamata <i>placement new</i> la quale permette di chiamare un costruttore 
    per un pezzo di memoria pre-allocato. Questo argomento verr&agrave; introdotto 
    pi&ugrave; in avanti nel capitolo.</span></font></p>

  <p align=center style='text-align:center'><span style='font-size:10.0pt;
font-family:Verdana'>[ </span><a href="Capitolo12.html"><span style='font-size:
10.0pt;font-family:Verdana'>Capitolo Precedente </span></a><span
style='font-size:10.0pt;font-family:Verdana'>] [ </span><a href="Contents.html"><span
style='font-size:10.0pt;font-family:Verdana'>Indice Generale</span></a><span
style='font-size:10.0pt;font-family:Verdana'> ] [ </span><a href="DocIndex.html"><span
style='font-size:10.0pt;font-family:Verdana'>Indice Analitico </span></a><span
style='font-size:10.0pt;font-family:Verdana'>] [ </span><a
href="Capitolo14.html"><span style='font-size:10.0pt;font-family:Verdana'>Prossimo 
    Capitolo</span></a><span style='font-size:10.0pt;font-family:Verdana'> ] </span></p>

  <p class=MsoNormal align=center style='text-align:center'><span lang=EN-GB
style='mso-ansi-language:EN-GB'><font face="Georgia, Times New Roman, Times, serif">Ultima 
    modifica: 12/11/2002 <o:p></o:p></font><o:p></o:p></span></p>

</div>

</body>

</html>
